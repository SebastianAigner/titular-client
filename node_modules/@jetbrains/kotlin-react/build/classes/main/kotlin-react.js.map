{"version":3,"file":"kotlin-react.js","sources":["../../../src/main/kotlin/react/HOC.kt","../../../src/main/kotlin/react/RBuilder.kt","collections/Collections.kt","kotlin/collections.kt","util/Standard.kt","../../../src/main/kotlin/kotlinext/js/Helpers.kt","../../../src/main/kotlin/react/React.kt","../../../src/main/kotlin/react/ReactComponent.kt","util/Preconditions.kt"],"sourcesContent":["package react\n\nimport kotlinext.js.*\n\nexternal interface HOC<out P : RProps, in R : RProps> : JsFunction<Nothing?, RClass<R>>\n\noperator fun <P : RProps, R : RProps> HOC<P, R>.invoke(component: RClass<P>) =\n    call(null, component)\n\noperator fun <P : RProps, R : RProps> HOC<P, R>.invoke(component: RBuilder.(P) -> Unit) =\n    call(null, { props: P ->\n        buildElements {\n            component(props)\n        }\n    })\n\noperator fun <P : RProps, R : RProps> HOC<P, R>.invoke(config: Any, component: RBuilder.(P) -> Unit) =\n    call(null, { props: P ->\n        buildElements {\n            component(props)\n        }\n    }, config)\n","package react\n\nimport kotlinext.js.*\nimport kotlin.reflect.*\n\n@DslMarker\nannotation class ReactDsl\n\n@ReactDsl\nopen class RBuilder {\n    val childList = mutableListOf<Any>()\n\n    fun child(element: ReactElement): ReactElement {\n        childList.add(element)\n        return element\n    }\n\n    operator fun String.unaryPlus() {\n        childList.add(this)\n    }\n\n    fun <P : RProps> child(type: Any, props: P, children: List<Any>) =\n        child(createElement(type, props, *children.toTypedArray()))\n\n    fun <P : RProps> child(type: Any, props: P, handler: RHandler<P>): ReactElement {\n        val children = with(RElementBuilder(props)) {\n            handler()\n            childList\n        }\n        return child(type, props, children)\n    }\n\n    operator fun <P : RProps> RClass<P>.invoke(handler: RHandler<P>) =\n        child(this, jsObject {}, handler)\n\n    operator fun <T> RProvider<T>.invoke(value: T, handler: RHandler<RProviderProps<T>>) =\n        child(this, jsObject { this.value = value }, handler)\n\n    operator fun <T> RConsumer<T>.invoke(handler: RBuilder.(T) -> Unit) =\n        child(this, jsObject<RConsumerProps<T>> {\n            this.children = { value ->\n                buildElements { handler(value) }\n            }\n        }) {}\n\n    fun <P : RProps> RClass<P>.node(\n        props: P,\n        children: List<Any> = emptyList()\n    ) = child(this, clone(props), children)\n\n    fun <P : RProps, C : Component<P, *>> child(klazz: KClass<C>, handler: RHandler<P>): ReactElement {\n        val rClass = klazz.js as RClass<P>\n        return rClass(handler)\n    }\n\n    inline fun <P : RProps, reified C : Component<P, *>> child(noinline handler: RHandler<P>) =\n        child(C::class, handler)\n\n    fun <P : RProps, C : Component<P, *>> node(\n        klazz: KClass<C>,\n        props: P,\n        children: List<Any> = emptyList()\n    ): ReactElement {\n        val rClass = klazz.js as RClass<P>\n        return rClass.node(props, children)\n    }\n\n    inline fun <P : RProps, reified C : Component<P, *>> node(props: P, children: List<Any> = emptyList()) =\n        node(C::class, props, children)\n\n    fun RProps.children() {\n        childList.addAll(Children.toArray(children))\n    }\n}\n\nopen class RBuilderMultiple : RBuilder() {\n}\n\nfun buildElements(handler: RBuilder.() -> Unit): dynamic {\n    val nodes = RBuilder().apply(handler).childList\n    return when {\n        nodes.size == 0 -> null\n        nodes.size == 1 -> nodes.first()\n        else -> createElement(Fragment, js {}, *nodes.toTypedArray())\n    }\n}\n\nopen class RBuilderSingle : RBuilder() {\n}\n\ninline fun buildElement(handler: RBuilder.() -> Unit): ReactElement? =\n    RBuilder().apply(handler).childList.first() as ReactElement?\n\nopen class RElementBuilder<out P : RProps>(open val attrs: P) : RBuilder() {\n    fun attrs(handler: P.() -> Unit) {\n        attrs.handler()\n    }\n\n    var key: String\n        get() = attrs.key\n        set(value) {\n            attrs.key = value\n        }\n\n    var ref: RRef\n        get() = attrs.ref\n        set(value) {\n            attrs.ref = value\n        }\n\n    fun ref(handler: (dynamic) -> Unit) {\n        attrs.ref(handler)\n    }\n}\n\ntypealias RHandler<P> = RElementBuilder<P>.() -> Unit\n\nfun <P : RProps> forwardRef(handler: RBuilder.(RProps, RRef) -> Unit): RClass<P> {\n    return rawForwardRef { props, ref ->\n        buildElements { handler(props, ref) }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.*\nimport kotlin.comparisons.compareValues\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which [comparison] function returns zero using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the provided [comparison],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that compares an element of the list with the element being searched.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\nimport kotlin.comparisons.naturalOrder\nimport kotlin.math.floor\n\n/** Returns the array if it's not `null`, or an empty array otherwise. */\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Array<out T>?.orEmpty(): Array<out T> = this ?: emptyArray<T>()\n\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Collection<T>.toTypedArray(): Array<T> = copyToArray(this)\n\n@JsName(\"copyToArray\")\n@PublishedApi\ninternal fun <T> copyToArray(collection: Collection<T>): Array<T> {\n    return if (collection.asDynamic().toArray !== undefined)\n        collection.asDynamic().toArray().unsafeCast<Array<T>>()\n    else\n        copyToArrayImpl(collection).unsafeCast<Array<T>>()\n}\n\n@JsName(\"copyToArrayImpl\")\ninternal actual fun copyToArrayImpl(collection: Collection<*>): Array<Any?> {\n    val array = emptyArray<Any?>()\n    val iterator = collection.iterator()\n    while (iterator.hasNext())\n        array.asDynamic().push(iterator.next())\n    return array\n}\n\n@JsName(\"copyToExistingArrayImpl\")\ninternal actual fun <T> copyToArrayImpl(collection: Collection<*>, array: Array<T>): Array<T> {\n    if (array.size < collection.size)\n        return copyToArrayImpl(collection).unsafeCast<Array<T>>()\n\n    val iterator = collection.iterator()\n    var index = 0\n    while (iterator.hasNext()) {\n        array[index++] = iterator.next().unsafeCast<T>()\n    }\n    if (index < array.size) {\n        array[index] = null.unsafeCast<T>()\n    }\n    return array\n}\n\n@library(\"arrayToString\")\n@Suppress(\"UNUSED_PARAMETER\")\ninternal fun arrayToString(array: Array<*>): String = definedExternally\n\n/**\n * Returns an immutable list containing only the specified object [element].\n */\npublic fun <T> listOf(element: T): List<T> = arrayListOf(element)\n\n/**\n * Returns an immutable set containing only the specified object [element].\n */\npublic fun <T> setOf(element: T): Set<T> = hashSetOf(element)\n\n/**\n * Returns an immutable map, mapping only the specified key to the\n * specified value.\n */\npublic fun <K, V> mapOf(pair: Pair<K, V>): Map<K, V> = hashMapOf(pair)\n\n/**\n * Fills the list with the provided [value].\n *\n * Each element in the list gets replaced with the [value].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.fill(value: T): Unit {\n    for (index in 0..lastIndex) {\n        this[index] = value\n    }\n}\n\n/**\n * Randomly shuffles elements in this list.\n *\n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.shuffle(): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = rand(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\nprivate fun rand(upperBound: Int) = floor(kotlin.js.Math.random() * upperBound).toInt()\n\n/**\n * Returns a new list with the elements of this list randomly shuffled.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> Iterable<T>.shuffled(): List<T> = toMutableList().apply { shuffle() }\n\n/**\n * Sorts elements in the list in-place according to their natural sort order.\n */\npublic actual fun <T : Comparable<T>> MutableList<T>.sort(): Unit {\n    collectionsSort(this, naturalOrder())\n}\n\n/**\n * Sorts elements in the list in-place according to the order specified with [comparator].\n */\npublic actual fun <T> MutableList<T>.sortWith(comparator: Comparator<in T>): Unit {\n    collectionsSort(this, comparator)\n}\n\nprivate fun <T> collectionsSort(list: MutableList<T>, comparator: Comparator<in T>) {\n    if (list.size <= 1) return\n\n    val array = copyToArray(list)\n\n    array.asDynamic().sort(comparator.asDynamic().compare.bind(comparator))\n\n    for (i in 0 until array.size) {\n        list[i] = array[i]\n    }\n}\n\ninternal actual fun <T> arrayOfNulls(reference: Array<T>, size: Int): Array<T> {\n    return arrayOfNulls<Any>(size).unsafeCast<Array<T>>()\n}\n\n// no singleton map implementation in js, return map as is\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<K, V>.toSingletonMapOrSelf(): Map<K, V> = this\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<out K, V>.toSingletonMap(): Map<K, V> = this.toMutableMap()\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <T> Array<out T>.copyToArrayOfAny(isVarargs: Boolean): Array<out Any?> =\n    if (isVarargs)\n    // no need to copy vararg array in JS\n        this\n    else\n        this.copyOf()\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.internal.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","package kotlinext.js\n\ninline fun <T : Any> jsObject(builder: T.() -> Unit): T {\n    val obj: T = js(\"({})\")\n    return obj.apply {\n        builder()\n    }\n}\n\ninline fun js(builder: dynamic.() -> Unit): dynamic = jsObject(builder)\n\nfun <T : Any> clone(obj: T) = assign(jsObject<T> {}, obj)\ninline fun <T : Any> assign(obj: T, builder: T.() -> Unit) = clone(obj).apply(builder)\n\nfun toPlainObjectStripNull(obj: Any) = js {\n    for (key in Object.keys(obj)) {\n        val value = obj.asDynamic()[key]\n        if (value != null) this[key] = value\n    }\n}\n","package react\n\nimport kotlinext.js.*\n\nexternal interface Child\n\nfun Child.isString(): Boolean = asDynamic() is String\n\nfun Child.asStringOrNull(): String? = when {\n    isString() -> asDynamic()\n    else -> null\n}\n\nfun Child.asElementOrNull(): ReactElement? = when {\n    asJsObject().hasOwnProperty(\"\\$\\$typeof\") -> asDynamic()\n    else -> null\n}\n\nexternal interface ReactElement : Child {\n    val props: RProps\n}\n\nfun Children.forEachElement(children: Any?, handler: (ReactElement) -> Unit) =\n    forEach(children) {\n        val element = it.asElementOrNull()\n        element?.let(handler)\n    }\n\ninline fun <P : RProps> cloneElement(\n    element: ReactElement,\n    vararg child: Any?,\n    props: P.() -> Unit\n): ReactElement = cloneElement(element, jsObject(props), *child)\n\nfun clone(element: dynamic, props: dynamic, child: Any? = null): ReactElement =\n    cloneElement(element, props, *Children.toArray(child))\n\n","package react\n\nimport kotlinext.js.*\n\n// Props\nexternal interface RProps\n\nval RProps.children: Any get() = asDynamic().children\nvar RProps.key: String\n    get() = error(\"key cannot be read from props\")\n    set(value) {\n        asDynamic().key = value\n    }\n\nvar RProps.ref: RRef\n    get() = error(\"ref cannot be read from props\")\n    set(value) {\n        asDynamic().ref = value\n    }\n\nfun <T> RProps.ref(ref: (T?) -> Unit) {\n    asDynamic().ref = ref\n}\n\n// State\nexternal interface RState\n\nclass BoxedState<T>(var state: T) : RState\n\n// Error info\nexternal interface RErrorInfo\n\nval RErrorInfo.componentStack: Any get() = asDynamic().componentStack\n\nexternal interface RClass<in P : RProps> {\n    var displayName: String?\n}\n\nexternal interface RProviderProps<T> : RProps {\n    var value: T\n}\n\nexternal interface RProvider<T> : RClass<RProviderProps<T>>\n\nexternal interface RConsumerProps<T> : RProps {\n    var children: (T) -> Any\n}\n\nexternal interface RConsumer<T> : RClass<RConsumerProps<T>>\n\n// Context\nexternal interface RContext<T> {\n    val Provider: RProvider<T>\n    val Consumer: RConsumer<T>\n}\n\nexternal interface RRef\n\nexternal interface RReadableRef<out T> : RRef {\n    val current: T?\n}\n\nfun <S : RState> Component<*, S>.setState(buildState: S.() -> Unit) =\n    setState({ assign(it, buildState) })\n\ninline fun <P : RProps> rFunction(\n    displayName: String,\n    crossinline render: RBuilder.(P) -> Unit\n): RClass<P> {\n    val fn = { props: P -> buildElements { render(props) } } as RClass<P>\n    fn.displayName = displayName\n    return fn\n}\n\nabstract class RComponent<P : RProps, S : RState> : Component<P, S> {\n    constructor() : super() {\n        state = jsObject { init() }\n    }\n\n    constructor(props: P) : super(props) {\n        state = jsObject { init(props) }\n    }\n\n    open fun S.init() {}\n    // if you use this method, don't forget to pass props to the constructor first\n    open fun S.init(props: P) {}\n\n    fun RBuilder.children() {\n        props.children()\n    }\n\n    abstract fun RBuilder.render()\n\n    override fun render() = buildElements { render() }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.internal.contracts.*\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T = checkNotNull(value) { \"Required value was null.\" }\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n"],"names":[],"mappings":"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,OF0EG,C;;MEzEP,W;IAHkB,C;EAAA,C;;IAAlB,kBAAQ,QAAR,EAAkB,8BAAlB,C;EAAA,C;uFAKJ,yB;IAAA,4D;IAAA,wC;MDzBI,UAAa,E;MC6BgC,KD3BzC,CADG,GACH,C;MC2BU,iCAAa,OAAb,ED5BP,GC4BO,SAAwC,KAAxC,E;IAAA,C;GAJlB,C;;IAM4C,qB;MAAA,QAAc,I;IACtD,iCAAa,OAAb,EAAsB,KAAtB,SAA8B,QAAS,SAAQ,KAAR,CAAvC,E;EAAA,C;;IC5B6B,OAAA,SAAY,S;EAAZ,C;EC4HjC,iF;;IAMiD,MAAM,2BDhIrC,+BCgImE,WAA9B,C;EDhI3C,C;;IAEJ,gBAAkB,K;EACtB,C;;IC6H6C,MAAM,2BD1HrC,+BC0HmE,WAA9B,C;ED1H3C,C;;IAEJ,gBAAkB,K;EACtB,C;;IAGA,gBAAkB,G;EACtB,C;;IAKoB,kB;EAAD,C;;;;;;;IAKwB,OAAA,SAAY,e;EAAZ,C;;IA+B9B,qB;MAAE,cAAW,kB;MFnD8C,gBAAX,MEmDvC,EFnDuC,C;MAAiB,OD8D1E,W;MGXW,OHYJ,S;IGZE,C;EAAA,C;;IAAT,mBAAS,2BAAT,C;EAAA,C;+EAEJ,yB;IAAA,6B;IAAA,iD;IAAA,8B;;MAIyC,4B;QAAE,0BAAO,aAAP,C;QAAc,W;MAAhB,C;IAAA,C;;MAA5B,wB;QAAc,qBAAc,8CAAd,C;MAAd,C;IAAA,C;IAJb,sC;MAIa,Q;MAAT,SAAS,0E;MACT,iBAAiB,W;MACjB,OAAO,E;IACX,C;GAPA,C;;;;EAkBuB,C;;EAEQ,C;;IAGjB,2BAAN,UAAM,C;EACV,C;;IAIsC,4B;MAAE,wC;MAAS,W;IAAX,C;EAAA,C;;IAAd,qBAAc,8BAAd,C;EAAA,C;;;;;;;IAlBxB,oD;IAAgB,qB;IADpB,sB;IFvEI,UAAa,E;IEyEU,mBFxEhB,GEwEgB,C;IAAnB,cFxEG,G;IEuEP,Y;EAAA,C;;IAIA,oD;IAAwB,sBAAM,KAAN,C;IAL5B,sB;IFvEI,UAAa,E;IE6EU,mBF5EhB,GE4EgB,Q;IAAnB,cF5EG,G;IE2EP,Y;EAAA,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}