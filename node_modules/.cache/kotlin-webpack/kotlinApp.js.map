{"version":3,"file":"kotlinApp.js","sources":["../../../src/index/Button.kt","../../@jetbrains/kotlin-react-dom/src/main/kotlin/react/dom/ReactDOMTags.kt","../../@jetbrains/kotlin-react-dom/build/classes/main/util/Standard.kt","../../@jetbrains/kotlin-react-dom/src/main/kotlin/react/dom/RDOMBuilder.kt","../../../src/index/Evaluation.kt","generated/_Maps.kt","collections/Maps.kt","../../../src/index/ImageBox.kt","../../../src/index/Leaderboard.kt","../../../src/index/SimpleInputField.kt","../../../../../../../../dummy.kt","../../../src/index/VotingPanel.kt","../../../src/index/index.kt","generated/_Collections.kt","kotlin/string.kt"],"sourcesContent":["package index\n\nimport kotlinx.html.js.onClickFunction\nimport org.w3c.dom.events.Event\nimport react.RBuilder\nimport react.RComponent\nimport react.RProps\nimport react.RState\nimport react.dom.button\n\ninterface ButtonProps: RProps {\n    var label: String\n    var handleClick: (Event) -> Unit\n    var disabled: Boolean\n}\n\nclass Button(props: ButtonProps): RComponent<ButtonProps, RState>(props) {\n    override fun RBuilder.render() {\n        button {\n            +props.label\n            attrs {\n                onClickFunction = props.handleClick\n                disabled = props.disabled\n            }\n        }\n    }\n\n}","package react.dom\n\nimport kotlinx.html.*\nimport kotlinx.html.attributes.*\nimport react.*\n\ninline fun <T : Tag> RBuilder.tag(block: RDOMBuilder<T>.() -> Unit, noinline factory: (TagConsumer<Unit>) -> T): ReactElement =\n    child(RDOMBuilder(factory).apply {\n        block()\n    }.create())\n\ninline fun RBuilder.a(href: String? = null, target: String? = null, classes: String? = null, block: RDOMBuilder<A>.() -> Unit): ReactElement = tag(block) { A(attributesMapOf(\"href\", href, \"target\", target, \"class\", classes), it) }\n\ninline fun RBuilder.abbr(classes: String? = null, block: RDOMBuilder<ABBR>.() -> Unit): ReactElement = tag(block) { ABBR(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.address(classes: String? = null, block: RDOMBuilder<ADDRESS>.() -> Unit): ReactElement = tag(block) { ADDRESS(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.area(shape: AreaShape? = null, alt: String? = null, classes: String? = null, block: RDOMBuilder<AREA>.() -> Unit): ReactElement = tag(block) { AREA(attributesMapOf(\"Shape\", shape?.enumEncode(), \"alt\", alt, \"class\", classes), it) }\n\ninline fun RBuilder.article(classes: String? = null, block: RDOMBuilder<ARTICLE>.() -> Unit): ReactElement = tag(block) { ARTICLE(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.aside(classes: String? = null, block: RDOMBuilder<ASIDE>.() -> Unit): ReactElement = tag(block) { ASIDE(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.audio(classes: String? = null, block: RDOMBuilder<AUDIO>.() -> Unit): ReactElement = tag(block) { AUDIO(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.b(classes: String? = null, block: RDOMBuilder<B>.() -> Unit): ReactElement = tag(block) { B(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.base(classes: String? = null, block: RDOMBuilder<BASE>.() -> Unit): ReactElement = tag(block) { BASE(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.bdi(classes: String? = null, block: RDOMBuilder<BDI>.() -> Unit): ReactElement = tag(block) { BDI(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.bdo(classes: String? = null, block: RDOMBuilder<BDO>.() -> Unit): ReactElement = tag(block) { BDO(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.blockQuote(classes: String? = null, block: RDOMBuilder<BLOCKQUOTE>.() -> Unit): ReactElement = tag(block) { BLOCKQUOTE(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.body(classes: String? = null, block: RDOMBuilder<BODY>.() -> Unit): ReactElement = tag(block) { BODY(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.br(classes: String? = null, block: RDOMBuilder<BR>.() -> Unit): ReactElement = tag(block) { BR(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.button(formEncType: ButtonFormEncType? = null, formMethod: ButtonFormMethod? = null, type: ButtonType? = null, classes: String? = null, block: RDOMBuilder<BUTTON>.() -> Unit): ReactElement = tag(block) { BUTTON(attributesMapOf(\"formenctype\", formEncType?.enumEncode(), \"formmethod\", formMethod?.enumEncode(), \"type\", type?.enumEncode(), \"class\", classes), it) }\n\ninline fun RBuilder.canvas(classes: String? = null, content: String = \"\"): ReactElement = tag({ +content }) { CANVAS(attributesMapOf(\"class\", classes), it) }\ninline fun RBuilder.canvas(classes: String? = null, block: RDOMBuilder<CANVAS>.() -> Unit): ReactElement = tag(block) { CANVAS(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.caption(classes: String? = null, block: RDOMBuilder<CAPTION>.() -> Unit): ReactElement = tag(block) { CAPTION(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.cite(classes: String? = null, block: RDOMBuilder<CITE>.() -> Unit): ReactElement = tag(block) { CITE(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.code(classes: String? = null, block: RDOMBuilder<CODE>.() -> Unit): ReactElement = tag(block) { CODE(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.col(classes: String? = null, block: RDOMBuilder<COL>.() -> Unit): ReactElement = tag(block) { COL(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.colGroup(classes: String? = null, block: RDOMBuilder<COLGROUP>.() -> Unit): ReactElement = tag(block) { COLGROUP(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.command(type: CommandType? = null, classes: String? = null, block: RDOMBuilder<COMMAND>.() -> Unit): ReactElement = tag(block) { COMMAND(attributesMapOf(\"type\", type?.enumEncode(), \"class\", classes), it) }\n\ninline fun RBuilder.dataList(classes: String? = null, block: RDOMBuilder<DATALIST>.() -> Unit): ReactElement = tag(block) { DATALIST(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.dd(classes: String? = null, block: RDOMBuilder<DD>.() -> Unit): ReactElement = tag(block) { DD(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.del(classes: String? = null, block: RDOMBuilder<DEL>.() -> Unit): ReactElement = tag(block) { DEL(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.details(classes: String? = null, block: RDOMBuilder<DETAILS>.() -> Unit): ReactElement = tag(block) { DETAILS(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.dfn(classes: String? = null, block: RDOMBuilder<DFN>.() -> Unit): ReactElement = tag(block) { DFN(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.dialog(classes: String? = null, block: RDOMBuilder<DIALOG>.() -> Unit): ReactElement = tag(block) { DIALOG(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.div(classes: String? = null, block: RDOMBuilder<DIV>.() -> Unit): ReactElement = tag(block) { DIV(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.dl(classes: String? = null, block: RDOMBuilder<DL>.() -> Unit): ReactElement = tag(block) { DL(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.dt(classes: String? = null, block: RDOMBuilder<DT>.() -> Unit): ReactElement = tag(block) { DT(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.em(classes: String? = null, block: RDOMBuilder<EM>.() -> Unit): ReactElement = tag(block) { EM(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.embed(classes: String? = null, block: RDOMBuilder<EMBED>.() -> Unit): ReactElement = tag(block) { EMBED(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.fieldSet(classes: String? = null, block: RDOMBuilder<FIELDSET>.() -> Unit): ReactElement = tag(block) { FIELDSET(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.figcaption(classes: String? = null, block: RDOMBuilder<FIGCAPTION>.() -> Unit): ReactElement = tag(block) { FIGCAPTION(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.figure(classes: String? = null, block: RDOMBuilder<FIGURE>.() -> Unit): ReactElement = tag(block) { FIGURE(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.footer(classes: String? = null, block: RDOMBuilder<FOOTER>.() -> Unit): ReactElement = tag(block) { FOOTER(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.form(action: String? = null, encType: FormEncType? = null, method: FormMethod? = null, classes: String? = null, block: RDOMBuilder<FORM>.() -> Unit): ReactElement = tag(block) { FORM(attributesMapOf(\"action\", action, \"enctype\", encType?.enumEncode(), \"method\", method?.enumEncode(), \"class\", classes), it) }\n\ninline fun RBuilder.h1(classes: String? = null, block: RDOMBuilder<H1>.() -> Unit): ReactElement = tag(block) { H1(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.h2(classes: String? = null, block: RDOMBuilder<H2>.() -> Unit): ReactElement = tag(block) { H2(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.h3(classes: String? = null, block: RDOMBuilder<H3>.() -> Unit): ReactElement = tag(block) { H3(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.h4(classes: String? = null, block: RDOMBuilder<H4>.() -> Unit): ReactElement = tag(block) { H4(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.h5(classes: String? = null, block: RDOMBuilder<H5>.() -> Unit): ReactElement = tag(block) { H5(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.h6(classes: String? = null, block: RDOMBuilder<H6>.() -> Unit): ReactElement = tag(block) { H6(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.head(block: RDOMBuilder<HEAD>.() -> Unit): ReactElement = tag(block) { HEAD(emptyMap, it) }\n\ninline fun RBuilder.header(classes: String? = null, block: RDOMBuilder<HEADER>.() -> Unit): ReactElement = tag(block) { HEADER(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.hGroup(classes: String? = null, block: RDOMBuilder<HGROUP>.() -> Unit): ReactElement = tag(block) { HGROUP(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.hr(classes: String? = null, block: RDOMBuilder<HR>.() -> Unit): ReactElement = tag(block) { HR(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.html(block: RDOMBuilder<HTML>.() -> Unit): ReactElement = tag(block) { HTML(emptyMap, it) }\n\ninline fun RBuilder.i(classes: String? = null, block: RDOMBuilder<I>.() -> Unit): ReactElement = tag(block) { I(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.iframe(sandbox: IframeSandbox? = null, classes: String? = null, content: String = \"\"): ReactElement = tag({ +content }) { IFRAME(attributesMapOf(\"sandbox\", sandbox?.enumEncode(), \"class\", classes), it) }\ninline fun RBuilder.iframe(sandbox: IframeSandbox? = null, classes: String? = null, block: RDOMBuilder<IFRAME>.() -> Unit): ReactElement = tag(block) { IFRAME(attributesMapOf(\"sandbox\", sandbox?.enumEncode(), \"class\", classes), it) }\n\ninline fun RBuilder.img(alt: String? = null, src: String? = null, classes: String? = null, block: RDOMBuilder<IMG>.() -> Unit): ReactElement = tag(block) { IMG(attributesMapOf(\"alt\", alt, \"src\", src, \"class\", classes), it) }\n\ninline fun RBuilder.input(type: InputType? = null, formEncType: InputFormEncType? = null, formMethod: InputFormMethod? = null, name: String? = null, classes: String? = null, block: RDOMBuilder<INPUT>.() -> Unit): ReactElement = tag(block) { INPUT(attributesMapOf(\"type\", type?.enumEncode(), \"formenctype\", formEncType?.enumEncode(), \"formmethod\", formMethod?.enumEncode(), \"name\", name, \"class\", classes), it) }\n\ninline fun RBuilder.ins(classes: String? = null, block: RDOMBuilder<INS>.() -> Unit): ReactElement = tag(block) { INS(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.kbd(classes: String? = null, block: RDOMBuilder<KBD>.() -> Unit): ReactElement = tag(block) { KBD(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.keyGen(keyType: KeyGenKeyType? = null, classes: String? = null, block: RDOMBuilder<KEYGEN>.() -> Unit): ReactElement = tag(block) { KEYGEN(attributesMapOf(\"keytype\", keyType?.enumEncode(), \"class\", classes), it) }\n\ninline fun RBuilder.label(classes: String? = null, block: RDOMBuilder<LABEL>.() -> Unit): ReactElement = tag(block) { LABEL(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.legend(classes: String? = null, block: RDOMBuilder<LEGEND>.() -> Unit): ReactElement = tag(block) { LEGEND(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.li(classes: String? = null, block: RDOMBuilder<LI>.() -> Unit): ReactElement = tag(block) { LI(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.link(href: String? = null, rel: String? = null, type: String? = null, block: RDOMBuilder<LINK>.() -> Unit): ReactElement = tag(block) { LINK(attributesMapOf(\"href\", href, \"rel\", rel, \"type\", type), it) }\n\ninline fun RBuilder.map(name: String? = null, classes: String? = null, block: RDOMBuilder<MAP>.() -> Unit): ReactElement = tag(block) { MAP(attributesMapOf(\"name\", name, \"class\", classes), it) }\n\ninline fun RBuilder.mark(classes: String? = null, block: RDOMBuilder<MARK>.() -> Unit): ReactElement = tag(block) { MARK(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.math(classes: String? = null, block: RDOMBuilder<MATH>.() -> Unit): ReactElement = tag(block) { MATH(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.mathml(classes: String? = null, content: String = \"\"): ReactElement = tag({ +content }) { MATHML(attributesMapOf(\"class\", classes), it) }\ninline fun RBuilder.mathml(classes: String? = null, block: RDOMBuilder<MATHML>.() -> Unit): ReactElement = tag(block) { MATHML(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.meta(name: String? = null, content: String? = null, block: RDOMBuilder<META>.() -> Unit): ReactElement = tag(block) { META(attributesMapOf(\"name\", name, \"content\", content), it) }\n\ninline fun RBuilder.meter(classes: String? = null, block: RDOMBuilder<METER>.() -> Unit): ReactElement = tag(block) { METER(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.nav(classes: String? = null, block: RDOMBuilder<NAV>.() -> Unit): ReactElement = tag(block) { NAV(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.noScript(classes: String? = null, block: RDOMBuilder<NOSCRIPT>.() -> Unit): ReactElement = tag(block) { NOSCRIPT(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.object_(classes: String? = null, block: RDOMBuilder<OBJECT>.() -> Unit): ReactElement = tag(block) { OBJECT(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.ol(classes: String? = null, block: RDOMBuilder<OL>.() -> Unit): ReactElement = tag(block) { OL(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.optGroup(label: String? = null, classes: String? = null, block: RDOMBuilder<OPTGROUP>.() -> Unit): ReactElement = tag(block) { OPTGROUP(attributesMapOf(\"label\", label, \"class\", classes), it) }\n\ninline fun RBuilder.option(classes: String? = null, content: String = \"\"): ReactElement = tag({ +content }) { OPTION(attributesMapOf(\"class\", classes), it) }\ninline fun RBuilder.option(classes: String? = null, block: RDOMBuilder<OPTION>.() -> Unit): ReactElement = tag(block) { OPTION(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.output(classes: String? = null, block: RDOMBuilder<OUTPUT>.() -> Unit): ReactElement = tag(block) { OUTPUT(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.p(classes: String? = null, block: RDOMBuilder<P>.() -> Unit): ReactElement = tag(block) { P(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.param(name: String? = null, value: String? = null, block: RDOMBuilder<PARAM>.() -> Unit): ReactElement = tag(block) { PARAM(attributesMapOf(\"name\", name, \"value\", value), it) }\n\ninline fun RBuilder.pre(classes: String? = null, block: RDOMBuilder<PRE>.() -> Unit): ReactElement = tag(block) { PRE(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.progress(classes: String? = null, block: RDOMBuilder<PROGRESS>.() -> Unit): ReactElement = tag(block) { PROGRESS(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.q(classes: String? = null, block: RDOMBuilder<Q>.() -> Unit): ReactElement = tag(block) { Q(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.rp(classes: String? = null, block: RDOMBuilder<RP>.() -> Unit): ReactElement = tag(block) { RP(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.rt(classes: String? = null, block: RDOMBuilder<RT>.() -> Unit): ReactElement = tag(block) { RT(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.ruby(classes: String? = null, block: RDOMBuilder<RUBY>.() -> Unit): ReactElement = tag(block) { RUBY(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.samp(classes: String? = null, block: RDOMBuilder<SAMP>.() -> Unit): ReactElement = tag(block) { SAMP(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.script(type: String? = null, src: String? = null, block: RDOMBuilder<SCRIPT>.() -> Unit): ReactElement = tag(block) { SCRIPT(attributesMapOf(\"type\", type, \"src\", src), it) }\n\ninline fun RBuilder.section(classes: String? = null, block: RDOMBuilder<SECTION>.() -> Unit): ReactElement = tag(block) { SECTION(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.select(classes: String? = null, block: RDOMBuilder<SELECT>.() -> Unit): ReactElement = tag(block) { SELECT(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.small(classes: String? = null, block: RDOMBuilder<SMALL>.() -> Unit): ReactElement = tag(block) { SMALL(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.source(classes: String? = null, block: RDOMBuilder<SOURCE>.() -> Unit): ReactElement = tag(block) { SOURCE(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.span(classes: String? = null, block: RDOMBuilder<SPAN>.() -> Unit): ReactElement = tag(block) { SPAN(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.strong(classes: String? = null, block: RDOMBuilder<STRONG>.() -> Unit): ReactElement = tag(block) { STRONG(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.style(type: String? = null, content: String = \"\"): ReactElement = tag({ +content }) { STYLE(attributesMapOf(\"type\", type), it) }\ninline fun RBuilder.style(type: String? = null, block: RDOMBuilder<STYLE>.() -> Unit): ReactElement = tag(block) { STYLE(attributesMapOf(\"type\", type), it) }\n\ninline fun RBuilder.sub(classes: String? = null, block: RDOMBuilder<SUB>.() -> Unit): ReactElement = tag(block) { SUB(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.sup(classes: String? = null, block: RDOMBuilder<SUP>.() -> Unit): ReactElement = tag(block) { SUP(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.svg(classes: String? = null, content: String = \"\"): ReactElement = tag({ +content }) { SVG(attributesMapOf(\"class\", classes), it) }\ninline fun RBuilder.svg(classes: String? = null, block: RDOMBuilder<SVG>.() -> Unit): ReactElement = tag(block) { SVG(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.table(classes: String? = null, block: RDOMBuilder<TABLE>.() -> Unit): ReactElement = tag(block) { TABLE(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.tbody(classes: String? = null, block: RDOMBuilder<TBODY>.() -> Unit): ReactElement = tag(block) { TBODY(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.td(classes: String? = null, block: RDOMBuilder<TD>.() -> Unit): ReactElement = tag(block) { TD(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.textArea(rows: String? = null, cols: String? = null, wrap: TextAreaWrap? = null, classes: String? = null, content: String = \"\"): ReactElement = tag({ +content }) { TEXTAREA(attributesMapOf(\"rows\", rows, \"cols\", cols, \"wrap\", wrap?.enumEncode(), \"class\", classes), it) }\ninline fun RBuilder.textArea(rows: String? = null, cols: String? = null, wrap: TextAreaWrap? = null, classes: String? = null, block: RDOMBuilder<TEXTAREA>.() -> Unit): ReactElement = tag(block) { TEXTAREA(attributesMapOf(\"rows\", rows, \"cols\", cols, \"wrap\", wrap?.enumEncode(), \"class\", classes), it) }\n\ninline fun RBuilder.tfoot(classes: String? = null, block: RDOMBuilder<TFOOT>.() -> Unit): ReactElement = tag(block) { TFOOT(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.th(scope: ThScope? = null, classes: String? = null, block: RDOMBuilder<TH>.() -> Unit): ReactElement = tag(block) { TH(attributesMapOf(\"scope\", scope?.enumEncode(), \"class\", classes), it) }\n\ninline fun RBuilder.thead(classes: String? = null, block: RDOMBuilder<THEAD>.() -> Unit): ReactElement = tag(block) { THEAD(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.time(classes: String? = null, block: RDOMBuilder<TIME>.() -> Unit): ReactElement = tag(block) { TIME(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.title(content: String = \"\"): ReactElement = tag({ +content }) { TITLE(emptyMap, it) }\ninline fun RBuilder.title(block: RDOMBuilder<TITLE>.() -> Unit): ReactElement = tag(block) { TITLE(emptyMap, it) }\n\ninline fun RBuilder.tr(classes: String? = null, block: RDOMBuilder<TR>.() -> Unit): ReactElement = tag(block) { TR(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.ul(classes: String? = null, block: RDOMBuilder<UL>.() -> Unit): ReactElement = tag(block) { UL(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.var_(classes: String? = null, block: RDOMBuilder<VAR>.() -> Unit): ReactElement = tag(block) { VAR(attributesMapOf(\"class\", classes), it) }\n\ninline fun RBuilder.video(classes: String? = null, block: RDOMBuilder<VIDEO>.() -> Unit): ReactElement = tag(block) { VIDEO(attributesMapOf(\"class\", classes), it) }\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.internal.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","package react.dom\n\nimport kotlinext.js.*\nimport kotlinx.html.*\nimport org.w3c.dom.events.*\nimport react.*\n\nclass InnerHTML(\n    val __html: String\n)\n\nexternal interface WithClassName : RProps {\n    var className: String?\n}\n\nexternal interface DOMProps : WithClassName {\n    var dangerouslySetInnerHTML: InnerHTML?\n}\n\nopen class RDOMBuilder<out T : Tag>(factory: (TagConsumer<Unit>) -> T) : RBuilder() {\n    fun setProp(attribute: String, value: Any?) {\n        val key = fixAttributeName(attribute)\n        props.asDynamic()[key] = value\n    }\n\n    val consumer = object : TagConsumer<Unit> {\n        override fun onTagAttributeChange(tag: Tag, attribute: String, value: String?) {\n            setProp(attribute, value)\n        }\n\n        override fun onTagComment(content: CharSequence) {\n            throw IllegalStateException(\"Comments are not supported\")\n        }\n\n        override fun onTagContent(content: CharSequence): Unit {\n            childList.add(content)\n        }\n\n        override fun onTagContentEntity(entity: Entities): Unit {\n            childList.add(entity.text)\n        }\n\n        override fun onTagContentUnsafe(block: Unsafe.() -> Unit) {\n            val sb = StringBuilder()\n            object : Unsafe {\n                override fun String.unaryPlus() {\n                    sb.append(this)\n                }\n            }.block()\n            props.dangerouslySetInnerHTML = InnerHTML(sb.toString())\n        }\n\n        override fun onTagStart(tag: Tag) {\n            throw IllegalStateException(\"Don't nest tags inside props block\")\n        }\n\n        override fun onTagEnd(tag: Tag) {\n            throw IllegalStateException(\"Don't nest tags inside props block\")\n        }\n\n        override fun onTagEvent(tag: Tag, event: String, value: (Event) -> Unit) {\n            setProp(event, value)\n        }\n\n        override fun finalize() {}\n    }\n\n    val attrs: T = factory(consumer)\n\n    operator fun Tag.get(name: String) = props.asDynamic()[name]\n    operator fun Tag.set(name: String, value: Any) {\n        props.asDynamic()[name] = value\n    }\n\n    // See https://facebook.github.io/react/docs/forms.html\n    var INPUT.defaultChecked: Boolean\n        get() = this[\"defaultChecked\"] ?: false\n        set(value) {\n            this[\"defaultChecked\"] = value\n        }\n\n    var SELECT.values: Set<String>\n        get() {\n            val valuesArr: Array<String> = this[\"value\"] ?: arrayOf()\n            return valuesArr.toSet()\n        }\n        set(value) {\n            this[\"value\"] = value.toTypedArray()\n        }\n\n    var SELECT.value: String\n        get() = \"\"\n        set(value) {\n            values = setOf(value)\n        }\n\n    protected val props: DOMProps = jsObject {}\n\n    init {\n        attrs.attributesEntries.forEach { setProp(it.key, it.value) }\n    }\n\n    inline fun attrs(handler: T.() -> Unit) {\n        attrs.handler()\n    }\n\n    var key: String\n        get() = props.key\n        set(value) {\n            props.key = value\n        }\n\n    var ref: RRef\n        get() = props.ref\n        set(value) {\n            props.ref = value\n        }\n\n    fun ref(handler: (dynamic) -> Unit) {\n        props.ref(handler)\n    }\n\n    open fun create(): ReactElement = createElement(attrs.tagName, props, *childList.toTypedArray())\n}\n\n\n","package index\n\nimport react.RBuilder\nimport react.RComponent\nimport react.RProps\nimport react.RState\nimport react.dom.div\nimport react.dom.li\nimport react.dom.ul\n\ninterface EvaluationProps: RProps {\n    var players: Map<String, Pair<String?, Int?>>\n}\n\nclass Evaluation(props: EvaluationProps): RComponent<EvaluationProps, RState>(props) {\n    override fun RBuilder.render() {\n        div(\"evaluation\") {\n            ul {\n                props.players.map {\n                    if(it.value.first == null || it.value.second == null) {\n\n                    } else {\n                        li {\n                            +\"${it.key}: \\\"${it.value.first}\\\": +${it.value.second} Points\"\n                        }\n                    }\n                }\n            }\n        }\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.*\nimport kotlin.text.*\nimport kotlin.comparisons.*\n\n/**\n * Returns a [List] containing all key-value pairs.\n */\npublic fun <K, V> Map<out K, V>.toList(): List<Pair<K, V>> {\n    if (size == 0)\n        return emptyList()\n    val iterator = entries.iterator()\n    if (!iterator.hasNext())\n        return emptyList()\n    val first = iterator.next()\n    if (!iterator.hasNext())\n        return listOf(first.toPair())\n    val result = ArrayList<Pair<K, V>>(size)\n    result.add(first.toPair())\n    do {\n        result.add(iterator.next().toPair())\n    } while (iterator.hasNext())\n    return result\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each entry of original map.\n */\npublic inline fun <K, V, R> Map<out K, V>.flatMap(transform: (Map.Entry<K, V>) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each entry of original map, to the given [destination].\n */\npublic inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.flatMapTo(destination: C, transform: (Map.Entry<K, V>) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each entry in the original map.\n */\npublic inline fun <K, V, R> Map<out K, V>.map(transform: (Map.Entry<K, V>) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each entry in the original map.\n */\npublic inline fun <K, V, R : Any> Map<out K, V>.mapNotNull(transform: (Map.Entry<K, V>) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each entry in the original map\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <K, V, R : Any, C : MutableCollection<in R>> Map<out K, V>.mapNotNullTo(destination: C, transform: (Map.Entry<K, V>) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each entry of the original map\n * and appends the results to the given [destination].\n */\npublic inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.mapTo(destination: C, transform: (Map.Entry<K, V>) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns `true` if all entries match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <K, V> Map<out K, V>.all(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if map has at least one entry.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <K, V> Map<out K, V>.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one entry matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <K, V> Map<out K, V>.any(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of entries in this map.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of entries matching the given [predicate].\n */\npublic inline fun <K, V> Map<out K, V>.count(predicate: (Map.Entry<K, V>) -> Boolean): Int {\n    if (isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) count++\n    return count\n}\n\n/**\n * Performs the given [action] on each entry.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <K, V> Map<out K, V>.forEach(action: (Map.Entry<K, V>) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Returns the first entry yielding the largest value of the given function or `null` if there are no entries.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxBy(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return entries.maxBy(selector)\n}\n\n/**\n * Returns the first entry having the largest value according to the provided [comparator] or `null` if there are no entries.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxWith(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return entries.maxWith(comparator)\n}\n\n/**\n * Returns the first entry yielding the smallest value of the given function or `null` if there are no entries.\n */\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minBy(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return entries.minBy(selector)\n}\n\n/**\n * Returns the first entry having the smallest value according to the provided [comparator] or `null` if there are no entries.\n */\npublic fun <K, V> Map<out K, V>.minWith(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return entries.minWith(comparator)\n}\n\n/**\n * Returns `true` if the map has no entries.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <K, V> Map<out K, V>.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no entries match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <K, V> Map<out K, V>.none(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each entry and returns the map itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <K, V, M : Map<out K, V>> M.onEach(action: (Map.Entry<K, V>) -> Unit): M {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original map returning its entries when being iterated.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.asIterable(): Iterable<Map.Entry<K, V>> {\n    return entries\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original map returning its entries when being iterated.\n */\npublic fun <K, V> Map<out K, V>.asSequence(): Sequence<Map.Entry<K, V>> {\n    return entries.asSequence()\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\nprivate object EmptyMap : Map<Any?, Nothing>, Serializable {\n    private const val serialVersionUID: Long = 8246714829545688274\n\n    override fun equals(other: Any?): Boolean = other is Map<*, *> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"{}\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n\n    override fun containsKey(key: Any?): Boolean = false\n    override fun containsValue(value: Nothing): Boolean = false\n    override fun get(key: Any?): Nothing? = null\n    override val entries: Set<Map.Entry<Any?, Nothing>> get() = EmptySet\n    override val keys: Set<Any?> get() = EmptySet\n    override val values: Collection<Nothing> get() = EmptyList\n\n    private fun readResolve(): Any = EmptyMap\n}\n\n/**\n * Returns an empty read-only map of specified type.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\npublic fun <K, V> emptyMap(): Map<K, V> = @Suppress(\"UNCHECKED_CAST\") (EmptyMap as Map<K, V>)\n\n/**\n * Returns a new read-only map with the specified contents, given as a list of pairs\n * where the first value is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =\n    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\n\n/**\n * Returns an empty read-only map.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mapOf(): Map<K, V> = emptyMap()\n\n/**\n * Returns an empty new [MutableMap].\n *\n * The returned map preserves the entry iteration order.\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mutableMapOf(): MutableMap<K, V> = LinkedHashMap()\n\n/**\n * Returns a new [MutableMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.mutableMapFromPairs\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\npublic fun <K, V> mutableMapOf(vararg pairs: Pair<K, V>): MutableMap<K, V> =\n    LinkedHashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [HashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> hashMapOf(): HashMap<K, V> = HashMap<K, V>()\n\n/**\n * Returns a new [HashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * @sample samples.collections.Maps.Instantiation.hashMapFromPairs\n */\npublic fun <K, V> hashMapOf(vararg pairs: Pair<K, V>): HashMap<K, V> = HashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [LinkedHashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> linkedMapOf(): LinkedHashMap<K, V> = LinkedHashMap<K, V>()\n\n/**\n * Returns a new [LinkedHashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.linkedMapFromPairs\n */\npublic fun <K, V> linkedMapOf(vararg pairs: Pair<K, V>): LinkedHashMap<K, V> = pairs.toMap(LinkedHashMap(mapCapacity(pairs.size)))\n\n/**\n * Calculate the initial capacity of a map, based on Guava's com.google.common.collect.Maps approach. This is equivalent\n * to the Collection constructor for HashSet, (c.size()/.75f) + 1, but provides further optimisations for very small or\n * very large sizes, allows support non-collection classes, and provides consistency for all map based class construction.\n */\n@PublishedApi\ninternal fun mapCapacity(expectedSize: Int): Int {\n    if (expectedSize < 3) {\n        return expectedSize + 1\n    }\n    if (expectedSize < INT_MAX_POWER_OF_TWO) {\n        return expectedSize + expectedSize / 3\n    }\n    return Int.MAX_VALUE // any large value\n}\n\nprivate const val INT_MAX_POWER_OF_TWO: Int = Int.MAX_VALUE / 2 + 1\n\n/** Returns `true` if this map is not empty. */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns the [Map] if its not `null`, or the empty [Map] otherwise.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>?.orEmpty(): Map<K, V> = this ?: emptyMap()\n\n/**\n * Checks if the map contains the given key.\n *\n * This method allows to use the `x in map` syntax for checking whether an object is contained in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.contains(key: K): Boolean = containsKey(key)\n\n/**\n * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.get(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, V>).get(key)\n\n/**\n * Allows to use the index operator for storing values in a mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.set(key: K, value: V): Unit {\n    put(key, value)\n}\n\n/**\n * Returns `true` if the map contains the specified [key].\n *\n * Allows to overcome type-safety restriction of `containsKey` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K> Map<out K, *>.containsKey(key: K): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, *>).containsKey(key)\n\n/**\n * Returns `true` if the map maps one or more keys to the specified [value].\n *\n * Allows to overcome type-safety restriction of `containsValue` that requires to pass a value of type `V`.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <K, @kotlin.internal.OnlyInputTypes V> Map<K, V>.containsValue(value: V): Boolean = this.containsValue(value)\n\n\n/**\n * Removes the specified key and its corresponding value from this map.\n *\n * @return the previous value associated with the key, or `null` if the key was not present in the map.\n\n * Allows to overcome type-safety restriction of `remove` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K, V> MutableMap<out K, V>.remove(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableMap<K, V>).remove(key)\n\n/**\n * Returns the key component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component1(): K = key\n\n/**\n * Returns the value component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component2(): V = value\n\n/**\n * Converts entry to [Pair] with key being first component and value being second.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map.Entry<K, V>.toPair(): Pair<K, V> = Pair(key, value)\n\n/**\n * Returns the value for the given key, or the result of the [defaultValue] function if there was no entry for the given key.\n *\n * @sample samples.collections.Maps.Usage.getOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>.getOrElse(key: K, defaultValue: () -> V): V = get(key) ?: defaultValue()\n\n\ninternal inline fun <K, V> Map<K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    if (value == null && !containsKey(key)) {\n        return defaultValue()\n    } else {\n        @Suppress(\"UNCHECKED_CAST\")\n        return value as V\n    }\n}\n\n/**\n * Returns the value for the given [key] or throws an exception if there is no such key in the map.\n *\n * If the map was created by [withDefault], resorts to its `defaultValue` provider function\n * instead of throwing an exception.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and\n * no implicit default value was provided for that map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<K, V>.getValue(key: K): V = getOrImplicitDefault(key)\n\n/**\n * Returns the value for the given key. If the key is not found in the map, calls the [defaultValue] function,\n * puts its result into the map under the given key and returns it.\n *\n * @sample samples.collections.Maps.Usage.getOrPut\n */\npublic inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n\n/**\n * Returns an [Iterator] over the entries in the [Map].\n *\n * @sample samples.collections.Maps.Usage.forOverEntries\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>> = entries.iterator()\n\n/**\n * Returns a [MutableIterator] over the mutable entries in the [MutableMap].\n *\n */\n@kotlin.jvm.JvmName(\"mutableIterator\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> = entries.iterator()\n\n/**\n * Populates the given [destination] map with entries having the keys of this map and the values obtained\n * by applying the [transform] function to each entry in this [Map].\n */\npublic inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, { it.key }, transform)\n}\n\n/**\n * Populates the given [destination] map with entries having the keys obtained\n * by applying the [transform] function to each entry in this [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n */\npublic inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, transform, { it.value })\n}\n\n/**\n * Puts all the given [pairs] into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given collection into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given sequence into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Returns a new map with entries having the keys of this map and the values obtained by applying the [transform]\n * function to each entry in this [Map].\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapValues\n */\npublic inline fun <K, V, R> Map<out K, V>.mapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> {\n    return mapValuesTo(LinkedHashMap<K, R>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a new Map with entries having the keys obtained by applying the [transform] function to each entry in this\n * [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapKeys\n */\npublic inline fun <K, V, R> Map<out K, V>.mapKeys(transform: (Map.Entry<K, V>) -> R): Map<R, V> {\n    return mapKeysTo(LinkedHashMap<R, V>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a map containing all key-value pairs with keys matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterKeys\n */\npublic inline fun <K, V> Map<out K, V>.filterKeys(predicate: (K) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.key)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n/**\n * Returns a map containing all key-value pairs with values matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n *  @sample samples.collections.Maps.Filtering.filterValues\n */\npublic inline fun <K, V> Map<out K, V>.filterValues(predicate: (V) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.value)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n\n/**\n * Appends all entries matching the given [predicate] into the mutable map given as [destination] parameter.\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filter\n */\npublic inline fun <K, V> Map<out K, V>.filter(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Appends all entries not matching the given [predicate] into the given [destination].\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterNotTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (!predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs not matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterNot\n */\npublic inline fun <K, V> Map<out K, V>.filterNot(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterNotTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Returns a new map containing all key-value pairs from the given collection of pairs.\n *\n * The returned map preserves the entry iteration order of the original collection.\n */\npublic fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyMap()\n            1 -> mapOf(if (this is List) this[0] else iterator().next())\n            else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n        }\n    }\n    return toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given collection of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given array of pairs.\n *\n * The returned map preserves the entry iteration order of the original array.\n */\npublic fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> mapOf(this[0])\n    else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n}\n\n/**\n *  Populates and returns the [destination] mutable map with key-value pairs from the given array of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given sequence of pairs.\n *\n * The returned map preserves the entry iteration order of the original sequence.\n */\npublic fun <K, V> Sequence<Pair<K, V>>.toMap(): Map<K, V> = toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given sequence of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new read-only map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMap()\n    else -> toMutableMap()\n}\n\n/**\n * Returns a new mutable map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> = LinkedHashMap(this)\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Creates a new read-only map by replacing or adding an entry to this map from a given key-value [pair].\n *\n * The returned map preserves the entry iteration order of the original map.\n * The [pair] is iterated in the end if it has a unique key.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pair: Pair<K, V>): Map<K, V> =\n    if (this.isEmpty()) mapOf(pair) else LinkedHashMap(this).apply { put(pair.first, pair.second) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given collection of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] collection.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Iterable<Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given array of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] array.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Array<out Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given sequence of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] sequence.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Sequence<Pair<K, V>>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(pairs) }.optimizeReadOnlyMap()\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from another [map].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those entries of another [map] that are missing in this map are iterated in the end in the order of that [map].\n */\npublic operator fun <K, V> Map<out K, V>.plus(map: Map<out K, V>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(map) }\n\n\n/**\n * Appends or replaces the given [pair] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pair: Pair<K, V>) {\n    put(pair.first, pair.second)\n}\n\n/**\n * Appends or replaces all pairs from the given collection of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Iterable<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given array of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Array<out Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given sequence of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Sequence<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all entries from the given [map] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(map: Map<K, V>) {\n    putAll(map)\n}\n\n/**\n * Returns a map containing all entries of the original map except the entry with the given [key].\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(key: K): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(key) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] collection.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Iterable<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] array.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Array<out K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] sequence.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Sequence<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Removes the entry with the given [key] from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(key: K) {\n    remove(key)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] collection from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] array from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries from the keys of which are contained in the given [keys] sequence from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>) {\n    this.keys.removeAll(keys)\n}\n\n\n// do not expose for now @PublishedApi\ninternal fun <K, V> Map<K, V>.optimizeReadOnlyMap() = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMapOrSelf()\n    else -> this\n}\n","package index\n\nimport react.RBuilder\nimport react.RComponent\nimport react.RProps\nimport react.RState\nimport react.dom.div\nimport react.dom.img\n\ninterface ImageBoxProps: RProps {\n    var image: String\n}\n\nclass ImageBox(props: ImageBoxProps): RComponent<ImageBoxProps, RState>(props) {\n    override fun RBuilder.render() {\n        div(\"imagebox\") {\n            img(src=props.image) {\n\n            }\n        }\n    }\n}","package index\n\nimport react.RBuilder\nimport react.RComponent\nimport react.RProps\nimport react.RState\nimport react.dom.div\nimport react.dom.li\nimport react.dom.ul\n\ninterface LeaderboardProps: RProps {\n    var players: Map<String, Int>\n}\n\nclass Leaderboard(props: LeaderboardProps): RComponent<LeaderboardProps, RState>(props) {\n    override fun RBuilder.render() {\n        div(\"leaderboard\") {\n            ul {\n                props.players.map {\n                    li {\n                        +\"${it.key}: ${it.value} Points\"\n                    }\n                }\n            }\n        }\n    }\n}","package index\n\nimport kotlinx.html.InputType\nimport kotlinx.html.js.onChangeFunction\nimport kotlinx.html.js.onSubmitFunction\nimport org.w3c.dom.HTMLInputElement\nimport org.w3c.dom.events.Event\nimport react.*\nimport react.dom.form\nimport react.dom.input\n\ninterface SimpleInputFieldProps: RProps {\n    var handleNameAdd: (String) -> Any?\n}\n\ninterface SimpleInputFieldState: RState {\n    var textStuff: String\n}\n\nclass SimpleInputField(props: SimpleInputFieldProps): RComponent<SimpleInputFieldProps, SimpleInputFieldState>(props) {\n\n    override fun SimpleInputFieldState.init(props: SimpleInputFieldProps) {\n        textStuff = \"\"\n    }\n\n    override fun RBuilder.render() {\n        form {\n            attrs {\n                onSubmitFunction = {\n                    it.preventDefault()\n                    handleSubmit(it)\n                }\n            }\n            input(type = InputType.text) {\n                attrs {\n                    name = \"newElementText\"\n                    value = state.textStuff\n                    onChangeFunction = ::handleChange\n                }\n            }\n        }\n    }\n\n    fun handleChange(e: Event) {\n        val html = e.target as HTMLInputElement\n        val txt = html.value\n        setState {\n            textStuff = txt\n        }\n    }\n\n    fun handleSubmit(e: Event) {\n        setState {\n            textStuff = \"\"\n        }\n        props.handleNameAdd(state.textStuff)\n    }\n}",null,"package index\n\nimport react.RBuilder\nimport react.RComponent\nimport react.RProps\nimport react.RState\n\ninterface VotingPanelProps: RProps {\n    var options: Map<String, String>\n    var buttonPressHandler: (String) -> Unit\n    var shouldShow: Boolean\n    var shouldEnable: Boolean\n}\n\nclass VotingPanel(props: VotingPanelProps): RComponent<VotingPanelProps, RState>(props) {\n    override fun RBuilder.render() {\n        props.options.map {\n            child(Button::class) {\n                attrs.label = if(props.shouldShow) it.value else \"\ud83e\udd14\"\n                attrs.handleClick = {_ ->\n                    props.buttonPressHandler(it.key)\n                }\n                attrs.disabled = (!props.shouldEnable) || !props.shouldShow\n            }\n        }\n    }\n\n}","package index\n\nimport kotlinext.js.*\nimport kotlinx.html.InputType\nimport kotlinx.html.js.onChangeFunction\nimport kotlinx.html.js.onClickFunction\nimport kotlinx.html.js.onSubmitFunction\nimport kotlinx.html.style\nimport org.w3c.dom.HTMLInputElement\nimport org.w3c.dom.MessageEvent\nimport org.w3c.dom.WebSocket\nimport org.w3c.dom.events.Event\nimport react.*\nimport react.dom.*\nimport kotlin.browser.*\n\nfun main(args: Array<String>) {\n    requireAll(require.context(\"src\", true, js(\"/\\\\.css$/\")))\n\n    render(document.getElementById(\"root\")) {\n        child(App::class) {\n\n        }\n    }\n}\n\ninterface AppState: RState {\n    var socket: WebSocket\n    var image: String\n    var timeRemaining: Int\n    var phase: GamePhase\n    var guesses: Map<String, String>\n    var players: Map<String, Player>\n    var lobby: String?\n    var points: Map<String, Pair<String, Int>>\n    var canVote: Boolean\n}\n\nclass Player(var name: String, var points: Int, var lastRoundPoints: Int?)\n\ninterface AppProps: RProps {\n\n}\n\n\nenum class GamePhase(val desc: String) {\n    NEED_NAME(\"Need name.\"),\n    NEED_GAME_ID(\"Need Game Id.\"),\n    WAITING_FOR_NEXT_ROUND(\"Waiting for next round\"),\n    GUESS(\"Enter your guess\"),\n    VOTE(\"Vote for the best results\")\n}\n\nval gameName = \"Titular\"\n\nclass App(props: AppProps): RComponent<AppProps, AppState>(props) {\n    var timerId: Int? = null\n\n    override fun AppState.init(props: AppProps) {\n        socket = WebSocket(\"ws://0.0.0.0:8080/myws/echo\")\n        image = \"https://via.placeholder.com/350x150\"\n        timeRemaining = 0\n        phase = GamePhase.NEED_NAME\n        guesses = mapOf()\n        players = mapOf()\n        points = mapOf()\n        canVote = true\n        socket.onmessage = {\n            if(it is MessageEvent) {\n                console.log(it.data)\n                val str = it.data.toString().split(\" \")\n                when(str[0].toLowerCase()) {\n                    \"startround\" -> {\n                        setState {\n                            guesses = mapOf()\n                            phase = GamePhase.GUESS\n                            players.values.forEach { it.lastRoundPoints = null }\n                        }\n                    }\n                    \"votenow\" -> {\n                        setState {\n                            canVote = true\n                            phase = GamePhase.VOTE\n                        }\n\n                    }\n                    \"voteend\" -> {\n                        setState {\n                            phase = GamePhase.WAITING_FOR_NEXT_ROUND\n                        }\n                    }\n\n                    \"guess\" -> {\n                        setState {\n                            guesses += str[1] to it.data.toString().substringAfter(\" \").substringAfter(\" \")\n                        }\n                        println(state.guesses)\n                    }\n\n                    \"player\" -> {\n                        setState {\n                            players += str[1] to Player(str[2], str[3].toInt(), null)\n                        }\n                    }\n\n                    \"point\" -> {\n                        val uuid = str[1]\n                        val amount = str[2]\n                        setState {\n                            players[uuid]?.let {\n                                it.points += amount.toInt()\n                                it.lastRoundPoints = amount.toInt()\n                            }\n                        }\n                    }\n\n                    \"image\" -> {\n                        setState {\n                            image = str[1]\n                        }\n                    }\n                    \"time\" -> {\n                        timerId?.let {\n                            window.clearInterval(it)\n                        }\n                        setState {\n                            timeRemaining = str[1].toInt()\n                        }\n                        timerId = window.setInterval({\n\n                            setState {\n                                if(state.timeRemaining > 0) {\n                                    timeRemaining -= 1\n                                }\n                                else {\n                                    timerId?.let {\n                                        window.clearInterval(it)\n                                    }\n                                }\n                            }\n                        }, 1000)\n                    }\n                }\n            }\n        }\n    }\n    override fun RBuilder.render() {\n        h1 {\n            +when(state.phase) {\n                GamePhase.NEED_NAME -> {\n                    \"$gameName \u2013 Welcome!\"\n                }\n\n                GamePhase.NEED_GAME_ID -> {\n                    \"$gameName \u2013 Join a Lobby\"\n                }\n                GamePhase.WAITING_FOR_NEXT_ROUND -> {\n                    \"$gameName: Lobby #${state.lobby}\"\n                }\n                else -> {\n                    gameName\n                }\n            }\n        }\n\n        div(\"statusbox\") {\n            p {\n                +state.phase.desc\n            }\n        }\n\n        if(state.phase == GamePhase.NEED_NAME) {\n            div(\"nameform\") {\n                h5 {\n                    +\"enter name\"\n                }\n                child(SimpleInputField::class) {\n                    attrs.handleNameAdd = {\n                        state.socket.send(\"name $it\")\n                        setState {\n                            phase = GamePhase.NEED_GAME_ID\n                        }\n                    }\n                }\n            }\n        }\n\n        if(state.phase == GamePhase.NEED_GAME_ID) {\n            div(\"gameform\") {\n                h5 {\n                    +\"enter game id\"\n                }\n                child(SimpleInputField::class) {\n                    attrs.handleNameAdd = {\n                        state.socket.send(\"game $it\")\n                        setState {\n                            phase = GamePhase.WAITING_FOR_NEXT_ROUND\n                            lobby = it\n                        }\n                    }\n                }\n            }\n        }\n\n        if(state.phase == GamePhase.WAITING_FOR_NEXT_ROUND) {\n            child(Button::class) {\n                attrs.label = \"Start Game\"\n                attrs.handleClick = {\n                    state.socket.send(\"start\")\n                }\n            }\n        }\n\n        if(state.phase == GamePhase.GUESS || state.phase == GamePhase.VOTE) {\n            h5 {\n                +\"observe image\"\n            }\n            child(ImageBox::class) {\n                attrs.image = state.image\n            }\n            h3 {\n                +\"${state.timeRemaining}s remaining\"\n            }\n        }\n\n        if(state.phase == GamePhase.GUESS) {\n            h5 {\n                +\"enter guess\"\n            }\n            child(SimpleInputField::class) {\n                attrs.handleNameAdd = {\n                    state.socket.send(\"guess $it\")\n                }\n            }\n        }\n\n        if(state.phase == GamePhase.VOTE) {\n            h5 {\n                +\"vote for your favorite!\"\n            }\n        }\n        if(state.phase == GamePhase.GUESS) {\n            h5 {\n                +\"taking suggestions...\"\n            }\n        }\n        if(state.phase == GamePhase.GUESS || state.phase == GamePhase.VOTE) {\n\n            child(VotingPanel::class) {\n                attrs.buttonPressHandler = {\n                    state.socket.send(\"vote $it\")\n                    setState {\n                        canVote = false\n                    }\n                }\n                attrs.options = state.guesses\n                attrs.shouldEnable = state.canVote\n                attrs.shouldShow = state.phase == GamePhase.VOTE\n            }\n\n        }\n\n        child(Leaderboard::class) {\n            attrs.players = state.players.map { x -> x.value.name to x.value.points }.toMap()\n        }\n\n        if(state.phase == GamePhase.WAITING_FOR_NEXT_ROUND) {\n            child(Evaluation::class) {\n                attrs.players = state.players.filterValues { it.lastRoundPoints != null }.map {\n                    it.value.name to Pair(state.guesses[it.key], it.value.lastRoundPoints)\n                }.toMap()\n            }\n        }\n    }\n}\n\n\n\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.*\nimport kotlin.text.*\nimport kotlin.comparisons.*\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count++ >= n) list.add(item)\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Collections.Transformations.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original collection.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) count++\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) count++\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    var maxValue = selector(maxElem)\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    var minValue = selector(minElem)\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(index++, accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val result = ArrayList<List<T>>((thisSize + step - 1) / step)\n        var index = 0\n        while (index < thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val result = ArrayList<R>((thisSize + step - 1) / step)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index < thisSize) {\n            window.move(index, (index + size).coerceAtMost(thisSize))\n            if (!partialWindows && window.size < size) break\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String(chars: CharArray): String {\n    return js(\"String.fromCharCode\").apply(null, chars)\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    return String(chars.copyOfRange(offset, offset + length))\n}\n\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@Deprecated(\"Use length property instead.\", ReplaceWith(\"length\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline val CharSequence.size: Int get() = length\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n"],"names":[],"mappings":"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"}