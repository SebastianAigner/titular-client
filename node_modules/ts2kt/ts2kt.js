#!/usr/bin/env node
(function (_, Kotlin, $module$typescript, $module$path, $module$fs, $module$process) {
  'use strict';
  var $$importsForInline$$ = _.$$importsForInline$$ || (_.$$importsForInline$$ = {});
  var getDefaultCompilerOptions = $module$typescript.getDefaultCompilerOptions;
  var Unit = Kotlin.kotlin.Unit;
  var Kind_CLASS = Kotlin.Kind.CLASS;
  var Kind_INTERFACE = Kotlin.Kind.INTERFACE;
  var repeat = Kotlin.kotlin.text.repeat_94bcnn$;
  var listOf = Kotlin.kotlin.collections.listOf_mh5how$;
  var MutableList = Kotlin.kotlin.collections.MutableList;
  var throwCCE = Kotlin.throwCCE;
  var joinToString = Kotlin.kotlin.collections.joinToString_fmv235$;
  var first = Kotlin.kotlin.collections.first_2p1efm$;
  var getCallableRef = Kotlin.getCallableRef;
  var emptyList = Kotlin.kotlin.collections.emptyList_287e2$;
  var plus = Kotlin.kotlin.collections.plus_mydzjv$;
  var toString = Kotlin.toString;
  var Kind_OBJECT = Kotlin.Kind.OBJECT;
  var Enum = Kotlin.kotlin.Enum;
  var throwISE = Kotlin.throwISE;
  var toList = Kotlin.kotlin.collections.toList_us0mfu$;
  var single = Kotlin.kotlin.collections.single_2p1efm$;
  var defineInlineFunction = Kotlin.defineInlineFunction;
  var wrapFunction = Kotlin.wrapFunction;
  var setOf = Kotlin.kotlin.collections.setOf_i5x0yv$;
  var equals = Kotlin.equals;
  var unboxChar = Kotlin.unboxChar;
  var drop = Kotlin.kotlin.text.drop_6ic1pp$;
  var CharRange = Kotlin.kotlin.ranges.CharRange;
  var StringBuilder = Kotlin.kotlin.text.StringBuilder;
  var iterator = Kotlin.kotlin.text.iterator_gw00vp$;
  var ensureNotNull = Kotlin.ensureNotNull;
  var Any = Object;
  var SyntaxKind$NumericLiteral = $module$typescript.SyntaxKind.NumericLiteral;
  var SyntaxKind$StringLiteral = $module$typescript.SyntaxKind.StringLiteral;
  var getCombinedModifierFlags = $module$typescript.getCombinedModifierFlags;
  var ModifierFlags$AccessibilityModifier = $module$typescript.ModifierFlags.AccessibilityModifier;
  var SyntaxKind$ArrayType = $module$typescript.SyntaxKind.ArrayType;
  var SyntaxKind$TypeReference = $module$typescript.SyntaxKind.TypeReference;
  var plus_0 = Kotlin.kotlin.collections.plus_qloxvw$;
  var SyntaxKind$ConstructorType = $module$typescript.SyntaxKind.ConstructorType;
  var SyntaxKind$FunctionType = $module$typescript.SyntaxKind.FunctionType;
  var SyntaxKind$UnionType = $module$typescript.SyntaxKind.UnionType;
  var SyntaxKind$IntersectionType = $module$typescript.SyntaxKind.IntersectionType;
  var SyntaxKind$AnyKeyword = $module$typescript.SyntaxKind.AnyKeyword;
  var SyntaxKind$ObjectKeyword = $module$typescript.SyntaxKind.ObjectKeyword;
  var SyntaxKind$NumberKeyword = $module$typescript.SyntaxKind.NumberKeyword;
  var SyntaxKind$StringKeyword = $module$typescript.SyntaxKind.StringKeyword;
  var SyntaxKind$BooleanKeyword = $module$typescript.SyntaxKind.BooleanKeyword;
  var SyntaxKind$VoidKeyword = $module$typescript.SyntaxKind.VoidKeyword;
  var SyntaxKind$NullKeyword = $module$typescript.SyntaxKind.NullKeyword;
  var SyntaxKind$UndefinedKeyword = $module$typescript.SyntaxKind.UndefinedKeyword;
  var SyntaxKind$ExpressionWithTypeArguments = $module$typescript.SyntaxKind.ExpressionWithTypeArguments;
  var SyntaxKind$Identifier = $module$typescript.SyntaxKind.Identifier;
  var SyntaxKind$TypeLiteral = $module$typescript.SyntaxKind.TypeLiteral;
  var SyntaxKind$ParenthesizedType = $module$typescript.SyntaxKind.ParenthesizedType;
  var SyntaxKind$LiteralType = $module$typescript.SyntaxKind.LiteralType;
  var SyntaxKind$ThisType = $module$typescript.SyntaxKind.ThisType;
  var SyntaxKind$TypePredicate = $module$typescript.SyntaxKind.TypePredicate;
  var SyntaxKind$PropertyAccessExpression = $module$typescript.SyntaxKind.PropertyAccessExpression;
  var distinct = Kotlin.kotlin.collections.distinct_7wnvza$;
  var dropLast = Kotlin.kotlin.collections.dropLast_yzln2o$;
  var last = Kotlin.kotlin.collections.last_2p1efm$;
  var SyntaxKind$ClassDeclaration = $module$typescript.SyntaxKind.ClassDeclaration;
  var SyntaxKind$InterfaceDeclaration = $module$typescript.SyntaxKind.InterfaceDeclaration;
  var forEachChild = $module$typescript.forEachChild;
  var SyntaxKind$ModuleDeclaration = $module$typescript.SyntaxKind.ModuleDeclaration;
  var SyntaxKind$FunctionDeclaration = $module$typescript.SyntaxKind.FunctionDeclaration;
  var SyntaxKind$VariableStatement = $module$typescript.SyntaxKind.VariableStatement;
  var SyntaxKind$EnumDeclaration = $module$typescript.SyntaxKind.EnumDeclaration;
  var SyntaxKind$TypeAliasDeclaration = $module$typescript.SyntaxKind.TypeAliasDeclaration;
  var SyntaxKind$HeritageClause = $module$typescript.SyntaxKind.HeritageClause;
  var SyntaxKind$Constructor = $module$typescript.SyntaxKind.Constructor;
  var SyntaxKind$ConstructSignature = $module$typescript.SyntaxKind.ConstructSignature;
  var SyntaxKind$MethodDeclaration = $module$typescript.SyntaxKind.MethodDeclaration;
  var SyntaxKind$MethodSignature = $module$typescript.SyntaxKind.MethodSignature;
  var SyntaxKind$PropertyDeclaration = $module$typescript.SyntaxKind.PropertyDeclaration;
  var SyntaxKind$PropertySignature = $module$typescript.SyntaxKind.PropertySignature;
  var SyntaxKind$IndexSignature = $module$typescript.SyntaxKind.IndexSignature;
  var SyntaxKind$CallSignature = $module$typescript.SyntaxKind.CallSignature;
  var SyntaxKind$ExportAssignment = $module$typescript.SyntaxKind.ExportAssignment;
  var SyntaxKind$ImportEqualsDeclaration = $module$typescript.SyntaxKind.ImportEqualsDeclaration;
  var SyntaxKind$EndOfFileToken = $module$typescript.SyntaxKind.EndOfFileToken;
  var unescapeIdentifier = $module$typescript.unescapeIdentifier;
  var numberToInt = Kotlin.numberToInt;
  var SymbolFlags$Alias = $module$typescript.SymbolFlags.Alias;
  var sorted = Kotlin.kotlin.collections.sorted_exjks8$;
  var asSequence = Kotlin.kotlin.collections.asSequence_7wnvza$;
  var generateSequence = Kotlin.kotlin.sequences.generateSequence_9ce4rd$;
  var zip = Kotlin.kotlin.sequences.zip_r7q3s9$;
  var flatMap = Kotlin.kotlin.sequences.flatMap_49vfel$;
  var toMutableList = Kotlin.kotlin.collections.toMutableList_4c7yge$;
  var generateSequence_0 = Kotlin.kotlin.sequences.generateSequence_gexuht$;
  var map = Kotlin.kotlin.sequences.map_z5avom$;
  var takeWhile = Kotlin.kotlin.sequences.takeWhile_euau3h$;
  var filter = Kotlin.kotlin.sequences.filter_euau3h$;
  var toList_0 = Kotlin.kotlin.sequences.toList_veqyi0$;
  var asReversed = Kotlin.kotlin.collections.asReversed_2p1efm$;
  var listOf_0 = Kotlin.kotlin.collections.listOf_i5x0yv$;
  var SyntaxKind$StaticKeyword = $module$typescript.SyntaxKind.StaticKeyword;
  var lazy = Kotlin.kotlin.lazy_klfg04$;
  var SyntaxKind$DeclareKeyword = $module$typescript.SyntaxKind.DeclareKeyword;
  var SyntaxKind$DefaultKeyword = $module$typescript.SyntaxKind.DefaultKeyword;
  var replace = Kotlin.kotlin.text.replace_r2fvfm$;
  var SyntaxKind$ExportKeyword = $module$typescript.SyntaxKind.ExportKeyword;
  var ModifierFlags$Export = $module$typescript.ModifierFlags.Export;
  var SyntaxKind$ObjectBindingPattern = $module$typescript.SyntaxKind.ObjectBindingPattern;
  var trimIndent = Kotlin.kotlin.text.trimIndent_pdl1vz$;
  var toList_1 = Kotlin.kotlin.collections.toList_7wnvza$;
  var plus_1 = Kotlin.kotlin.collections.plus_drqvgf$;
  var IntRange = Kotlin.kotlin.ranges.IntRange;
  var toList_2 = Kotlin.kotlin.collections.toList_abgq59$;
  var toMap = Kotlin.kotlin.collections.toMap_6hr0sd$;
  var singleOrNull = Kotlin.kotlin.collections.singleOrNull_us0mfu$;
  var TypeFlags$Any = $module$typescript.TypeFlags.Any;
  var TypeFlags$Union = $module$typescript.TypeFlags.Union;
  var TypeFlags$String = $module$typescript.TypeFlags.String;
  var TypeFlags$Boolean = $module$typescript.TypeFlags.Boolean;
  var TypeFlags$Number = $module$typescript.TypeFlags.Number;
  var TypeFlags$Void = $module$typescript.TypeFlags.Void;
  var TypeFlags$Undefined = $module$typescript.TypeFlags.Undefined;
  var TypeFlags$Null = $module$typescript.TypeFlags.Null;
  var TypeFlags$StringLiteral = $module$typescript.TypeFlags.StringLiteral;
  var TypeFlags$NumberLiteral = $module$typescript.TypeFlags.NumberLiteral;
  var TypeFlags$BooleanLiteral = $module$typescript.TypeFlags.BooleanLiteral;
  var TypeFlags$Intersection = $module$typescript.TypeFlags.Intersection;
  var TypeFlags$TypeParameter = $module$typescript.TypeFlags.TypeParameter;
  var ObjectFlags$Anonymous = $module$typescript.ObjectFlags.Anonymous;
  var ObjectFlags$ClassOrInterface = $module$typescript.ObjectFlags.ClassOrInterface;
  var ObjectFlags$Reference = $module$typescript.ObjectFlags.Reference;
  var TypeFlags$Object = $module$typescript.TypeFlags.Object;
  var TypeFlags$Enum = $module$typescript.TypeFlags.Enum;
  var first_0 = Kotlin.kotlin.collections.first_us0mfu$;
  var joinToString_0 = Kotlin.kotlin.collections.joinToString_cgipc5$;
  var ObjectFlags$Tuple = $module$typescript.ObjectFlags.Tuple;
  var joinToString_1 = Kotlin.kotlin.sequences.joinToString_853xkz$;
  var asSequence_0 = Kotlin.kotlin.collections.asSequence_us0mfu$;
  var emptySequence = Kotlin.kotlin.sequences.emptySequence_287e2$;
  var sequenceOf = Kotlin.kotlin.sequences.sequenceOf_i5x0yv$;
  var plus_2 = Kotlin.kotlin.sequences.plus_v0iwhp$;
  var startsWith = Kotlin.kotlin.text.startsWith_7epoxm$;
  var indexOf = Kotlin.kotlin.text.indexOf_8eortd$;
  var split = Kotlin.kotlin.text.split_ip8yn$;
  var SyntaxKind$ModuleBlock = $module$typescript.SyntaxKind.ModuleBlock;
  var zip_0 = Kotlin.kotlin.collections.zip_45mdf7$;
  var Pair = Kotlin.kotlin.Pair;
  var emptyMap = Kotlin.kotlin.collections.emptyMap_q3lmfv$;
  var IllegalStateException_init = Kotlin.kotlin.IllegalStateException_init_pdl1vj$;
  var Exception_init = Kotlin.kotlin.Exception_init;
  var HashMap_init = Kotlin.kotlin.collections.HashMap_init_q3lmfv$;
  var Throwable = Error;
  var drop_0 = Kotlin.kotlin.collections.drop_8ujjk8$;
  var endsWith = Kotlin.kotlin.text.endsWith_7epoxm$;
  var getDefaultLibFilePath = $module$typescript.getDefaultLibFilePath;
  var fromString = $module$typescript.ScriptSnapshot.fromString;
  var to = Kotlin.kotlin.to_ujzrz7$;
  var createDocumentRegistry = $module$typescript.createDocumentRegistry;
  var createLanguageService = $module$typescript.createLanguageService;
  var normalizePath = $module$typescript.normalizePath;
  var hashMapOf = Kotlin.kotlin.collections.hashMapOf_qfcya0$;
  var getDirectoryPath = $module$typescript.getDirectoryPath;
  var preProcessFile = $module$typescript.preProcessFile;
  var sortedDescending = Kotlin.kotlin.collections.sortedDescending_exjks8$;
  KtPackagePart.prototype = Object.create(AbstractKtNode.prototype);
  KtPackagePart.prototype.constructor = KtPackagePart;
  KtArgument.prototype = Object.create(AbstractKtNode.prototype);
  KtArgument.prototype.constructor = KtArgument;
  KtAnnotation.prototype = Object.create(AbstractKtNode.prototype);
  KtAnnotation.prototype.constructor = KtAnnotation;
  KtClassKind.prototype = Object.create(Enum.prototype);
  KtClassKind.prototype.constructor = KtClassKind;
  KtClassifier.prototype = Object.create(AbstractKtNode.prototype);
  KtClassifier.prototype.constructor = KtClassifier;
  KtFunParam.prototype = Object.create(AbstractKtNode.prototype);
  KtFunParam.prototype.constructor = KtFunParam;
  KtCallSignature.prototype = Object.create(AbstractKtNode.prototype);
  KtCallSignature.prototype.constructor = KtCallSignature;
  KtFunction.prototype = Object.create(AbstractKtNode.prototype);
  KtFunction.prototype.constructor = KtFunction;
  KtVariable.prototype = Object.create(AbstractKtNode.prototype);
  KtVariable.prototype.constructor = KtVariable;
  KtEnumEntry.prototype = Object.create(AbstractKtNode.prototype);
  KtEnumEntry.prototype.constructor = KtEnumEntry;
  KtHeritageType.prototype = Object.create(AbstractKtNode.prototype);
  KtHeritageType.prototype.constructor = KtHeritageType;
  KtTypeUnion_0.prototype = Object.create(AbstractKtNode.prototype);
  KtTypeUnion_0.prototype.constructor = KtTypeUnion_0;
  KtType.prototype = Object.create(AbstractKtNode.prototype);
  KtType.prototype.constructor = KtType;
  KtTypeParam.prototype = Object.create(AbstractKtNode.prototype);
  KtTypeParam.prototype.constructor = KtTypeParam;
  KtTypeAnnotation.prototype = Object.create(AbstractKtNode.prototype);
  KtTypeAnnotation.prototype.constructor = KtTypeAnnotation;
  TsClassifierToKt.prototype = Object.create(TypeScriptToKotlinBase.prototype);
  TsClassifierToKt.prototype.constructor = TsClassifierToKt;
  TsClassToKt.prototype = Object.create(TsClassifierToKt.prototype);
  TsClassToKt.prototype.constructor = TsClassToKt;
  TsInterfaceToKt.prototype = Object.create(TsClassifierToKt.prototype);
  TsInterfaceToKt.prototype.constructor = TsInterfaceToKt;
  TsInterfaceToKtExtensions.prototype = Object.create(TsInterfaceToKt.prototype);
  TsInterfaceToKtExtensions.prototype.constructor = TsInterfaceToKtExtensions;
  TypeScriptToKotlin.prototype = Object.create(TypeScriptToKotlinBase.prototype);
  TypeScriptToKotlin.prototype.constructor = TypeScriptToKotlin;
  DiagnosticLevel.prototype = Object.create(Enum.prototype);
  DiagnosticLevel.prototype.constructor = DiagnosticLevel;
  function FileSystemBasedLSH(file2scriptSnapshot, currentDirectory) {
    this.currentDirectory = currentDirectory;
    this.filesCache_0 = [];
    this.file2scriptSnapshot_ezm4qw$_0 = file2scriptSnapshot;
    this.log_4gdksn$_0 = FileSystemBasedLSH$log$lambda;
  }
  var copyToArray = Kotlin.kotlin.collections.copyToArray;
  Object.defineProperty(FileSystemBasedLSH.prototype, 'file2scriptSnapshot', {
    get: function () {
      return this.file2scriptSnapshot_ezm4qw$_0;
    },
    set: function (value) {
      this.file2scriptSnapshot_ezm4qw$_0 = value;
      this.filesCache_0 = copyToArray(value.keys);
    }
  });
  FileSystemBasedLSH.prototype.getCompilationSettings = function () {
    return getDefaultCompilerOptions();
  };
  FileSystemBasedLSH.prototype.getScriptFileNames = function () {
    return this.filesCache_0;
  };
  FileSystemBasedLSH.prototype.getScriptVersion = function (fileName) {
    return '0';
  };
  FileSystemBasedLSH.prototype.getScriptSnapshot = function (fileName) {
    return this.file2scriptSnapshot.get_11rb$(fileName);
  };
  FileSystemBasedLSH.prototype.getCurrentDirectory = function () {
    return this.currentDirectory;
  };
  FileSystemBasedLSH.prototype.getDefaultLibFileName = function (options) {
    return 'lib.d.ts';
  };
  Object.defineProperty(FileSystemBasedLSH.prototype, 'log', {
    get: function () {
      return this.log_4gdksn$_0;
    }
  });
  function FileSystemBasedLSH$log$lambda(message) {
    console.log(message);
    return Unit;
  }
  FileSystemBasedLSH.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'FileSystemBasedLSH',
    interfaces: []
  };
  function KtVisitor() {
  }
  KtVisitor.$metadata$ = {
    kind: Kind_INTERFACE,
    simpleName: 'KtVisitor',
    interfaces: []
  };
  function Output(indentWidth) {
    if (indentWidth === void 0)
      indentWidth = 4;
    this.buffer_0 = '';
    this.singleIndent_0 = repeat(' ', indentWidth);
    var tmp$;
    this.indentCache_0 = Kotlin.isType(tmp$ = listOf(''), MutableList) ? tmp$ : throwCCE();
    this.currentDepth_0 = 0;
    this.indent_0 = '';
  }
  Output.prototype.toString = function () {
    return this.buffer_0;
  };
  Output.prototype.print_61zpoe$ = function (value) {
    this.buffer_0 += value;
  };
  Output.prototype.println_61zpoe$ = function (value) {
    this.print_61zpoe$(value);
    this.println();
  };
  Output.prototype.println = function () {
    this.print_61zpoe$('\n');
  };
  Output.prototype.printIndent = function () {
    this.print_61zpoe$(this.indent_0);
  };
  Output.prototype.printWithIndent_61zpoe$ = function (value) {
    this.printIndent();
    this.print_61zpoe$(value);
  };
  Output.prototype.printlnWithIndent_61zpoe$ = function (value) {
    this.printWithIndent_61zpoe$(value);
    this.println();
  };
  Output.prototype.printlnWithIndent = function () {
    this.printWithIndent_61zpoe$('\n');
  };
  Output.prototype.getIndent_0 = function (depth) {
    assert(depth >= 0, 'The indent index should be >= 0');
    if (depth < this.indentCache_0.size)
      return this.indentCache_0.get_za3lpa$(depth);
    for (var i = this.indentCache_0.size; i <= depth; i++) {
      this.indentCache_0.add_11rb$(this.indentCache_0.get_za3lpa$(i - 1 | 0) + this.singleIndent_0);
    }
    return this.indentCache_0.get_za3lpa$(depth);
  };
  Output.prototype.pushIndent = function () {
    this.currentDepth_0 = this.currentDepth_0 + 1 | 0;
    this.indent_0 = this.getIndent_0(this.currentDepth_0);
  };
  Output.prototype.popIndent = function () {
    this.currentDepth_0 = this.currentDepth_0 - 1 | 0;
    this.indent_0 = this.getIndent_0(this.currentDepth_0);
  };
  Output.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'Output',
    interfaces: []
  };
  function indent($receiver, f) {
    $receiver.pushIndent();
    f($receiver);
    $receiver.popIndent();
  }
  var NO_IMPL;
  var EQ_NO_IMPL;
  var NO_IMPL_PROPERTY_GETTER;
  var NO_IMPL_PROPERTY_SETTER;
  var EXTERNAL;
  var OPEN;
  var OVERRIDE;
  var OPERATOR;
  var VAR;
  var VAL;
  var FUN;
  var VARARG;
  function Stringify(packagePartPrefix, topLevel, additionalImports, suppressedDiagnostics, out) {
    if (additionalImports === void 0) {
      additionalImports = emptyList();
    }
    if (suppressedDiagnostics === void 0) {
      suppressedDiagnostics = emptyList();
    }
    if (out === void 0)
      out = new Output();
    this.packagePartPrefix_0 = packagePartPrefix;
    this.topLevel_0 = topLevel;
    this.additionalImports_0 = additionalImports;
    this.suppressedDiagnostics_0 = suppressedDiagnostics;
    this.out_0 = out;
  }
  Object.defineProperty(Stringify.prototype, 'result', {
    get: function () {
      return this.out_0.toString();
    }
  });
  Stringify.prototype.acceptForEach_0 = function ($receiver, visitor, delimiter, startWithIfNotEmpty, endWithIfNotEmpty) {
    if (delimiter === void 0)
      delimiter = null;
    if (startWithIfNotEmpty === void 0)
      startWithIfNotEmpty = null;
    if (endWithIfNotEmpty === void 0)
      endWithIfNotEmpty = null;
    if (!$receiver.isEmpty() && startWithIfNotEmpty != null) {
      this.out_0.print_61zpoe$(startWithIfNotEmpty);
    }
    for (var i = 0; i !== $receiver.size; ++i) {
      if (delimiter != null && i > 0) {
        this.out_0.print_61zpoe$(delimiter);
      }
      $receiver.get_za3lpa$(i).accept_nbqbgi$(visitor);
    }
    if (!$receiver.isEmpty() && endWithIfNotEmpty != null) {
      this.out_0.print_61zpoe$(endWithIfNotEmpty);
    }
  };
  var NotImplementedError_init = Kotlin.kotlin.NotImplementedError;
  Stringify.prototype.visitNode_yawk5q$ = function (node) {
    throw new NotImplementedError_init();
  };
  Stringify.prototype.visitAnnotation_tw9up$ = function (annotation) {
    if (annotation != null ? annotation.equals(NATIVE_ANNOTATION) : null)
      return;
    this.out_0.printWithIndent_61zpoe$('@');
    this.printAnnotation_0(annotation);
    this.out_0.println();
  };
  Stringify.prototype.printExternalIfNeed_0 = function () {
    if (this.topLevel_0) {
      this.out_0.print_61zpoe$(EXTERNAL + ' ');
    }
  };
  Stringify.prototype.printAnnotation_0 = function (annotation) {
    this.out_0.print_61zpoe$(annotation.name.asString());
    this.acceptForEach_0(annotation.parameters, this, ', ', '(', ')');
  };
  var ArrayList_init = Kotlin.kotlin.collections.ArrayList_init_ww73n8$;
  function Stringify$visitClassifier$lambda$lambda(this$, this$Stringify) {
    return function ($receiver) {
      if (this$.paramsOfConstructors.size > 1) {
        var $receiver_0 = this$.paramsOfConstructors;
        var tmp$;
        tmp$ = $receiver_0.iterator();
        while (tmp$.hasNext()) {
          var element = tmp$.next();
          var this$Stringify_0 = this$Stringify;
          $receiver.printWithIndent_61zpoe$('constructor(');
          this$Stringify_0.acceptForEach_0(element, this$Stringify_0, ', ');
          $receiver.println_61zpoe$(')');
        }
      }
      var tmp$_0 = this$Stringify;
      var $receiver_1 = this$.members;
      var predicate = isNotAnnotatedAsFake;
      var destination = ArrayList_init();
      var tmp$_1;
      tmp$_1 = $receiver_1.iterator();
      while (tmp$_1.hasNext()) {
        var element_0 = tmp$_1.next();
        if (predicate(element_0))
          destination.add_11rb$(element_0);
      }
      tmp$_0.acceptForEach_0(destination, this$Stringify.innerStringifier_0(), this$.kind === KtClassKind$ENUM_getInstance() ? ',\n' : '', void 0, this$.kind === KtClassKind$ENUM_getInstance() ? '\n' : '');
      return Unit;
    };
  }
  Stringify.prototype.visitClassifier_k8ctg1$ = function (classifier) {
    var tmp$;
    this.acceptForEach_0(classifier.annotations, this);
    this.out_0.printIndent();
    this.printExternalIfNeed_0();
    if (classifier.hasOpenModifier) {
      this.out_0.print_61zpoe$(OPEN + ' ');
    }
    this.out_0.print_61zpoe$(classifier.kind.keyword);
    var nameToPrint = classifier.name.asString();
    if (nameToPrint.length > 0) {
      this.out_0.print_61zpoe$(' ' + nameToPrint);
    }
    (tmp$ = classifier.typeParams) != null ? (this.acceptForEach_0(tmp$, this, ', ', '<', '>'), Unit) : null;
    if (classifier.paramsOfConstructors.size === 1) {
      this.acceptForEach_0(classifier.paramsOfConstructors.get_za3lpa$(0), this, ', ', '(', ')');
    }
    this.acceptForEach_0(classifier.parents, this, ', ', ' : ');
    var bracesRequired = classifier.kind.bracesAlwaysRequired || classifier.paramsOfConstructors.size > 1 || !classifier.members.isEmpty();
    if (bracesRequired) {
      this.out_0.println_61zpoe$(' {');
    }
    indent(this.out_0, Stringify$visitClassifier$lambda$lambda(classifier, this));
    if (bracesRequired) {
      this.out_0.printWithIndent_61zpoe$('}');
    }
    this.out_0.println();
  };
  Stringify.prototype.visitFunction_g5u9tk$ = function (function_0) {
    this.acceptForEach_0(function_0.annotations, this);
    this.out_0.printIndent();
    this.printExternalIfNeed_0();
    if (function_0.isOverride) {
      this.out_0.print_61zpoe$(OVERRIDE + ' ');
    }
     else if (function_0.hasOpenModifier) {
      this.out_0.print_61zpoe$(OPEN + ' ');
    }
    if (function_0.isOperator) {
      this.out_0.print_61zpoe$(OPERATOR + ' ');
    }
    this.out_0.print_61zpoe$(FUN + ' ');
    this.printTypeParams_340l6o$(function_0.callSignature, true);
    if (function_0.extendsType != null) {
      function_0.extendsType.accept_nbqbgi$(this);
      this.out_0.print_61zpoe$('.');
    }
    this.out_0.print_61zpoe$(function_0.name.asString());
    this.printToOut_6dmgio$(function_0.callSignature, false, function_0.needsNoImpl, !function_0.isOverride);
    if (function_0.needsNoImpl) {
      this.out_0.print_61zpoe$(EQ_NO_IMPL);
    }
    this.out_0.println();
  };
  Stringify.prototype.visitVariable_bd4hv0$ = function (variable) {
    var tmp$, tmp$_0;
    this.acceptForEach_0(variable.annotations, this);
    this.out_0.printIndent();
    this.printExternalIfNeed_0();
    if (variable.isOverride) {
      this.out_0.print_61zpoe$(OVERRIDE + ' ');
    }
     else if (variable.hasOpenModifier) {
      this.out_0.print_61zpoe$(OPEN + ' ');
    }
    this.out_0.print_61zpoe$((variable.isVar ? VAR : VAL) + ' ');
    (tmp$ = variable.typeParams) != null ? (this.acceptForEach_0(tmp$, this, ', ', '<', '> '), Unit) : null;
    if ((tmp$_0 = variable.extendsType) != null) {
      tmp$_0.accept_nbqbgi$(this);
      this.out_0.print_61zpoe$('.');
    }
    this.out_0.print_61zpoe$(variable.name.asString());
    this.printToOut_laliwh$(variable.type, !variable.needsNoImpl);
    if (variable.needsNoImpl) {
      if (variable.isInInterface) {
        this.out_0.print_61zpoe$(NO_IMPL_PROPERTY_GETTER);
        if (variable.isVar) {
          this.out_0.print_61zpoe$(';' + NO_IMPL_PROPERTY_SETTER);
        }
      }
       else {
        this.out_0.print_61zpoe$(EQ_NO_IMPL);
      }
    }
    this.out_0.println();
  };
  function Stringify$visitPackagePart$lambda(it) {
    return '"' + it + '"';
  }
  function Stringify$visitPackagePart$lambda_0(it) {
    return escapeIfNeed(sanitize(it));
  }
  Stringify.prototype.visitPackagePart_56vfc9$ = function (packagePart) {
    var tmp$, tmp$_0;
    var $receiver = packagePart.annotations;
    var destination = ArrayList_init();
    var tmp$_1;
    tmp$_1 = $receiver.iterator();
    while (tmp$_1.hasNext()) {
      var element = tmp$_1.next();
      if (!(element != null ? element.equals(NATIVE_ANNOTATION) : null))
        destination.add_11rb$(element);
    }
    var annotations = destination;
    if (!this.suppressedDiagnostics_0.isEmpty()) {
      this.out_0.printlnWithIndent_61zpoe$('@file:Suppress(' + joinToString(this.suppressedDiagnostics_0, void 0, void 0, void 0, void 0, void 0, Stringify$visitPackagePart$lambda) + ')');
      if (annotations.isEmpty())
        this.out_0.println();
    }
    if (!annotations.isEmpty()) {
      this.out_0.print_61zpoe$('@file:');
      if (annotations.size === 1) {
        this.printAnnotation_0(first(annotations));
      }
       else {
        this.out_0.print_61zpoe$('[');
        var tmp$_2, tmp$_0_0;
        var index = 0;
        tmp$_2 = annotations.iterator();
        while (tmp$_2.hasNext()) {
          var item = tmp$_2.next();
          if ((tmp$_0_0 = index, index = tmp$_0_0 + 1 | 0, tmp$_0_0) > 0) {
            this.out_0.print_61zpoe$(' ');
          }
          this.printAnnotation_0(item);
        }
        this.out_0.print_61zpoe$(']');
      }
      this.out_0.println();
    }
    var packageNameParts = plus((tmp$_0 = (tmp$ = this.packagePartPrefix_0) != null ? listOf(tmp$) : null) != null ? tmp$_0 : emptyList(), packagePart.fqName);
    if (!packageNameParts.isEmpty()) {
      this.out_0.println_61zpoe$('package ' + joinToString(packageNameParts, '.', void 0, void 0, void 0, void 0, Stringify$visitPackagePart$lambda_0));
      this.out_0.println();
    }
    if (!this.additionalImports_0.isEmpty()) {
      var tmp$_3;
      tmp$_3 = this.additionalImports_0.iterator();
      while (tmp$_3.hasNext()) {
        var element_0 = tmp$_3.next();
        this.out_0.printlnWithIndent_61zpoe$('import ' + element_0);
      }
      this.out_0.println();
    }
    var $receiver_0 = packagePart.members;
    var predicate = isNotAnnotatedAsFake;
    var destination_0 = ArrayList_init();
    var tmp$_4;
    tmp$_4 = $receiver_0.iterator();
    while (tmp$_4.hasNext()) {
      var element_1 = tmp$_4.next();
      if (predicate(element_1))
        destination_0.add_11rb$(element_1);
    }
    this.acceptForEach_0(destination_0, this);
  };
  Stringify.prototype.printToOut_sa4ob0$ = function ($receiver, printDefaultValue) {
    if ($receiver.isVar) {
      this.out_0.print_61zpoe$('open var ');
    }
    if ($receiver.type.isVararg) {
      this.out_0.print_61zpoe$(VARARG + ' ');
    }
    this.out_0.print_61zpoe$($receiver.name.asString());
    this.printToOut_laliwh$($receiver.type, true);
    if ($receiver.defaultValue != null && printDefaultValue) {
      this.out_0.print_61zpoe$(' = ' + NO_IMPL + ' /* ' + toString($receiver.defaultValue) + ' */');
    }
  };
  Stringify.prototype.visitFunParam_ggmbia$ = function (funParam) {
    this.printToOut_sa4ob0$(funParam, true);
  };
  Stringify.prototype.visitCallSignature_qsdh4m$ = function (signature) {
    this.printToOut_6dmgio$(signature, true, true, true);
  };
  Stringify.prototype.printTypeParams_340l6o$ = function ($receiver, withSpaceAfter) {
    var tmp$;
    (tmp$ = $receiver.typeParams) != null ? (this.acceptForEach_0(tmp$, this, ', ', '<', '>' + (withSpaceAfter ? ' ' : '')), Unit) : null;
  };
  Stringify.prototype.printToOut_6dmgio$ = function ($receiver, withTypeParams, printUnitReturnType, printDefaultValues) {
    if (withTypeParams) {
      this.printTypeParams_340l6o$($receiver, false);
    }
    this.out_0.print_61zpoe$('(');
    var tmp$, tmp$_0;
    var index = 0;
    tmp$ = $receiver.params.iterator();
    while (tmp$.hasNext()) {
      var item = tmp$.next();
      if ((tmp$_0 = index, index = tmp$_0 + 1 | 0, tmp$_0) > 0)
        this.out_0.print_61zpoe$(', ');
      this.printToOut_sa4ob0$(item, printDefaultValues);
    }
    this.out_0.print_61zpoe$(')');
    this.printToOut_laliwh$($receiver.returnType, printUnitReturnType);
  };
  Stringify.prototype.visitEnumEntry_241v5t$ = function (enumEntry) {
    var tmp$;
    this.out_0.printWithIndent_61zpoe$(enumEntry.name.asString());
    if ((tmp$ = enumEntry.value) != null) {
      this.out_0.print_61zpoe$(' /* = ' + tmp$ + ' */');
    }
  };
  Stringify.prototype.visitTypeParam_6v1wg3$ = function (typeParam) {
    var tmp$;
    this.out_0.print_61zpoe$(typeParam.name.asString());
    if ((tmp$ = typeParam.upperBound) != null) {
      this.out_0.print_61zpoe$(' : ');
      tmp$.accept_nbqbgi$(this);
    }
  };
  Stringify.prototype.printToOut_laliwh$ = function ($receiver, printUnitType) {
    var isUnit = $receiver.type.isUnit() && !$receiver.isVararg;
    if (!printUnitType && isUnit)
      return;
    this.out_0.print_61zpoe$(': ');
    $receiver.type.accept_nbqbgi$(this);
  };
  Stringify.prototype.visitTypeAnnotation_ryuo7b$ = function (typeAnnotation) {
    this.printToOut_laliwh$(typeAnnotation, true);
  };
  function Stringify$visitType$lambda$lambda(it) {
    var tmp$, tmp$_0;
    return it.name.asString() + stringify(it.type) + toString((tmp$_0 = (tmp$ = it.defaultValue) != null ? ' /*= ' + tmp$ + '*/' : null) != null ? tmp$_0 : '');
  }
  Stringify.prototype.visitType_yasija$ = function (type) {
    var tmp$, tmp$_0;
    var callSignature = type.callSignature;
    if (callSignature != null) {
      if (type.isNullable)
        this.out_0.print_61zpoe$('(');
      var params = joinToString(callSignature.params, ', ', void 0, void 0, void 0, void 0, Stringify$visitType$lambda$lambda);
      var typeAsString = '(' + params + ') -> ' + stringify(callSignature.returnType.type);
      this.out_0.print_61zpoe$(typeAsString);
      if (type.isNullable)
        this.out_0.print_61zpoe$(')');
    }
     else {
      this.out_0.print_61zpoe$(type.qualifiedName.asString());
      this.acceptForEach_0(type.typeArgs, this, ', ', '<', '>');
    }
    if (type.isNullable && !((tmp$ = type.qualifiedName) != null ? tmp$.equals(DYNAMIC) : null)) {
      this.out_0.print_61zpoe$('?');
    }
    if ((tmp$_0 = type.comment) != null) {
      this.out_0.print_61zpoe$(' /* ' + tmp$_0 + ' */');
    }
  };
  Stringify.prototype.visitTypeUnion_6y0zwl$ = function (typeUnion) {
    this.acceptForEach_0(typeUnion.possibleTypes, this, ' | ');
  };
  Stringify.prototype.visitHeritageType_dup87$ = function (heritageType) {
    var tmp$;
    this.visitType_yasija$(heritageType.type);
    if ((tmp$ = heritageType.byExpression) != null) {
      this.out_0.print_61zpoe$(' by ' + tmp$);
    }
  };
  Stringify.prototype.visitArgument_5qn25p$ = function (argument) {
    var tmp$;
    if ((tmp$ = argument.name) != null) {
      this.out_0.print_61zpoe$(tmp$.toString() + ' = ');
    }
    this.out_0.print_61zpoe$(argument.value.toString());
  };
  Stringify.prototype.innerStringifier_0 = function () {
    return new Stringify(this.packagePartPrefix_0, false, this.additionalImports_0, this.suppressedDiagnostics_0, this.out_0);
  };
  Stringify.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'Stringify',
    interfaces: [KtVisitor]
  };
  var MODULE;
  var FAKE;
  var FAKE_ANNOTATION;
  var DEFAULT_FAKE_ANNOTATION;
  function isNotAnnotatedAsFake$lambda(node) {
    var tmp$;
    var result = true;
    tmp$ = node.annotations.iterator();
    while (tmp$.hasNext()) {
      var a = tmp$.next();
      if (a != null ? a.equals(FAKE_ANNOTATION) : null) {
        result = false;
        break;
      }
    }
    return result;
  }
  var isNotAnnotatedAsFake;
  function KtNode() {
  }
  KtNode.$metadata$ = {
    kind: Kind_INTERFACE,
    simpleName: 'KtNode',
    interfaces: []
  };
  function AbstractKtNode() {
  }
  AbstractKtNode.prototype.accept_nbqbgi$ = function (visitor) {
    visitor.visitNode_yawk5q$(this);
  };
  AbstractKtNode.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'AbstractKtNode',
    interfaces: [KtNode]
  };
  function KtWithMembers() {
  }
  KtWithMembers.$metadata$ = {
    kind: Kind_INTERFACE,
    simpleName: 'KtWithMembers',
    interfaces: []
  };
  function KtPackagePart(fqName, members, annotations) {
    AbstractKtNode.call(this);
    this.fqName = fqName;
    this.members_qwgf8m$_0 = members;
    this.annotations_s16ayj$_0 = annotations;
  }
  Object.defineProperty(KtPackagePart.prototype, 'members', {
    get: function () {
      return this.members_qwgf8m$_0;
    },
    set: function (members) {
      this.members_qwgf8m$_0 = members;
    }
  });
  Object.defineProperty(KtPackagePart.prototype, 'annotations', {
    get: function () {
      return this.annotations_s16ayj$_0;
    },
    set: function (annotations) {
      this.annotations_s16ayj$_0 = annotations;
    }
  });
  KtPackagePart.prototype.accept_nbqbgi$ = function (visitor) {
    visitor.visitPackagePart_56vfc9$(this);
  };
  KtPackagePart.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'KtPackagePart',
    interfaces: [KtWithMembers, KtAnnotated, AbstractKtNode]
  };
  function KtName(value) {
    KtName$Companion_getInstance();
    this.value = value;
  }
  KtName.prototype.asString = function () {
    return escapeIfNeed(this.value);
  };
  function KtName$Companion() {
    KtName$Companion_instance = this;
    this.NO_NAME = new KtName('');
  }
  KtName$Companion.$metadata$ = {
    kind: Kind_OBJECT,
    simpleName: 'Companion',
    interfaces: []
  };
  var KtName$Companion_instance = null;
  function KtName$Companion_getInstance() {
    if (KtName$Companion_instance === null) {
      new KtName$Companion();
    }
    return KtName$Companion_instance;
  }
  KtName.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'KtName',
    interfaces: []
  };
  KtName.prototype.component1 = function () {
    return this.value;
  };
  KtName.prototype.copy_61zpoe$ = function (value) {
    return new KtName(value === void 0 ? this.value : value);
  };
  KtName.prototype.toString = function () {
    return 'KtName(value=' + Kotlin.toString(this.value) + ')';
  };
  KtName.prototype.hashCode = function () {
    var result = 0;
    result = result * 31 + Kotlin.hashCode(this.value) | 0;
    return result;
  };
  KtName.prototype.equals = function (other) {
    return this === other || (other !== null && (typeof other === 'object' && (Object.getPrototypeOf(this) === Object.getPrototypeOf(other) && Kotlin.equals(this.value, other.value))));
  };
  function KtQualifiedName(name, qualifier) {
    if (qualifier === void 0)
      qualifier = null;
    this.name = name;
    this.qualifier = qualifier;
  }
  KtQualifiedName.prototype.asString = function () {
    var tmp$, tmp$_0;
    return ((tmp$_0 = (tmp$ = this.qualifier) != null ? tmp$.asString() + '.' : null) != null ? tmp$_0 : '') + this.name.asString();
  };
  KtQualifiedName.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'KtQualifiedName',
    interfaces: []
  };
  function KtQualifiedName_init(name, qualifier, $this) {
    if (qualifier === void 0)
      qualifier = null;
    $this = $this || Object.create(KtQualifiedName.prototype);
    KtQualifiedName.call($this, new KtName(name), qualifier);
    return $this;
  }
  KtQualifiedName.prototype.component1 = function () {
    return this.name;
  };
  KtQualifiedName.prototype.component2 = function () {
    return this.qualifier;
  };
  KtQualifiedName.prototype.copy_uzs46h$ = function (name, qualifier) {
    return new KtQualifiedName(name === void 0 ? this.name : name, qualifier === void 0 ? this.qualifier : qualifier);
  };
  KtQualifiedName.prototype.toString = function () {
    return 'KtQualifiedName(name=' + Kotlin.toString(this.name) + (', qualifier=' + Kotlin.toString(this.qualifier)) + ')';
  };
  KtQualifiedName.prototype.hashCode = function () {
    var result = 0;
    result = result * 31 + Kotlin.hashCode(this.name) | 0;
    result = result * 31 + Kotlin.hashCode(this.qualifier) | 0;
    return result;
  };
  KtQualifiedName.prototype.equals = function (other) {
    return this === other || (other !== null && (typeof other === 'object' && (Object.getPrototypeOf(this) === Object.getPrototypeOf(other) && (Kotlin.equals(this.name, other.name) && Kotlin.equals(this.qualifier, other.qualifier)))));
  };
  function KtNamed() {
  }
  KtNamed.$metadata$ = {
    kind: Kind_INTERFACE,
    simpleName: 'KtNamed',
    interfaces: []
  };
  function KtAnnotated() {
  }
  KtAnnotated.$metadata$ = {
    kind: Kind_INTERFACE,
    simpleName: 'KtAnnotated',
    interfaces: []
  };
  function KtMember() {
  }
  KtMember.$metadata$ = {
    kind: Kind_INTERFACE,
    simpleName: 'KtMember',
    interfaces: [KtAnnotated, KtNamed, KtNode]
  };
  function KtArgument(value, name) {
    if (name === void 0)
      name = null;
    AbstractKtNode.call(this);
    this.value = value;
    this.name = name;
  }
  KtArgument.prototype.accept_nbqbgi$ = function (visitor) {
    visitor.visitArgument_5qn25p$(this);
  };
  KtArgument.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'KtArgument',
    interfaces: [AbstractKtNode]
  };
  KtArgument.prototype.component1 = function () {
    return this.value;
  };
  KtArgument.prototype.component2 = function () {
    return this.name;
  };
  KtArgument.prototype.copy_oq671r$ = function (value, name) {
    return new KtArgument(value === void 0 ? this.value : value, name === void 0 ? this.name : name);
  };
  KtArgument.prototype.toString = function () {
    return 'KtArgument(value=' + Kotlin.toString(this.value) + (', name=' + Kotlin.toString(this.name)) + ')';
  };
  KtArgument.prototype.hashCode = function () {
    var result = 0;
    result = result * 31 + Kotlin.hashCode(this.value) | 0;
    result = result * 31 + Kotlin.hashCode(this.name) | 0;
    return result;
  };
  KtArgument.prototype.equals = function (other) {
    return this === other || (other !== null && (typeof other === 'object' && (Object.getPrototypeOf(this) === Object.getPrototypeOf(other) && (Kotlin.equals(this.value, other.value) && Kotlin.equals(this.name, other.name)))));
  };
  function KtAnnotation(name, parameters) {
    if (parameters === void 0) {
      parameters = emptyList();
    }
    AbstractKtNode.call(this);
    this.name_1u24qo$_0 = name;
    this.parameters = parameters;
  }
  Object.defineProperty(KtAnnotation.prototype, 'name', {
    get: function () {
      return this.name_1u24qo$_0;
    },
    set: function (name) {
      this.name_1u24qo$_0 = name;
    }
  });
  KtAnnotation.prototype.accept_nbqbgi$ = function (visitor) {
    visitor.visitAnnotation_tw9up$(this);
  };
  KtAnnotation.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'KtAnnotation',
    interfaces: [AbstractKtNode, KtNamed]
  };
  KtAnnotation.prototype.component1 = function () {
    return this.name;
  };
  KtAnnotation.prototype.component2 = function () {
    return this.parameters;
  };
  KtAnnotation.prototype.copy_e6cya5$ = function (name, parameters) {
    return new KtAnnotation(name === void 0 ? this.name : name, parameters === void 0 ? this.parameters : parameters);
  };
  KtAnnotation.prototype.toString = function () {
    return 'KtAnnotation(name=' + Kotlin.toString(this.name) + (', parameters=' + Kotlin.toString(this.parameters)) + ')';
  };
  KtAnnotation.prototype.hashCode = function () {
    var result = 0;
    result = result * 31 + Kotlin.hashCode(this.name) | 0;
    result = result * 31 + Kotlin.hashCode(this.parameters) | 0;
    return result;
  };
  KtAnnotation.prototype.equals = function (other) {
    return this === other || (other !== null && (typeof other === 'object' && (Object.getPrototypeOf(this) === Object.getPrototypeOf(other) && (Kotlin.equals(this.name, other.name) && Kotlin.equals(this.parameters, other.parameters)))));
  };
  function KtClassKind(name, ordinal, keyword, bracesAlwaysRequired) {
    if (bracesAlwaysRequired === void 0)
      bracesAlwaysRequired = false;
    Enum.call(this);
    this.keyword = keyword;
    this.bracesAlwaysRequired = bracesAlwaysRequired;
    this.name$ = name;
    this.ordinal$ = ordinal;
  }
  function KtClassKind_initFields() {
    KtClassKind_initFields = function () {
    };
    KtClassKind$CLASS_instance = new KtClassKind('CLASS', 0, 'class');
    KtClassKind$INTERFACE_instance = new KtClassKind('INTERFACE', 1, 'interface');
    KtClassKind$ENUM_instance = new KtClassKind('ENUM', 2, 'enum class');
    KtClassKind$OBJECT_instance = new KtClassKind('OBJECT', 3, 'object', true);
    KtClassKind$COMPANION_OBJECT_instance = new KtClassKind('COMPANION_OBJECT', 4, 'companion object', true);
  }
  var KtClassKind$CLASS_instance;
  function KtClassKind$CLASS_getInstance() {
    KtClassKind_initFields();
    return KtClassKind$CLASS_instance;
  }
  var KtClassKind$INTERFACE_instance;
  function KtClassKind$INTERFACE_getInstance() {
    KtClassKind_initFields();
    return KtClassKind$INTERFACE_instance;
  }
  var KtClassKind$ENUM_instance;
  function KtClassKind$ENUM_getInstance() {
    KtClassKind_initFields();
    return KtClassKind$ENUM_instance;
  }
  var KtClassKind$OBJECT_instance;
  function KtClassKind$OBJECT_getInstance() {
    KtClassKind_initFields();
    return KtClassKind$OBJECT_instance;
  }
  var KtClassKind$COMPANION_OBJECT_instance;
  function KtClassKind$COMPANION_OBJECT_getInstance() {
    KtClassKind_initFields();
    return KtClassKind$COMPANION_OBJECT_instance;
  }
  KtClassKind.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'KtClassKind',
    interfaces: [Enum]
  };
  function KtClassKind$values() {
    return [KtClassKind$CLASS_getInstance(), KtClassKind$INTERFACE_getInstance(), KtClassKind$ENUM_getInstance(), KtClassKind$OBJECT_getInstance(), KtClassKind$COMPANION_OBJECT_getInstance()];
  }
  KtClassKind.values = KtClassKind$values;
  function KtClassKind$valueOf(name) {
    switch (name) {
      case 'CLASS':
        return KtClassKind$CLASS_getInstance();
      case 'INTERFACE':
        return KtClassKind$INTERFACE_getInstance();
      case 'ENUM':
        return KtClassKind$ENUM_getInstance();
      case 'OBJECT':
        return KtClassKind$OBJECT_getInstance();
      case 'COMPANION_OBJECT':
        return KtClassKind$COMPANION_OBJECT_getInstance();
      default:throwISE('No enum constant ts2kt.kotlin.ast.KtClassKind.' + name);
    }
  }
  KtClassKind.valueOf_61zpoe$ = KtClassKind$valueOf;
  function KtClassifier(kind, name, paramsOfConstructors, typeParams, parents, members, annotations, hasOpenModifier) {
    AbstractKtNode.call(this);
    this.kind = kind;
    this.name_mzeu42$_0 = name;
    this.paramsOfConstructors = paramsOfConstructors;
    this.typeParams = typeParams;
    this.parents = parents;
    this.members_1k2q2q$_0 = members;
    this.annotations_fa0uct$_0 = annotations;
    this.hasOpenModifier = hasOpenModifier;
  }
  Object.defineProperty(KtClassifier.prototype, 'name', {
    get: function () {
      return this.name_mzeu42$_0;
    },
    set: function (name) {
      this.name_mzeu42$_0 = name;
    }
  });
  Object.defineProperty(KtClassifier.prototype, 'members', {
    get: function () {
      return this.members_1k2q2q$_0;
    },
    set: function (members) {
      this.members_1k2q2q$_0 = members;
    }
  });
  Object.defineProperty(KtClassifier.prototype, 'annotations', {
    get: function () {
      return this.annotations_fa0uct$_0;
    },
    set: function (annotations) {
      this.annotations_fa0uct$_0 = annotations;
    }
  });
  KtClassifier.prototype.accept_nbqbgi$ = function (visitor) {
    visitor.visitClassifier_k8ctg1$(this);
  };
  KtClassifier.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'KtClassifier',
    interfaces: [KtWithMembers, AbstractKtNode, KtMember]
  };
  KtClassifier.prototype.component1 = function () {
    return this.kind;
  };
  KtClassifier.prototype.component2 = function () {
    return this.name;
  };
  KtClassifier.prototype.component3 = function () {
    return this.paramsOfConstructors;
  };
  KtClassifier.prototype.component4 = function () {
    return this.typeParams;
  };
  KtClassifier.prototype.component5 = function () {
    return this.parents;
  };
  KtClassifier.prototype.component6 = function () {
    return this.members;
  };
  KtClassifier.prototype.component7 = function () {
    return this.annotations;
  };
  KtClassifier.prototype.component8 = function () {
    return this.hasOpenModifier;
  };
  KtClassifier.prototype.copy_xb7jjy$ = function (kind, name, paramsOfConstructors, typeParams, parents, members, annotations, hasOpenModifier) {
    return new KtClassifier(kind === void 0 ? this.kind : kind, name === void 0 ? this.name : name, paramsOfConstructors === void 0 ? this.paramsOfConstructors : paramsOfConstructors, typeParams === void 0 ? this.typeParams : typeParams, parents === void 0 ? this.parents : parents, members === void 0 ? this.members : members, annotations === void 0 ? this.annotations : annotations, hasOpenModifier === void 0 ? this.hasOpenModifier : hasOpenModifier);
  };
  KtClassifier.prototype.toString = function () {
    return 'KtClassifier(kind=' + Kotlin.toString(this.kind) + (', name=' + Kotlin.toString(this.name)) + (', paramsOfConstructors=' + Kotlin.toString(this.paramsOfConstructors)) + (', typeParams=' + Kotlin.toString(this.typeParams)) + (', parents=' + Kotlin.toString(this.parents)) + (', members=' + Kotlin.toString(this.members)) + (', annotations=' + Kotlin.toString(this.annotations)) + (', hasOpenModifier=' + Kotlin.toString(this.hasOpenModifier)) + ')';
  };
  KtClassifier.prototype.hashCode = function () {
    var result = 0;
    result = result * 31 + Kotlin.hashCode(this.kind) | 0;
    result = result * 31 + Kotlin.hashCode(this.name) | 0;
    result = result * 31 + Kotlin.hashCode(this.paramsOfConstructors) | 0;
    result = result * 31 + Kotlin.hashCode(this.typeParams) | 0;
    result = result * 31 + Kotlin.hashCode(this.parents) | 0;
    result = result * 31 + Kotlin.hashCode(this.members) | 0;
    result = result * 31 + Kotlin.hashCode(this.annotations) | 0;
    result = result * 31 + Kotlin.hashCode(this.hasOpenModifier) | 0;
    return result;
  };
  KtClassifier.prototype.equals = function (other) {
    return this === other || (other !== null && (typeof other === 'object' && (Object.getPrototypeOf(this) === Object.getPrototypeOf(other) && (Kotlin.equals(this.kind, other.kind) && Kotlin.equals(this.name, other.name) && Kotlin.equals(this.paramsOfConstructors, other.paramsOfConstructors) && Kotlin.equals(this.typeParams, other.typeParams) && Kotlin.equals(this.parents, other.parents) && Kotlin.equals(this.members, other.members) && Kotlin.equals(this.annotations, other.annotations) && Kotlin.equals(this.hasOpenModifier, other.hasOpenModifier)))));
  };
  function KtFunParam(name, type, defaultValue, isVar) {
    if (defaultValue === void 0)
      defaultValue = null;
    if (isVar === void 0)
      isVar = false;
    AbstractKtNode.call(this);
    this.name_3amaw1$_0 = name;
    this.type = type;
    this.defaultValue = defaultValue;
    this.isVar = isVar;
  }
  Object.defineProperty(KtFunParam.prototype, 'name', {
    get: function () {
      return this.name_3amaw1$_0;
    },
    set: function (name) {
      this.name_3amaw1$_0 = name;
    }
  });
  KtFunParam.prototype.accept_nbqbgi$ = function (visitor) {
    visitor.visitFunParam_ggmbia$(this);
  };
  KtFunParam.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'KtFunParam',
    interfaces: [AbstractKtNode, KtNamed]
  };
  KtFunParam.prototype.component1 = function () {
    return this.name;
  };
  KtFunParam.prototype.component2 = function () {
    return this.type;
  };
  KtFunParam.prototype.component3 = function () {
    return this.defaultValue;
  };
  KtFunParam.prototype.component4 = function () {
    return this.isVar;
  };
  KtFunParam.prototype.copy_wii1xx$ = function (name, type, defaultValue, isVar) {
    return new KtFunParam(name === void 0 ? this.name : name, type === void 0 ? this.type : type, defaultValue === void 0 ? this.defaultValue : defaultValue, isVar === void 0 ? this.isVar : isVar);
  };
  KtFunParam.prototype.toString = function () {
    return 'KtFunParam(name=' + Kotlin.toString(this.name) + (', type=' + Kotlin.toString(this.type)) + (', defaultValue=' + Kotlin.toString(this.defaultValue)) + (', isVar=' + Kotlin.toString(this.isVar)) + ')';
  };
  KtFunParam.prototype.hashCode = function () {
    var result = 0;
    result = result * 31 + Kotlin.hashCode(this.name) | 0;
    result = result * 31 + Kotlin.hashCode(this.type) | 0;
    result = result * 31 + Kotlin.hashCode(this.defaultValue) | 0;
    result = result * 31 + Kotlin.hashCode(this.isVar) | 0;
    return result;
  };
  KtFunParam.prototype.equals = function (other) {
    return this === other || (other !== null && (typeof other === 'object' && (Object.getPrototypeOf(this) === Object.getPrototypeOf(other) && (Kotlin.equals(this.name, other.name) && Kotlin.equals(this.type, other.type) && Kotlin.equals(this.defaultValue, other.defaultValue) && Kotlin.equals(this.isVar, other.isVar)))));
  };
  function KtCallSignature(params, typeParams, returnType) {
    AbstractKtNode.call(this);
    this.params = params;
    this.typeParams = typeParams;
    this.returnType = returnType;
  }
  KtCallSignature.prototype.accept_nbqbgi$ = function (visitor) {
    visitor.visitCallSignature_qsdh4m$(this);
  };
  KtCallSignature.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'KtCallSignature',
    interfaces: [AbstractKtNode]
  };
  KtCallSignature.prototype.component1 = function () {
    return this.params;
  };
  KtCallSignature.prototype.component2 = function () {
    return this.typeParams;
  };
  KtCallSignature.prototype.component3 = function () {
    return this.returnType;
  };
  KtCallSignature.prototype.copy_sl5de3$ = function (params, typeParams, returnType) {
    return new KtCallSignature(params === void 0 ? this.params : params, typeParams === void 0 ? this.typeParams : typeParams, returnType === void 0 ? this.returnType : returnType);
  };
  KtCallSignature.prototype.toString = function () {
    return 'KtCallSignature(params=' + Kotlin.toString(this.params) + (', typeParams=' + Kotlin.toString(this.typeParams)) + (', returnType=' + Kotlin.toString(this.returnType)) + ')';
  };
  KtCallSignature.prototype.hashCode = function () {
    var result = 0;
    result = result * 31 + Kotlin.hashCode(this.params) | 0;
    result = result * 31 + Kotlin.hashCode(this.typeParams) | 0;
    result = result * 31 + Kotlin.hashCode(this.returnType) | 0;
    return result;
  };
  KtCallSignature.prototype.equals = function (other) {
    return this === other || (other !== null && (typeof other === 'object' && (Object.getPrototypeOf(this) === Object.getPrototypeOf(other) && (Kotlin.equals(this.params, other.params) && Kotlin.equals(this.typeParams, other.typeParams) && Kotlin.equals(this.returnType, other.returnType)))));
  };
  function KtFunction(name, callSignature, extendsType, annotations, needsNoImpl, isOverride, hasOpenModifier, isOperator) {
    if (extendsType === void 0)
      extendsType = null;
    if (annotations === void 0)
      annotations = emptyList();
    if (needsNoImpl === void 0)
      needsNoImpl = true;
    if (isOverride === void 0)
      isOverride = false;
    if (hasOpenModifier === void 0)
      hasOpenModifier = false;
    if (isOperator === void 0)
      isOperator = false;
    AbstractKtNode.call(this);
    this.name_dhvs0n$_0 = name;
    this.callSignature = callSignature;
    this.extendsType = extendsType;
    this.annotations_esie4c$_0 = annotations;
    this.needsNoImpl = needsNoImpl;
    this.isOverride = isOverride;
    this.hasOpenModifier = hasOpenModifier;
    this.isOperator = isOperator;
  }
  Object.defineProperty(KtFunction.prototype, 'name', {
    get: function () {
      return this.name_dhvs0n$_0;
    },
    set: function (name) {
      this.name_dhvs0n$_0 = name;
    }
  });
  Object.defineProperty(KtFunction.prototype, 'annotations', {
    get: function () {
      return this.annotations_esie4c$_0;
    },
    set: function (annotations) {
      this.annotations_esie4c$_0 = annotations;
    }
  });
  KtFunction.prototype.accept_nbqbgi$ = function (visitor) {
    visitor.visitFunction_g5u9tk$(this);
  };
  KtFunction.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'KtFunction',
    interfaces: [AbstractKtNode, KtMember]
  };
  KtFunction.prototype.component1 = function () {
    return this.name;
  };
  KtFunction.prototype.component2 = function () {
    return this.callSignature;
  };
  KtFunction.prototype.component3 = function () {
    return this.extendsType;
  };
  KtFunction.prototype.component4 = function () {
    return this.annotations;
  };
  KtFunction.prototype.component5 = function () {
    return this.needsNoImpl;
  };
  KtFunction.prototype.component6 = function () {
    return this.isOverride;
  };
  KtFunction.prototype.component7 = function () {
    return this.hasOpenModifier;
  };
  KtFunction.prototype.component8 = function () {
    return this.isOperator;
  };
  KtFunction.prototype.copy_3m4w0d$ = function (name, callSignature, extendsType, annotations, needsNoImpl, isOverride, hasOpenModifier, isOperator) {
    return new KtFunction(name === void 0 ? this.name : name, callSignature === void 0 ? this.callSignature : callSignature, extendsType === void 0 ? this.extendsType : extendsType, annotations === void 0 ? this.annotations : annotations, needsNoImpl === void 0 ? this.needsNoImpl : needsNoImpl, isOverride === void 0 ? this.isOverride : isOverride, hasOpenModifier === void 0 ? this.hasOpenModifier : hasOpenModifier, isOperator === void 0 ? this.isOperator : isOperator);
  };
  KtFunction.prototype.toString = function () {
    return 'KtFunction(name=' + Kotlin.toString(this.name) + (', callSignature=' + Kotlin.toString(this.callSignature)) + (', extendsType=' + Kotlin.toString(this.extendsType)) + (', annotations=' + Kotlin.toString(this.annotations)) + (', needsNoImpl=' + Kotlin.toString(this.needsNoImpl)) + (', isOverride=' + Kotlin.toString(this.isOverride)) + (', hasOpenModifier=' + Kotlin.toString(this.hasOpenModifier)) + (', isOperator=' + Kotlin.toString(this.isOperator)) + ')';
  };
  KtFunction.prototype.hashCode = function () {
    var result = 0;
    result = result * 31 + Kotlin.hashCode(this.name) | 0;
    result = result * 31 + Kotlin.hashCode(this.callSignature) | 0;
    result = result * 31 + Kotlin.hashCode(this.extendsType) | 0;
    result = result * 31 + Kotlin.hashCode(this.annotations) | 0;
    result = result * 31 + Kotlin.hashCode(this.needsNoImpl) | 0;
    result = result * 31 + Kotlin.hashCode(this.isOverride) | 0;
    result = result * 31 + Kotlin.hashCode(this.hasOpenModifier) | 0;
    result = result * 31 + Kotlin.hashCode(this.isOperator) | 0;
    return result;
  };
  KtFunction.prototype.equals = function (other) {
    return this === other || (other !== null && (typeof other === 'object' && (Object.getPrototypeOf(this) === Object.getPrototypeOf(other) && (Kotlin.equals(this.name, other.name) && Kotlin.equals(this.callSignature, other.callSignature) && Kotlin.equals(this.extendsType, other.extendsType) && Kotlin.equals(this.annotations, other.annotations) && Kotlin.equals(this.needsNoImpl, other.needsNoImpl) && Kotlin.equals(this.isOverride, other.isOverride) && Kotlin.equals(this.hasOpenModifier, other.hasOpenModifier) && Kotlin.equals(this.isOperator, other.isOperator)))));
  };
  function KtVariable(name, type, extendsType, annotations, typeParams, isVar, needsNoImpl, isInInterface, isOverride, hasOpenModifier) {
    if (extendsType === void 0)
      extendsType = null;
    if (needsNoImpl === void 0)
      needsNoImpl = true;
    if (isOverride === void 0)
      isOverride = false;
    AbstractKtNode.call(this);
    this.name_pibwtv$_0 = name;
    this.type = type;
    this.extendsType = extendsType;
    this.annotations_ufbf3c$_0 = annotations;
    this.typeParams = typeParams;
    this.isVar = isVar;
    this.needsNoImpl = needsNoImpl;
    this.isInInterface = isInInterface;
    this.isOverride = isOverride;
    this.hasOpenModifier = hasOpenModifier;
  }
  Object.defineProperty(KtVariable.prototype, 'name', {
    get: function () {
      return this.name_pibwtv$_0;
    },
    set: function (name) {
      this.name_pibwtv$_0 = name;
    }
  });
  Object.defineProperty(KtVariable.prototype, 'annotations', {
    get: function () {
      return this.annotations_ufbf3c$_0;
    },
    set: function (annotations) {
      this.annotations_ufbf3c$_0 = annotations;
    }
  });
  KtVariable.prototype.accept_nbqbgi$ = function (visitor) {
    visitor.visitVariable_bd4hv0$(this);
  };
  KtVariable.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'KtVariable',
    interfaces: [AbstractKtNode, KtMember]
  };
  KtVariable.prototype.component1 = function () {
    return this.name;
  };
  KtVariable.prototype.component2 = function () {
    return this.type;
  };
  KtVariable.prototype.component3 = function () {
    return this.extendsType;
  };
  KtVariable.prototype.component4 = function () {
    return this.annotations;
  };
  KtVariable.prototype.component5 = function () {
    return this.typeParams;
  };
  KtVariable.prototype.component6 = function () {
    return this.isVar;
  };
  KtVariable.prototype.component7 = function () {
    return this.needsNoImpl;
  };
  KtVariable.prototype.component8 = function () {
    return this.isInInterface;
  };
  KtVariable.prototype.component9 = function () {
    return this.isOverride;
  };
  KtVariable.prototype.component10 = function () {
    return this.hasOpenModifier;
  };
  KtVariable.prototype.copy_cpuxes$ = function (name, type, extendsType, annotations, typeParams, isVar, needsNoImpl, isInInterface, isOverride, hasOpenModifier) {
    return new KtVariable(name === void 0 ? this.name : name, type === void 0 ? this.type : type, extendsType === void 0 ? this.extendsType : extendsType, annotations === void 0 ? this.annotations : annotations, typeParams === void 0 ? this.typeParams : typeParams, isVar === void 0 ? this.isVar : isVar, needsNoImpl === void 0 ? this.needsNoImpl : needsNoImpl, isInInterface === void 0 ? this.isInInterface : isInInterface, isOverride === void 0 ? this.isOverride : isOverride, hasOpenModifier === void 0 ? this.hasOpenModifier : hasOpenModifier);
  };
  KtVariable.prototype.toString = function () {
    return 'KtVariable(name=' + Kotlin.toString(this.name) + (', type=' + Kotlin.toString(this.type)) + (', extendsType=' + Kotlin.toString(this.extendsType)) + (', annotations=' + Kotlin.toString(this.annotations)) + (', typeParams=' + Kotlin.toString(this.typeParams)) + (', isVar=' + Kotlin.toString(this.isVar)) + (', needsNoImpl=' + Kotlin.toString(this.needsNoImpl)) + (', isInInterface=' + Kotlin.toString(this.isInInterface)) + (', isOverride=' + Kotlin.toString(this.isOverride)) + (', hasOpenModifier=' + Kotlin.toString(this.hasOpenModifier)) + ')';
  };
  KtVariable.prototype.hashCode = function () {
    var result = 0;
    result = result * 31 + Kotlin.hashCode(this.name) | 0;
    result = result * 31 + Kotlin.hashCode(this.type) | 0;
    result = result * 31 + Kotlin.hashCode(this.extendsType) | 0;
    result = result * 31 + Kotlin.hashCode(this.annotations) | 0;
    result = result * 31 + Kotlin.hashCode(this.typeParams) | 0;
    result = result * 31 + Kotlin.hashCode(this.isVar) | 0;
    result = result * 31 + Kotlin.hashCode(this.needsNoImpl) | 0;
    result = result * 31 + Kotlin.hashCode(this.isInInterface) | 0;
    result = result * 31 + Kotlin.hashCode(this.isOverride) | 0;
    result = result * 31 + Kotlin.hashCode(this.hasOpenModifier) | 0;
    return result;
  };
  KtVariable.prototype.equals = function (other) {
    return this === other || (other !== null && (typeof other === 'object' && (Object.getPrototypeOf(this) === Object.getPrototypeOf(other) && (Kotlin.equals(this.name, other.name) && Kotlin.equals(this.type, other.type) && Kotlin.equals(this.extendsType, other.extendsType) && Kotlin.equals(this.annotations, other.annotations) && Kotlin.equals(this.typeParams, other.typeParams) && Kotlin.equals(this.isVar, other.isVar) && Kotlin.equals(this.needsNoImpl, other.needsNoImpl) && Kotlin.equals(this.isInInterface, other.isInInterface) && Kotlin.equals(this.isOverride, other.isOverride) && Kotlin.equals(this.hasOpenModifier, other.hasOpenModifier)))));
  };
  function KtEnumEntry(name, value) {
    if (value === void 0)
      value = null;
    AbstractKtNode.call(this);
    this.name_urqkte$_0 = name;
    this.value = value;
    this.annotations_y3anq5$_0 = emptyList();
  }
  Object.defineProperty(KtEnumEntry.prototype, 'name', {
    get: function () {
      return this.name_urqkte$_0;
    },
    set: function (name) {
      this.name_urqkte$_0 = name;
    }
  });
  Object.defineProperty(KtEnumEntry.prototype, 'annotations', {
    get: function () {
      return this.annotations_y3anq5$_0;
    },
    set: function (annotations) {
      this.annotations_y3anq5$_0 = annotations;
    }
  });
  KtEnumEntry.prototype.accept_nbqbgi$ = function (visitor) {
    visitor.visitEnumEntry_241v5t$(this);
  };
  KtEnumEntry.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'KtEnumEntry',
    interfaces: [AbstractKtNode, KtMember]
  };
  KtEnumEntry.prototype.component1 = function () {
    return this.name;
  };
  KtEnumEntry.prototype.component2 = function () {
    return this.value;
  };
  KtEnumEntry.prototype.copy_m1kk8e$ = function (name, value) {
    return new KtEnumEntry(name === void 0 ? this.name : name, value === void 0 ? this.value : value);
  };
  KtEnumEntry.prototype.toString = function () {
    return 'KtEnumEntry(name=' + Kotlin.toString(this.name) + (', value=' + Kotlin.toString(this.value)) + ')';
  };
  KtEnumEntry.prototype.hashCode = function () {
    var result = 0;
    result = result * 31 + Kotlin.hashCode(this.name) | 0;
    result = result * 31 + Kotlin.hashCode(this.value) | 0;
    return result;
  };
  KtEnumEntry.prototype.equals = function (other) {
    return this === other || (other !== null && (typeof other === 'object' && (Object.getPrototypeOf(this) === Object.getPrototypeOf(other) && (Kotlin.equals(this.name, other.name) && Kotlin.equals(this.value, other.value)))));
  };
  function KtHeritageType(type, byExpression) {
    if (byExpression === void 0)
      byExpression = null;
    AbstractKtNode.call(this);
    this.type = type;
    this.byExpression = byExpression;
  }
  KtHeritageType.prototype.accept_nbqbgi$ = function (visitor) {
    visitor.visitHeritageType_dup87$(this);
  };
  KtHeritageType.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'KtHeritageType',
    interfaces: [AbstractKtNode]
  };
  KtHeritageType.prototype.component1 = function () {
    return this.type;
  };
  KtHeritageType.prototype.component2 = function () {
    return this.byExpression;
  };
  KtHeritageType.prototype.copy_89ixvh$ = function (type, byExpression) {
    return new KtHeritageType(type === void 0 ? this.type : type, byExpression === void 0 ? this.byExpression : byExpression);
  };
  KtHeritageType.prototype.toString = function () {
    return 'KtHeritageType(type=' + Kotlin.toString(this.type) + (', byExpression=' + Kotlin.toString(this.byExpression)) + ')';
  };
  KtHeritageType.prototype.hashCode = function () {
    var result = 0;
    result = result * 31 + Kotlin.hashCode(this.type) | 0;
    result = result * 31 + Kotlin.hashCode(this.byExpression) | 0;
    return result;
  };
  KtHeritageType.prototype.equals = function (other) {
    return this === other || (other !== null && (typeof other === 'object' && (Object.getPrototypeOf(this) === Object.getPrototypeOf(other) && (Kotlin.equals(this.type, other.type) && Kotlin.equals(this.byExpression, other.byExpression)))));
  };
  function KtTypeUnion(possibleTypes) {
    return new KtTypeUnion_0(toList(possibleTypes));
  }
  function KtTypeUnion_0(possibleTypes) {
    AbstractKtNode.call(this);
    this.possibleTypes = possibleTypes;
    var tmp$;
    if (this.possibleTypes.size === 1)
      tmp$ = single(this.possibleTypes);
    else {
      tmp$ = new KtType(DYNAMIC, void 0, stringify(this), first(this.possibleTypes).isNullable);
    }
    this.singleType = tmp$;
  }
  KtTypeUnion_0.prototype.accept_nbqbgi$ = function (visitor) {
    visitor.visitTypeUnion_6y0zwl$(this);
  };
  KtTypeUnion_0.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'KtTypeUnion',
    interfaces: [AbstractKtNode]
  };
  KtTypeUnion_0.prototype.component1 = function () {
    return this.possibleTypes;
  };
  KtTypeUnion_0.prototype.copy_uevjwn$ = function (possibleTypes) {
    return new KtTypeUnion_0(possibleTypes === void 0 ? this.possibleTypes : possibleTypes);
  };
  KtTypeUnion_0.prototype.toString = function () {
    return 'KtTypeUnion(possibleTypes=' + Kotlin.toString(this.possibleTypes) + ')';
  };
  KtTypeUnion_0.prototype.hashCode = function () {
    var result = 0;
    result = result * 31 + Kotlin.hashCode(this.possibleTypes) | 0;
    return result;
  };
  KtTypeUnion_0.prototype.equals = function (other) {
    return this === other || (other !== null && (typeof other === 'object' && (Object.getPrototypeOf(this) === Object.getPrototypeOf(other) && Kotlin.equals(this.possibleTypes, other.possibleTypes))));
  };
  function KtType(qualifiedName, typeArgs, comment, isNullable, callSignature) {
    if (typeArgs === void 0)
      typeArgs = emptyList();
    if (comment === void 0)
      comment = null;
    if (isNullable === void 0)
      isNullable = false;
    if (callSignature === void 0)
      callSignature = null;
    AbstractKtNode.call(this);
    this.qualifiedName = qualifiedName;
    this.typeArgs = typeArgs;
    this.comment = comment;
    this.isNullable = isNullable;
    this.callSignature = callSignature;
  }
  KtType.prototype.accept_nbqbgi$ = function (visitor) {
    visitor.visitType_yasija$(this);
  };
  Object.defineProperty(KtType.prototype, 'isLambda', {
    get: function () {
      return this.callSignature != null;
    }
  });
  KtType.prototype.isUnit = function () {
    var tmp$;
    return ((tmp$ = this.qualifiedName) != null ? tmp$.equals(UNIT) : null) && !this.isNullable && !this.isLambda;
  };
  KtType.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'KtType',
    interfaces: [AbstractKtNode]
  };
  KtType.prototype.component1 = function () {
    return this.qualifiedName;
  };
  KtType.prototype.component2 = function () {
    return this.typeArgs;
  };
  KtType.prototype.component3 = function () {
    return this.comment;
  };
  KtType.prototype.component4 = function () {
    return this.isNullable;
  };
  KtType.prototype.component5 = function () {
    return this.callSignature;
  };
  KtType.prototype.copy_wau779$ = function (qualifiedName, typeArgs, comment, isNullable, callSignature) {
    return new KtType(qualifiedName === void 0 ? this.qualifiedName : qualifiedName, typeArgs === void 0 ? this.typeArgs : typeArgs, comment === void 0 ? this.comment : comment, isNullable === void 0 ? this.isNullable : isNullable, callSignature === void 0 ? this.callSignature : callSignature);
  };
  KtType.prototype.toString = function () {
    return 'KtType(qualifiedName=' + Kotlin.toString(this.qualifiedName) + (', typeArgs=' + Kotlin.toString(this.typeArgs)) + (', comment=' + Kotlin.toString(this.comment)) + (', isNullable=' + Kotlin.toString(this.isNullable)) + (', callSignature=' + Kotlin.toString(this.callSignature)) + ')';
  };
  KtType.prototype.hashCode = function () {
    var result = 0;
    result = result * 31 + Kotlin.hashCode(this.qualifiedName) | 0;
    result = result * 31 + Kotlin.hashCode(this.typeArgs) | 0;
    result = result * 31 + Kotlin.hashCode(this.comment) | 0;
    result = result * 31 + Kotlin.hashCode(this.isNullable) | 0;
    result = result * 31 + Kotlin.hashCode(this.callSignature) | 0;
    return result;
  };
  KtType.prototype.equals = function (other) {
    return this === other || (other !== null && (typeof other === 'object' && (Object.getPrototypeOf(this) === Object.getPrototypeOf(other) && (Kotlin.equals(this.qualifiedName, other.qualifiedName) && Kotlin.equals(this.typeArgs, other.typeArgs) && Kotlin.equals(this.comment, other.comment) && Kotlin.equals(this.isNullable, other.isNullable) && Kotlin.equals(this.callSignature, other.callSignature)))));
  };
  function starType() {
    return new KtType(KtQualifiedName_init('*'));
  }
  function KtTypeParam(name, upperBound) {
    if (upperBound === void 0)
      upperBound = null;
    AbstractKtNode.call(this);
    this.name_2ryplo$_0 = name;
    this.upperBound = upperBound;
  }
  Object.defineProperty(KtTypeParam.prototype, 'name', {
    get: function () {
      return this.name_2ryplo$_0;
    },
    set: function (name) {
      this.name_2ryplo$_0 = name;
    }
  });
  KtTypeParam.prototype.accept_nbqbgi$ = function (visitor) {
    visitor.visitTypeParam_6v1wg3$(this);
  };
  KtTypeParam.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'KtTypeParam',
    interfaces: [AbstractKtNode, KtNamed]
  };
  KtTypeParam.prototype.component1 = function () {
    return this.name;
  };
  KtTypeParam.prototype.component2 = function () {
    return this.upperBound;
  };
  KtTypeParam.prototype.copy_g617e$ = function (name, upperBound) {
    return new KtTypeParam(name === void 0 ? this.name : name, upperBound === void 0 ? this.upperBound : upperBound);
  };
  KtTypeParam.prototype.toString = function () {
    return 'KtTypeParam(name=' + Kotlin.toString(this.name) + (', upperBound=' + Kotlin.toString(this.upperBound)) + ')';
  };
  KtTypeParam.prototype.hashCode = function () {
    var result = 0;
    result = result * 31 + Kotlin.hashCode(this.name) | 0;
    result = result * 31 + Kotlin.hashCode(this.upperBound) | 0;
    return result;
  };
  KtTypeParam.prototype.equals = function (other) {
    return this === other || (other !== null && (typeof other === 'object' && (Object.getPrototypeOf(this) === Object.getPrototypeOf(other) && (Kotlin.equals(this.name, other.name) && Kotlin.equals(this.upperBound, other.upperBound)))));
  };
  function KtTypeAnnotation(type, isVararg) {
    if (isVararg === void 0)
      isVararg = false;
    AbstractKtNode.call(this);
    this.type = type;
    this.isVararg = isVararg;
  }
  KtTypeAnnotation.prototype.accept_nbqbgi$ = function (visitor) {
    visitor.visitTypeAnnotation_ryuo7b$(this);
  };
  KtTypeAnnotation.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'KtTypeAnnotation',
    interfaces: [AbstractKtNode]
  };
  KtTypeAnnotation.prototype.component1 = function () {
    return this.type;
  };
  KtTypeAnnotation.prototype.component2 = function () {
    return this.isVararg;
  };
  KtTypeAnnotation.prototype.copy_nxconx$ = function (type, isVararg) {
    return new KtTypeAnnotation(type === void 0 ? this.type : type, isVararg === void 0 ? this.isVararg : isVararg);
  };
  KtTypeAnnotation.prototype.toString = function () {
    return 'KtTypeAnnotation(type=' + Kotlin.toString(this.type) + (', isVararg=' + Kotlin.toString(this.isVararg)) + ')';
  };
  KtTypeAnnotation.prototype.hashCode = function () {
    var result = 0;
    result = result * 31 + Kotlin.hashCode(this.type) | 0;
    result = result * 31 + Kotlin.hashCode(this.isVararg) | 0;
    return result;
  };
  KtTypeAnnotation.prototype.equals = function (other) {
    return this === other || (other !== null && (typeof other === 'object' && (Object.getPrototypeOf(this) === Object.getPrototypeOf(other) && (Kotlin.equals(this.type, other.type) && Kotlin.equals(this.isVararg, other.isVararg)))));
  };
  function stringify($receiver) {
    return stringify_0($receiver, null, false);
  }
  function stringify_0($receiver, packagePartPrefix, topLevel, additionalImports, suppressedDiagnostics) {
    if (topLevel === void 0)
      topLevel = true;
    if (additionalImports === void 0) {
      additionalImports = emptyList();
    }
    if (suppressedDiagnostics === void 0) {
      suppressedDiagnostics = emptyList();
    }
    var $receiver_0 = new Stringify(packagePartPrefix, topLevel, additionalImports, suppressedDiagnostics);
    $receiver.accept_nbqbgi$($receiver_0);
    return $receiver_0.result;
  }
  function getFirstParamAsString($receiver) {
    var tmp$;
    if ($receiver.parameters.isEmpty())
      return null;
    var annotationParam = typeof (tmp$ = $receiver.parameters.get_za3lpa$(0).value) === 'string' ? tmp$ : throwCCE();
    var endIndex = annotationParam.length - 1 | 0;
    return annotationParam.substring(1, endIndex);
  }
  function isModule($receiver) {
    return $receiver.kind === KtClassKind$OBJECT_getInstance() && hasModuleAnnotation($receiver);
  }
  var Collection = Kotlin.kotlin.collections.Collection;
  function hasModuleAnnotation($receiver) {
    var $receiver_0 = $receiver.annotations;
    var any$result;
    any$break: do {
      var tmp$;
      if (Kotlin.isType($receiver_0, Collection) && $receiver_0.isEmpty()) {
        any$result = false;
        break any$break;
      }
      tmp$ = $receiver_0.iterator();
      while (tmp$.hasNext()) {
        var element = tmp$.next();
        var tmp$_0;
        if ((tmp$_0 = element.name) != null ? tmp$_0.equals(MODULE) : null) {
          any$result = true;
          break any$break;
        }
      }
      any$result = false;
    }
     while (false);
    return any$result;
  }
  function getClassObject($receiver) {
    var tmp$;
    var $receiver_0 = $receiver.members;
    var firstOrNull$result;
    firstOrNull$break: do {
      var tmp$_0;
      tmp$_0 = $receiver_0.iterator();
      while (tmp$_0.hasNext()) {
        var element = tmp$_0.next();
        if (Kotlin.isType(element, KtClassifier) && element.kind === KtClassKind$COMPANION_OBJECT_getInstance()) {
          firstOrNull$result = element;
          break firstOrNull$break;
        }
      }
      firstOrNull$result = null;
    }
     while (false);
    return Kotlin.isType(tmp$ = firstOrNull$result, KtClassifier) ? tmp$ : null;
  }
  function createFunctionType(parameters, returnType, isNullable) {
    if (isNullable === void 0)
      isNullable = false;
    return new KtType(KtQualifiedName_init('Function'), void 0, void 0, isNullable, new KtCallSignature(parameters, null, new KtTypeAnnotation(returnType)));
  }
  function Visitor() {
  }
  Visitor.prototype.visitModuleDeclaration_ezg4eu$ = function (node) {
    reportUnsupportedNode(node);
  };
  Visitor.prototype.visitFunctionDeclaration_eywj3y$ = function (node) {
    reportUnsupportedNode(node);
  };
  Visitor.prototype.visitTypeAliasDeclaration_it7xrc$ = function (node) {
    reportUnsupportedNode(node);
  };
  Visitor.prototype.visitVariableStatement_x0poxd$ = function (node) {
    reportUnsupportedNode(node);
  };
  Visitor.prototype.visitEnumDeclaration_1emvp1$ = function (node) {
    reportUnsupportedNode(node);
  };
  Visitor.prototype.visitClassDeclaration_4wvyue$ = function (node) {
    reportUnsupportedNode(node);
  };
  Visitor.prototype.visitInterfaceDeclaration_f4u3$ = function (node) {
    reportUnsupportedNode(node);
  };
  Visitor.prototype.visitHeritageClause_10qtta$ = function (node) {
    reportUnsupportedNode(node);
  };
  Visitor.prototype.visitConstructorDeclaration_cz84f8$ = function (node) {
    reportUnsupportedNode(node);
  };
  Visitor.prototype.visitConstructSignatureDeclaration_cz84f8$ = function (node) {
    reportUnsupportedNode(node);
  };
  Visitor.prototype.visitMethodDeclaration_7vsj57$ = function (node) {
    reportUnsupportedNode(node);
  };
  Visitor.prototype.visitPropertyDeclaration_qnxew1$ = function (node) {
    reportUnsupportedNode(node);
  };
  Visitor.prototype.visitIndexSignature_53if9s$ = function (node) {
    reportUnsupportedNode(node);
  };
  Visitor.prototype.visitSignatureDeclaration_vb212e$ = function (node) {
    reportUnsupportedNode(node);
  };
  Visitor.prototype.visitExportAssignment_fybyfv$ = function (node) {
    reportUnsupportedNode(node);
  };
  Visitor.prototype.visitImportEqualsDeclaration_p9svv6$ = function (node) {
    reportUnsupportedNode(node);
  };
  Visitor.$metadata$ = {
    kind: Kind_INTERFACE,
    simpleName: 'Visitor',
    interfaces: []
  };
  var unsupported = defineInlineFunction('ts2kt.ts2kt.unsupported_uvf806$', wrapFunction(function () {
    var reportUnsupportedNode = _.ts2kt.utils.reportUnsupportedNode_uvf806$;
    return function (node) {
      reportUnsupportedNode(node);
    };
  }));
  var ANY;
  var NOTHING;
  var NUMBER;
  var STRING;
  var BOOLEAN;
  var UNIT;
  var DYNAMIC;
  var ARRAY;
  var NOTHING_TYPE;
  var SHOULD_BE_ESCAPED;
  function NOT_OVERRIDE$lambda(it) {
    return false;
  }
  var NOT_OVERRIDE;
  var OVERLOAD_GEN_THRESHOLD_FOR_TYPE_COUNT_ON_ONE_PARAMETER;
  var OVERLOAD_GEN_THRESHOLD_FOR_TOTAL_COUNT;
  function escapeIfNeed($receiver) {
    var tmp$;
    if ($receiver.length > 0 && !equals($receiver, '*') && !isIdentifier($receiver)) {
      tmp$ = '`' + $receiver + '`';
    }
     else {
      tmp$ = $receiver;
    }
    return tmp$;
  }
  var toBoxedChar = Kotlin.toBoxedChar;
  function isIdentifier($receiver) {
    if ($receiver.length === 0)
      return false;
    if (SHOULD_BE_ESCAPED.contains_11rb$($receiver))
      return false;
    var all$result;
    all$break: do {
      var tmp$;
      tmp$ = iterator($receiver);
      while (tmp$.hasNext()) {
        var element = unboxChar(tmp$.next());
        if (!(unboxChar(toBoxedChar(element)) === 95)) {
          all$result = false;
          break all$break;
        }
      }
      all$result = true;
    }
     while (false);
    if (all$result)
      return false;
    if (!isIdentifierStart($receiver.charCodeAt(0)))
      return false;
    var $receiver_0 = drop($receiver, 1);
    var all$result_0;
    all$break: do {
      var tmp$_0;
      tmp$_0 = iterator($receiver_0);
      while (tmp$_0.hasNext()) {
        var element_0 = unboxChar(tmp$_0.next());
        if (!isIdentifierPart(unboxChar(toBoxedChar(element_0)))) {
          all$result_0 = false;
          break all$break;
        }
      }
      all$result_0 = true;
    }
     while (false);
    return all$result_0;
  }
  function isIdentifierStart($receiver) {
    if ($receiver === 95 || (new CharRange(97, 122)).contains_mef7kx$($receiver) || (new CharRange(65, 90)).contains_mef7kx$($receiver))
      return true;
    else
      return false;
  }
  function isIdentifierPart($receiver) {
    var tmp$;
    if (!isIdentifierStart($receiver)) {
      if ($receiver === 46 || (new CharRange(48, 57)).contains_mef7kx$($receiver))
        tmp$ = true;
      else
        tmp$ = false;
    }
     else
      tmp$ = true;
    return tmp$;
  }
  function sanitize($receiver) {
    var tmp$;
    var sb = new StringBuilder();
    sb.append_s8itvh$(!isIdentifierStart($receiver.charCodeAt(0)) ? 95 : $receiver.charCodeAt(0));
    tmp$ = iterator(drop($receiver, 1));
    while (tmp$.hasNext()) {
      var c = unboxChar(tmp$.next());
      sb.append_s8itvh$(!isIdentifierPart(c) ? 95 : c);
    }
    return sb.toString();
  }
  function get_isVararg($receiver) {
    return $receiver.dotDotDotToken != null;
  }
  function toKotlinParam($receiver, typeMapper) {
    var tmp$;
    var nodeType = getNodeTypeConsideringVararg($receiver);
    return toKotlinParam_0($receiver, nodeType, (tmp$ = nodeType != null ? mapType(typeMapper, nodeType) : null) != null ? tmp$ : new KtType(ANY));
  }
  var collectionSizeOrDefault = Kotlin.kotlin.collections.collectionSizeOrDefault_ba2ldo$;
  function toKotlinParamOverloads($receiver, typeMapper) {
    var tmp$;
    var nodeType = getNodeTypeConsideringVararg($receiver);
    var unionType = (tmp$ = nodeType != null ? mapTypeToUnion(typeMapper, nodeType) : null) != null ? tmp$ : KtTypeUnion([new KtType(ANY)]);
    if (unionType.possibleTypes.size > OVERLOAD_GEN_THRESHOLD_FOR_TYPE_COUNT_ON_ONE_PARAMETER) {
      return listOf(toKotlinParam_1($receiver, new KtType(DYNAMIC, void 0, stringify(unionType))));
    }
    var $receiver_0 = unionType.possibleTypes;
    var destination = ArrayList_init(collectionSizeOrDefault($receiver_0, 10));
    var tmp$_0;
    tmp$_0 = $receiver_0.iterator();
    while (tmp$_0.hasNext()) {
      var item = tmp$_0.next();
      destination.add_11rb$(toKotlinParam_0($receiver, nodeType, item));
    }
    return destination;
  }
  function toKotlinParam_0($receiver, nodeType, typeWithoutFlags) {
    return toKotlinParam_1($receiver, typeWithoutFlags.copy_wau779$(void 0, void 0, void 0, $receiver.questionToken != null || typeWithoutFlags.isNullable));
  }
  function toKotlinParam_1($receiver, type) {
    var tmp$, tmp$_0;
    var name = ensureNotNull((tmp$ = $receiver.name) != null ? asString_0(tmp$) : null);
    var tmp$_1;
    if ((tmp$_0 = $receiver.initializer) != null) {
      var block$result;
      var tmp$_2, tmp$_3;
      tmp$_3 = Kotlin.isType(tmp$_2 = tmp$_0.kind, Any) ? tmp$_2 : throwCCE();
      if (equals(tmp$_3, SyntaxKind$NumericLiteral)) {
        block$result = tmp$_0.text;
      }
       else if (equals(tmp$_3, SyntaxKind$StringLiteral)) {
        block$result = '"' + tmp$_0.text + '"';
      }
       else {
        block$result = reportUnsupportedNode(tmp$_0);
      }
      tmp$_1 = block$result;
    }
     else
      tmp$_1 = null;
    var defaultValue = tmp$_1;
    var isVar = (getCombinedModifierFlags($receiver) & ModifierFlags$AccessibilityModifier) !== 0;
    var isOptional = $receiver.questionToken != null;
    return new KtFunParam(new KtName(name), new KtTypeAnnotation(type, get_isVararg($receiver)), defaultValue == null && isOptional ? 'null' : defaultValue, isVar);
  }
  var getKClass = Kotlin.getKClass;
  var SyntaxKind = $module$typescript.SyntaxKind;
  var get_js = Kotlin.kotlin.js.get_js_1yb8b7$;
  function getNodeTypeConsideringVararg($receiver) {
    var originalNodeType = $receiver.type;
    var nodeType;
    if (get_isVararg($receiver) && originalNodeType != null) {
      var originalNodeKind = originalNodeType.kind;
      if (originalNodeKind === SyntaxKind$ArrayType) {
        nodeType = originalNodeType.elementType;
      }
       else {
        var tmp$, tmp$_0;
        if (originalNodeKind === SyntaxKind$TypeReference && equals((Kotlin.isType(tmp$_0 = (Kotlin.isType(tmp$ = originalNodeType, Object) ? tmp$ : throwCCE()).typeName, Object) ? tmp$_0 : throwCCE()).text, 'Array')) {
          var typeArguments = ensureNotNull(originalNodeType.typeArguments);
          assert(typeArguments.length === 1, 'Array should have one generic paramater, but have ' + typeArguments.length + '.');
          nodeType = typeArguments[0];
        }
         else {
          report('Rest parameter must be array types, but ' + get_js(getKClass(SyntaxKind))[originalNodeKind]);
          return null;
        }
      }
    }
     else {
      nodeType = originalNodeType;
    }
    return nodeType;
  }
  function toKotlinParamsOverloads($receiver, typeMapper) {
    return toKotlinParamsOverloads_0($receiver, typeMapper, $receiver.length - 1 | 0);
  }
  var addAll = Kotlin.kotlin.collections.addAll_ipc267$;
  function toKotlinParamsOverloads_0($receiver, typeMapper, arrIndex) {
    if (arrIndex < 0) {
      return listOf(emptyList());
    }
     else {
      var overloadsOfPriorParams = toKotlinParamsOverloads_0($receiver, typeMapper, arrIndex - 1 | 0);
      var parameterDeclaration = $receiver[arrIndex];
      var paramOverloads = {v: toKotlinParamOverloads(parameterDeclaration, typeMapper)};
      if (Kotlin.imul(overloadsOfPriorParams.size, paramOverloads.v.size) > OVERLOAD_GEN_THRESHOLD_FOR_TOTAL_COUNT) {
        var $receiver_0 = paramOverloads.v;
        var destination = ArrayList_init(collectionSizeOrDefault($receiver_0, 10));
        var tmp$;
        tmp$ = $receiver_0.iterator();
        while (tmp$.hasNext()) {
          var item = tmp$.next();
          destination.add_11rb$(item.type.type);
        }
        var comment = stringify(new KtTypeUnion_0(destination));
        paramOverloads.v = listOf(toKotlinParam_1(parameterDeclaration, new KtType(DYNAMIC, void 0, comment)));
      }
      var destination_0 = ArrayList_init();
      var tmp$_0;
      tmp$_0 = overloadsOfPriorParams.iterator();
      while (tmp$_0.hasNext()) {
        var element = tmp$_0.next();
        var $receiver_1 = paramOverloads.v;
        var destination_1 = ArrayList_init(collectionSizeOrDefault($receiver_1, 10));
        var tmp$_1;
        tmp$_1 = $receiver_1.iterator();
        while (tmp$_1.hasNext()) {
          var item_0 = tmp$_1.next();
          destination_1.add_11rb$(plus_0(element, item_0));
        }
        var list = destination_1;
        addAll(destination_0, list);
      }
      return destination_0;
    }
  }
  function toKotlinParams($receiver, typeMapper) {
    var destination = ArrayList_init($receiver.length);
    var tmp$;
    for (tmp$ = 0; tmp$ !== $receiver.length; ++tmp$) {
      var item = $receiver[tmp$];
      destination.add_11rb$(toKotlinParam(item, typeMapper));
    }
    return destination;
  }
  function toKotlinTypeParams($receiver, typeMapper) {
    var destination = ArrayList_init($receiver.length);
    var tmp$;
    for (tmp$ = 0; tmp$ !== $receiver.length; ++tmp$) {
      var item = $receiver[tmp$];
      destination.add_11rb$(toKotlinTypeParam(item, typeMapper));
    }
    return destination;
  }
  function toKotlinTypeParam($receiver, typeMapper) {
    var tmp$;
    var type = mapType(typeMapper, $receiver);
    var upperBound = (tmp$ = $receiver.constraint) != null ? mapType(typeMapper, tmp$) : null;
    assert(type.qualifiedName.qualifier == null, 'type.qualifiedName.qualifier expected to be null, but ' + toString(type.qualifiedName.qualifier));
    return new KtTypeParam(type.qualifiedName.name, upperBound);
  }
  function toKotlinCallSignatureOverloads($receiver, typeMapper) {
    var newTypeMapper = typeMapper.withTypeParameters_le0eav$($receiver.typeParameters);
    var paramsOverloads = toKotlinParamsOverloads($receiver.parameters, newTypeMapper);
    var destination = ArrayList_init(collectionSizeOrDefault(paramsOverloads, 10));
    var tmp$;
    tmp$ = paramsOverloads.iterator();
    while (tmp$.hasNext()) {
      var item = tmp$.next();
      destination.add_11rb$(toKotlinCallSignature_0($receiver, newTypeMapper, item));
    }
    return destination;
  }
  function toKotlinCallSignature($receiver, typeMapper) {
    var newTypeMapper = typeMapper.withTypeParameters_le0eav$($receiver.typeParameters);
    var params = toKotlinParams($receiver.parameters, newTypeMapper);
    return toKotlinCallSignature_0($receiver, newTypeMapper, params);
  }
  function toKotlinCallSignature_0($receiver, typeMapper, params) {
    var tmp$, tmp$_0, tmp$_1;
    var typeParams = (tmp$ = $receiver.typeParameters) != null ? toKotlinTypeParams(tmp$, typeMapper) : null;
    var returnType = (tmp$_1 = (tmp$_0 = $receiver.type) != null ? mapType(typeMapper, tmp$_0) : null) != null ? tmp$_1 : new KtType(UNIT);
    return new KtCallSignature(params, typeParams, new KtTypeAnnotation(returnType));
  }
  function toKotlinType($receiver, typeMapper) {
    var typeArg = mapType(typeMapper, $receiver.elementType);
    return new KtType(ARRAY, listOf(typeArg));
  }
  function toKotlinType_0($receiver, typeMapper) {
    var tmp$, tmp$_0;
    var params = toKotlinParams($receiver.parameters, typeMapper);
    var returnType = (tmp$_0 = (tmp$ = $receiver.type) != null ? mapType(typeMapper, tmp$) : null) != null ? tmp$_0 : new KtType(ANY);
    return createFunctionType(params, returnType);
  }
  function toKotlinTypeUnion($receiver, typeMapper) {
    var $receiver_0 = toKotlinParamsOverloads($receiver.parameters, typeMapper);
    var destination = ArrayList_init(collectionSizeOrDefault($receiver_0, 10));
    var tmp$;
    tmp$ = $receiver_0.iterator();
    while (tmp$.hasNext()) {
      var item = tmp$.next();
      var tmp$_0, tmp$_1;
      destination.add_11rb$(createFunctionType(item, (tmp$_1 = (tmp$_0 = $receiver.type) != null ? mapType(typeMapper, tmp$_0) : null) != null ? tmp$_1 : new KtType(ANY)));
    }
    return new KtTypeUnion_0(destination);
  }
  function toKotlinType_1($receiver, typeMapper) {
    return typeMapper.getKotlinTypeForObjectType_29gnwt$($receiver);
  }
  function toKotlinTypeUnion_0($receiver, typeMapper) {
    var tmp$, tmp$_0, tmp$_1;
    tmp$_0 = Kotlin.isType(tmp$ = $receiver.kind, Any) ? tmp$ : throwCCE();
    if (equals(tmp$_0, SyntaxKind$ConstructorType) || equals(tmp$_0, SyntaxKind$FunctionType)) {
      tmp$_1 = toKotlinTypeUnion($receiver, typeMapper);
    }
     else if (equals(tmp$_0, SyntaxKind$TypeReference)) {
      tmp$_1 = toKotlinTypeUnion_1($receiver, typeMapper);
    }
     else if (equals(tmp$_0, SyntaxKind$UnionType)) {
      tmp$_1 = toKotlinTypeUnion_2($receiver, typeMapper);
    }
     else if (equals(tmp$_0, SyntaxKind$IntersectionType)) {
      tmp$_1 = toKotlinTypeUnion_3($receiver, typeMapper);
    }
     else
      tmp$_1 = KtTypeUnion([toKotlinType_2($receiver, typeMapper)]);
    return tmp$_1;
  }
  function toKotlinType_2($receiver, typeMapper) {
    var tmp$, tmp$_0, tmp$_1;
    tmp$_0 = Kotlin.isType(tmp$ = $receiver.kind, Any) ? tmp$ : throwCCE();
    if (equals(tmp$_0, SyntaxKind$AnyKeyword))
      tmp$_1 = new KtType(ANY);
    else if (equals(tmp$_0, SyntaxKind$ObjectKeyword))
      tmp$_1 = new KtType(ANY);
    else if (equals(tmp$_0, SyntaxKind$NumberKeyword))
      tmp$_1 = new KtType(NUMBER);
    else if (equals(tmp$_0, SyntaxKind$StringKeyword))
      tmp$_1 = new KtType(STRING);
    else if (equals(tmp$_0, SyntaxKind$BooleanKeyword))
      tmp$_1 = new KtType(BOOLEAN);
    else if (equals(tmp$_0, SyntaxKind$VoidKeyword))
      tmp$_1 = new KtType(UNIT);
    else if (equals(tmp$_0, SyntaxKind$NullKeyword) || equals(tmp$_0, SyntaxKind$UndefinedKeyword))
      tmp$_1 = NOTHING_TYPE;
    else if (equals(tmp$_0, SyntaxKind$ArrayType)) {
      tmp$_1 = toKotlinType($receiver, typeMapper);
    }
     else if (equals(tmp$_0, SyntaxKind$ConstructorType) || equals(tmp$_0, SyntaxKind$FunctionType)) {
      tmp$_1 = toKotlinType_0($receiver, typeMapper);
    }
     else if (equals(tmp$_0, SyntaxKind$TypeReference)) {
      tmp$_1 = toKotlinTypeUnion_1($receiver, typeMapper).singleType;
    }
     else if (equals(tmp$_0, SyntaxKind$ExpressionWithTypeArguments)) {
      tmp$_1 = toKotlinType_3($receiver, typeMapper);
    }
     else if (equals(tmp$_0, SyntaxKind$Identifier)) {
      tmp$_1 = new KtType(KtQualifiedName_init(unescapeIdentifier($receiver.text)));
    }
     else if (equals(tmp$_0, SyntaxKind$TypeLiteral)) {
      tmp$_1 = toKotlinType_1($receiver, typeMapper);
    }
     else if (equals(tmp$_0, SyntaxKind$UnionType)) {
      tmp$_1 = toKotlinTypeUnion_2($receiver, typeMapper).singleType;
    }
     else if (equals(tmp$_0, SyntaxKind$IntersectionType)) {
      tmp$_1 = toKotlinTypeUnion_3($receiver, typeMapper).singleType;
    }
     else if (equals(tmp$_0, SyntaxKind$ParenthesizedType)) {
      tmp$_1 = toKotlinType_2($receiver.type, typeMapper);
    }
     else if (equals(tmp$_0, SyntaxKind$LiteralType))
      tmp$_1 = new KtType(ANY, void 0, '"' + toString($receiver.literal.text) + '"');
    else if (equals(tmp$_0, SyntaxKind$ThisType)) {
      tmp$_1 = toKotlinType_4($receiver, typeMapper);
    }
     else if (equals(tmp$_0, SyntaxKind$TypePredicate)) {
      tmp$_1 = toKotlinType_5($receiver, typeMapper);
    }
     else
      tmp$_1 = new KtType(DYNAMIC, void 0, reportUnsupportedNodeAndGetMessage($receiver));
    return tmp$_1;
  }
  function toKotlinTypeName($receiver) {
    var tmp$, tmp$_0, tmp$_1, tmp$_2;
    if (equals(Kotlin.isType(tmp$ = $receiver.kind, Any) ? tmp$ : throwCCE(), SyntaxKind$Identifier)) {
      tmp$_2 = KtQualifiedName_init(unescapeIdentifier((Kotlin.isType(tmp$_0 = $receiver, Object) ? tmp$_0 : throwCCE()).text));
    }
     else {
      tmp$_2 = KtQualifiedName_init(unescapeIdentifier((Kotlin.isType(tmp$_1 = $receiver, Object) ? tmp$_1 : throwCCE()).right.text), toKotlinTypeName($receiver.left));
    }
    return tmp$_2;
  }
  function toKotlinTypeUnion_1($receiver, typeMapper) {
    return KtTypeUnion([toKotlinTypeIgnoringTypeAliases($receiver, typeMapper)]);
  }
  function toKotlinTypeIgnoringTypeAliases($receiver, typeMapper) {
    var tmp$, tmp$_0, tmp$_1, tmp$_2, tmp$_3;
    var name = toKotlinTypeName(Kotlin.isType(tmp$ = $receiver.typeName, Object) ? tmp$ : throwCCE());
    if (equals(name, KtQualifiedName_init('Function')))
      tmp$_3 = new KtType(name, listOf(starType()));
    else if (equals(name, KtQualifiedName_init('Object')))
      tmp$_3 = new KtType(ANY);
    else {
      var tmp$_4;
      if ((tmp$_1 = (tmp$_0 = $receiver.typeArguments) != null ? tmp$_0 : null) != null) {
        var destination = ArrayList_init(tmp$_1.length);
        var tmp$_5;
        for (tmp$_5 = 0; tmp$_5 !== tmp$_1.length; ++tmp$_5) {
          var item = tmp$_1[tmp$_5];
          destination.add_11rb$(mapType(typeMapper, item));
        }
        tmp$_4 = destination;
      }
       else
        tmp$_4 = null;
      tmp$_3 = new KtType(name, (tmp$_2 = tmp$_4) != null ? tmp$_2 : emptyList());
    }
    return tmp$_3;
  }
  function toKotlinType_3($receiver, typeMapper) {
    var tmp$, tmp$_0, tmp$_1, tmp$_2;
    var name = stringifyQualifiedName($receiver.expression);
    tmp$ = name != null ? name : KtQualifiedName_init('???');
    var tmp$_3;
    if ((tmp$_1 = (tmp$_0 = $receiver.typeArguments) != null ? tmp$_0 : null) != null) {
      var destination = ArrayList_init(tmp$_1.length);
      var tmp$_4;
      for (tmp$_4 = 0; tmp$_4 !== tmp$_1.length; ++tmp$_4) {
        var item = tmp$_1[tmp$_4];
        destination.add_11rb$(mapType(typeMapper, item));
      }
      tmp$_3 = destination;
    }
     else
      tmp$_3 = null;
    return new KtType(tmp$, (tmp$_2 = tmp$_3) != null ? tmp$_2 : emptyList());
  }
  function toKtQualifiedName($receiver) {
    var tmp$;
    var identifier = unescapeIdentifier($receiver.name.text);
    var qualifier = (tmp$ = $receiver.expression) != null ? stringifyQualifiedName(tmp$) : null;
    return KtQualifiedName_init(identifier, qualifier);
  }
  function stringifyQualifiedName($receiver) {
    var tmp$, tmp$_0;
    tmp$_0 = Kotlin.isType(tmp$ = $receiver.kind, Any) ? tmp$ : throwCCE();
    if (equals(tmp$_0, SyntaxKind$Identifier)) {
      return KtQualifiedName_init(unescapeIdentifier($receiver.text));
    }
     else if (equals(tmp$_0, SyntaxKind$PropertyAccessExpression)) {
      return toKtQualifiedName($receiver);
    }
     else
      return reportUnsupportedNode($receiver);
  }
  function toKotlinTypeUnion_2($receiver, typeMapper) {
    var $receiver_0 = $receiver.types;
    var destination = ArrayList_init();
    var tmp$;
    for (tmp$ = 0; tmp$ !== $receiver_0.length; ++tmp$) {
      var element = $receiver_0[tmp$];
      var list = mapTypeToUnion(typeMapper, element).possibleTypes;
      addAll(destination, list);
    }
    var possibleTypes = distinct(destination);
    if (possibleTypes.size === 2) {
      var a = possibleTypes.get_za3lpa$(0);
      var b = possibleTypes.get_za3lpa$(1);
      var t = (a != null ? a.equals(NOTHING_TYPE) : null) ? b : (b != null ? b.equals(NOTHING_TYPE) : null) ? a : null;
      if (t != null) {
        return new KtTypeUnion_0(listOf(t.copy_wau779$(void 0, void 0, void 0, true)));
      }
    }
    return new KtTypeUnion_0(possibleTypes);
  }
  function toKotlinTypeUnion$lambda(closure$commentWithExpectedType) {
    return function (it) {
      return it.copy_wau779$(void 0, void 0, closure$commentWithExpectedType);
    };
  }
  function toKotlinTypeUnion_3($receiver, typeMapper) {
    var $receiver_0 = $receiver.types;
    var destination = ArrayList_init($receiver_0.length);
    var tmp$;
    for (tmp$ = 0; tmp$ !== $receiver_0.length; ++tmp$) {
      var item = $receiver_0[tmp$];
      destination.add_11rb$(mapTypeToUnion(typeMapper, item));
    }
    var kotlinTypeUnions = destination;
    var commentWithExpectedType = join(kotlinTypeUnions, ' & ', void 0, void 0, void 0, void 0, void 0, getCallableRef('stringify', function ($receiver) {
      return stringify($receiver);
    }));
    return mapLast(kotlinTypeUnions.get_za3lpa$(0), toKotlinTypeUnion$lambda(commentWithExpectedType));
  }
  function mapLast($receiver, function_0) {
    return new KtTypeUnion_0(plus_0(dropLast($receiver.possibleTypes, 1), function_0(last($receiver.possibleTypes))));
  }
  function toKotlinType_4($receiver, typeMapper) {
    var tmp$, tmp$_0;
    var parent = $receiver.parent;
    while (parent != null) {
      tmp$_0 = Kotlin.isType(tmp$ = parent.kind, Any) ? tmp$ : throwCCE();
      if (equals(tmp$_0, SyntaxKind$ClassDeclaration) || equals(tmp$_0, SyntaxKind$InterfaceDeclaration)) {
        return toKotlinType_6(parent, typeMapper).copy_wau779$(void 0, void 0, 'this');
      }
       else if (equals(tmp$_0, SyntaxKind$TypeLiteral))
        return new KtType(ANY, void 0, 'this');
      parent = parent.parent;
    }
    return new KtType(DYNAMIC, void 0, report('ThisTypeNode.toKotlinType in illegal state'));
  }
  function toKotlinType_5($receiver, typeMapper) {
    return new KtType(BOOLEAN);
  }
  function toKotlinType_6($receiver, typeMapper) {
    var tmp$, tmp$_0, tmp$_1, tmp$_2;
    var name = unescapeIdentifier(ensureNotNull($receiver.name).text);
    tmp$ = KtQualifiedName_init(name);
    var tmp$_3;
    if ((tmp$_1 = (tmp$_0 = $receiver.typeParameters) != null ? tmp$_0 : null) != null) {
      var destination = ArrayList_init(tmp$_1.length);
      var tmp$_4;
      for (tmp$_4 = 0; tmp$_4 !== tmp$_1.length; ++tmp$_4) {
        var item = tmp$_1[tmp$_4];
        destination.add_11rb$(new KtType(KtQualifiedName_init(unescapeIdentifier(item.name.text))));
      }
      tmp$_3 = destination;
    }
     else
      tmp$_3 = null;
    return new KtType(tmp$, (tmp$_2 = tmp$_3) != null ? tmp$_2 : emptyList());
  }
  function forEachChild$lambda(closure$visitor) {
    return function (node) {
      visitNode(closure$visitor, node);
      return undefined;
    };
  }
  function forEachChild_0(visitor, node) {
    forEachChild(node, forEachChild$lambda(visitor));
  }
  function visitNode(visitor, node) {
    if (node == null)
      return;
    try {
      visitNodeImpl(visitor, node);
    }
     catch (e) {
      reportUnsupportedNode(node);
    }
  }
  function visitNodeImpl(visitor, node) {
    var tmp$, tmp$_0;
    tmp$_0 = Kotlin.isType(tmp$ = node.kind, Any) ? tmp$ : throwCCE();
    if (equals(tmp$_0, SyntaxKind$ModuleDeclaration))
      visitor.visitModuleDeclaration_ezg4eu$(node);
    else if (equals(tmp$_0, SyntaxKind$FunctionDeclaration)) {
      visitor.visitFunctionDeclaration_eywj3y$(node);
    }
     else if (equals(tmp$_0, SyntaxKind$VariableStatement)) {
      visitor.visitVariableStatement_x0poxd$(node);
    }
     else if (equals(tmp$_0, SyntaxKind$EnumDeclaration)) {
      visitor.visitEnumDeclaration_1emvp1$(node);
    }
     else if (equals(tmp$_0, SyntaxKind$ClassDeclaration)) {
      visitor.visitClassDeclaration_4wvyue$(node);
    }
     else if (equals(tmp$_0, SyntaxKind$InterfaceDeclaration)) {
      visitor.visitInterfaceDeclaration_f4u3$(node);
    }
     else if (equals(tmp$_0, SyntaxKind$TypeAliasDeclaration)) {
      visitor.visitTypeAliasDeclaration_it7xrc$(node);
    }
     else if (equals(tmp$_0, SyntaxKind$HeritageClause)) {
      visitor.visitHeritageClause_10qtta$(node);
    }
     else if (equals(tmp$_0, SyntaxKind$Constructor)) {
      visitor.visitConstructorDeclaration_cz84f8$(node);
    }
     else if (equals(tmp$_0, SyntaxKind$ConstructSignature)) {
      visitor.visitConstructSignatureDeclaration_cz84f8$(node);
    }
     else if (equals(tmp$_0, SyntaxKind$MethodDeclaration) || equals(tmp$_0, SyntaxKind$MethodSignature)) {
      visitor.visitMethodDeclaration_7vsj57$(node);
    }
     else if (equals(tmp$_0, SyntaxKind$PropertyDeclaration) || equals(tmp$_0, SyntaxKind$PropertySignature)) {
      visitor.visitPropertyDeclaration_qnxew1$(node);
    }
     else if (equals(tmp$_0, SyntaxKind$IndexSignature)) {
      visitor.visitIndexSignature_53if9s$(node);
    }
     else if (equals(tmp$_0, SyntaxKind$CallSignature)) {
      visitor.visitSignatureDeclaration_vb212e$(node);
    }
     else if (equals(tmp$_0, SyntaxKind$ExportAssignment)) {
      visitor.visitExportAssignment_fybyfv$(node);
    }
     else if (equals(tmp$_0, SyntaxKind$ImportEqualsDeclaration)) {
      visitor.visitImportEqualsDeclaration_p9svv6$(node);
    }
     else if (!equals(tmp$_0, SyntaxKind$EndOfFileToken))
      reportUnsupportedNode(node);
  }
  var get_arr = defineInlineFunction('ts2kt.ts2kt.get_arr_zcybyc$', function ($receiver) {
    return $receiver;
  });
  var get_str = defineInlineFunction('ts2kt.ts2kt.get_str_g3v1o4$', wrapFunction(function () {
    var getKClass = Kotlin.getKClass;
    var SyntaxKind = _.$$importsForInline$$.typescript.SyntaxKind;
    var get_js = Kotlin.kotlin.js.get_js_1yb8b7$;
    return function ($receiver) {
      return get_js(getKClass(SyntaxKind))[$receiver];
    };
  }));
  var get_id = defineInlineFunction('ts2kt.ts2kt.get_id_g3v1o4$', function ($receiver) {
    return $receiver;
  });
  var get_unescapedText = defineInlineFunction('ts2kt.ts2kt.get_unescapedText_viuja6$', wrapFunction(function () {
    var unescapeIdentifier = _.$$importsForInline$$.typescript.unescapeIdentifier;
    return function ($receiver) {
      return unescapeIdentifier($receiver.text);
    };
  }));
  function format($receiver) {
    return (numberToInt($receiver.line) + 1 | 0).toString() + ':' + (numberToInt($receiver.character) + 1 | 0);
  }
  function location($receiver) {
    var start = $receiver.getSourceFile().getLineAndCharacterOfPosition($receiver.pos);
    var end = $receiver.getSourceFile().getLineAndCharacterOfPosition($receiver.end);
    return $receiver.getSourceFile().fileName + ':' + format(start) + ' to ' + format(end);
  }
  var contains = defineInlineFunction('ts2kt.ts2kt.contains_aufjat$', function ($receiver, flag) {
    return ($receiver & flag) !== 0;
  });
  function getSymbolResolvingAliases($receiver, location) {
    var symbol = $receiver.getSymbolAtLocation(location);
    while (true) {
      var tmp$ = symbol != null;
      if (tmp$) {
        tmp$ = (symbol.flags & SymbolFlags$Alias) !== 0;
      }
      if (!tmp$)
        break;
      symbol = $receiver.getAliasedSymbol(symbol);
    }
    return symbol;
  }
  var Regex_init = Kotlin.kotlin.text.Regex_init_61zpoe$;
  function toStringKey($receiver) {
    var destination = ArrayList_init(collectionSizeOrDefault($receiver, 10));
    var tmp$;
    tmp$ = $receiver.iterator();
    while (tmp$.hasNext()) {
      var item = tmp$.next();
      var tmp$_0 = destination.add_11rb$;
      var tmp$_1 = stringify(item);
      tmp$_0.call(destination, Regex_init('(\\(|,\\s*)\\w+: ').replace_x2uqeu$(tmp$_1, '$1'));
    }
    return joinToString(sorted(destination), '');
  }
  function BaseVisitor() {
  }
  BaseVisitor.prototype.visitModuleDeclaration_ezg4eu$ = function (node) {
    this.visitList_uvf806$(node.body);
  };
  BaseVisitor.prototype.visitFunctionDeclaration_eywj3y$ = function (node) {
  };
  BaseVisitor.prototype.visitTypeAliasDeclaration_it7xrc$ = function (node) {
  };
  BaseVisitor.prototype.visitVariableStatement_x0poxd$ = function (node) {
  };
  BaseVisitor.prototype.visitEnumDeclaration_1emvp1$ = function (node) {
  };
  BaseVisitor.prototype.visitClassDeclaration_4wvyue$ = function (node) {
    var $receiver = node.members;
    var tmp$;
    for (tmp$ = 0; tmp$ !== $receiver.length; ++tmp$) {
      var element = $receiver[tmp$];
      visitNode(this, element);
    }
  };
  BaseVisitor.prototype.visitInterfaceDeclaration_f4u3$ = function (node) {
    var $receiver = node.members;
    var tmp$;
    for (tmp$ = 0; tmp$ !== $receiver.length; ++tmp$) {
      var element = $receiver[tmp$];
      visitNode(this, element);
    }
  };
  BaseVisitor.prototype.visitHeritageClause_10qtta$ = function (node) {
  };
  BaseVisitor.prototype.visitConstructorDeclaration_cz84f8$ = function (node) {
  };
  BaseVisitor.prototype.visitConstructSignatureDeclaration_cz84f8$ = function (node) {
  };
  BaseVisitor.prototype.visitMethodDeclaration_7vsj57$ = function (node) {
  };
  BaseVisitor.prototype.visitPropertyDeclaration_qnxew1$ = function (node) {
  };
  BaseVisitor.prototype.visitIndexSignature_53if9s$ = function (node) {
  };
  BaseVisitor.prototype.visitSignatureDeclaration_vb212e$ = function (node) {
  };
  BaseVisitor.prototype.visitExportAssignment_fybyfv$ = function (node) {
  };
  BaseVisitor.prototype.visitImportEqualsDeclaration_p9svv6$ = function (node) {
  };
  BaseVisitor.prototype.visitList_uvf806$ = function (node) {
    forEachChild_0(this, node);
  };
  BaseVisitor.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'BaseVisitor',
    interfaces: [Visitor]
  };
  var LinkedHashMap_init = Kotlin.kotlin.collections.LinkedHashMap_init_q3lmfv$;
  function ConverterContext() {
    this.packageParts = ArrayList_init();
    this.packagePartsBySymbol = LinkedHashMap_init();
    this.declarations = LinkedHashMap_init();
  }
  ConverterContext.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'ConverterContext',
    interfaces: []
  };
  function build($receiver) {
    processExportedDeclarations($receiver);
    var tmp$;
    tmp$ = $receiver.packageParts.iterator();
    while (tmp$.hasNext()) {
      var element = tmp$.next();
      mergeClassesAndPackages(element);
    }
    var $receiver_0 = $receiver.packageParts;
    var destination = ArrayList_init(collectionSizeOrDefault($receiver_0, 10));
    var tmp$_0;
    tmp$_0 = $receiver_0.iterator();
    while (tmp$_0.hasNext()) {
      var item = tmp$_0.next();
      destination.add_11rb$(item.build());
    }
    var destination_0 = ArrayList_init();
    var tmp$_1;
    tmp$_1 = destination.iterator();
    while (tmp$_1.hasNext()) {
      var element_0 = tmp$_1.next();
      if (!element_0.members.isEmpty())
        destination_0.add_11rb$(element_0);
    }
    return destination_0;
  }
  function processExportedDeclarations$lambda$lambda(closure$packagePart) {
    return function () {
      return closure$packagePart;
    };
  }
  function processExportedDeclarations$lambda(packagePart) {
    return zip(asSequence(packagePart.members), generateSequence(processExportedDeclarations$lambda$lambda(packagePart)));
  }
  function processExportedDeclarations($receiver) {
    var tmp$, tmp$_0, tmp$_1, tmp$_2;
    var tmp$_3 = flatMap(asSequence($receiver.packageParts), processExportedDeclarations$lambda);
    var destination = LinkedHashMap_init();
    var tmp$_4;
    tmp$_4 = tmp$_3.iterator();
    while (tmp$_4.hasNext()) {
      var element = tmp$_4.next();
      var pair = element;
      destination.put_xwzc9p$(pair.first, pair.second);
    }
    var declarationToModule = destination;
    tmp$ = $receiver.packageParts.iterator();
    while (tmp$.hasNext()) {
      var builder = tmp$.next();
      var exportedNamespace = (tmp$_0 = builder.exportedSymbol) != null ? $receiver.packagePartsBySymbol.get_11rb$(tmp$_0) : null;
      if (exportedNamespace != null) {
        exportedNamespace.module = builder.module;
      }
      var exportedDeclarations = (tmp$_1 = builder.exportedSymbol) != null ? $receiver.declarations.get_11rb$(tmp$_1) : null;
      if (exportedDeclarations != null) {
        var module_0 = builder.module;
        if (module_0 != null) {
          tmp$_2 = exportedDeclarations.iterator();
          while (tmp$_2.hasNext()) {
            var exportedDeclaration = tmp$_2.next();
            var currentOwner = declarationToModule.get_11rb$(exportedDeclaration);
            exportedDeclaration.annotations = plus_0(exportedDeclaration.annotations, moduleAnnotation(module_0));
            if (Kotlin.isType(exportedDeclaration, KtVariable)) {
              exportedDeclaration.isVar = false;
              if (equals(currentOwner, builder)) {
                exportedDeclaration.name = new KtName(sanitize(module_0));
              }
            }
          }
        }
      }
    }
  }
  function KtPackagePartBuilder(id, parent, ownName) {
    this.id = id;
    this.parent = parent;
    this.ownName = ownName;
    this.members = ArrayList_init();
    this.annotations = ArrayList_init();
    this.module = null;
    this.exportedSymbol = null;
    this.nestedPackages = ArrayList_init();
  }
  KtPackagePartBuilder.prototype.build = function () {
    var tmp$;
    var allAnnotations = toMutableList(this.annotations);
    var $receiver = this.members;
    var none$result;
    none$break: do {
      var tmp$_0;
      if (Kotlin.isType($receiver, Collection) && $receiver.isEmpty()) {
        none$result = true;
        break none$break;
      }
      tmp$_0 = $receiver.iterator();
      while (tmp$_0.hasNext()) {
        var element = tmp$_0.next();
        var $receiver_0 = element.annotations;
        var any$result;
        any$break: do {
          var tmp$_1;
          if (Kotlin.isType($receiver_0, Collection) && $receiver_0.isEmpty()) {
            any$result = false;
            break any$break;
          }
          tmp$_1 = $receiver_0.iterator();
          while (tmp$_1.hasNext()) {
            var element_0 = tmp$_1.next();
            var tmp$_2;
            if ((tmp$_2 = element_0.name) != null ? tmp$_2.equals(JS_MODULE) : null) {
              any$result = true;
              break any$break;
            }
          }
          any$result = false;
        }
         while (false);
        if (any$result) {
          none$result = false;
          break none$break;
        }
      }
      none$result = true;
    }
     while (false);
    if (none$result) {
      if ((tmp$ = this.getEnclosingModule_0()) != null) {
        var element_1 = moduleAnnotation(tmp$);
        allAnnotations.add_11rb$(element_1);
      }
      var qualifier = this.buildQualifier_0();
      if (qualifier.length > 0) {
        var element_2 = new KtAnnotation(JS_QUALIFIER, listOf(new KtArgument('"' + qualifier + '"')));
        allAnnotations.add_11rb$(element_2);
      }
    }
    return new KtPackagePart(this.buildFqName_0(), this.members, allAnnotations);
  };
  function KtPackagePartBuilder$getEnclosingModule$lambda(it) {
    return it.parent;
  }
  function KtPackagePartBuilder$getEnclosingModule$lambda_0(it) {
    return it.module;
  }
  KtPackagePartBuilder.prototype.getEnclosingModule_0 = function () {
    var $receiver = map(generateSequence_0(this, KtPackagePartBuilder$getEnclosingModule$lambda), KtPackagePartBuilder$getEnclosingModule$lambda_0);
    var firstOrNull$result;
    firstOrNull$break: do {
      var tmp$;
      tmp$ = $receiver.iterator();
      while (tmp$.hasNext()) {
        var element = tmp$.next();
        if (element != null) {
          firstOrNull$result = element;
          break firstOrNull$break;
        }
      }
      firstOrNull$result = null;
    }
     while (false);
    return firstOrNull$result;
  };
  function KtPackagePartBuilder$buildQualifier$lambda(it) {
    return it.parent;
  }
  function KtPackagePartBuilder$buildQualifier$lambda_0(it) {
    return it.module == null;
  }
  KtPackagePartBuilder.prototype.buildQualifier_0 = function () {
    return joinToString(this.toFqName_0(takeWhile(generateSequence_0(this, KtPackagePartBuilder$buildQualifier$lambda), KtPackagePartBuilder$buildQualifier$lambda_0)), '.');
  };
  function KtPackagePartBuilder$buildFqName$lambda(it) {
    return it.parent;
  }
  KtPackagePartBuilder.prototype.buildFqName_0 = function () {
    return this.toFqName_0(generateSequence_0(this, KtPackagePartBuilder$buildFqName$lambda));
  };
  function KtPackagePartBuilder$toFqName$lambda(it) {
    return it.ownName;
  }
  function KtPackagePartBuilder$toFqName$lambda_0(it) {
    return it.length > 0;
  }
  KtPackagePartBuilder.prototype.toFqName_0 = function ($receiver) {
    return asReversed(toList_0(filter(map($receiver, KtPackagePartBuilder$toFqName$lambda), KtPackagePartBuilder$toFqName$lambda_0)));
  };
  KtPackagePartBuilder.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'KtPackagePartBuilder',
    interfaces: []
  };
  function TsClassToKt(typeMapper, kind, annotations, isOverride, isOverrideProperty, hasMembersOpenModifier, needsNoImpl) {
    if (kind === void 0)
      kind = KtClassKind$CLASS_getInstance();
    if (annotations === void 0)
      annotations = DEFAULT_ANNOTATION;
    if (hasMembersOpenModifier === void 0)
      hasMembersOpenModifier = true;
    if (needsNoImpl === void 0)
      needsNoImpl = true;
    TsClassifierToKt.call(this, typeMapper, isOverride, isOverrideProperty);
    this.kind = kind;
    this.annotations = annotations;
    this.hasMembersOpenModifier_7qg19l$_0 = hasMembersOpenModifier;
    this.needsNoImpl_97snr3$_0 = needsNoImpl;
    this.isInterface_qyfkxa$_0 = false;
    this.typeParams = null;
    this.paramsOfConstructors = ArrayList_init();
  }
  Object.defineProperty(TsClassToKt.prototype, 'hasMembersOpenModifier', {
    get: function () {
      return this.hasMembersOpenModifier_7qg19l$_0;
    }
  });
  Object.defineProperty(TsClassToKt.prototype, 'needsNoImpl', {
    get: function () {
      return this.needsNoImpl_97snr3$_0;
    }
  });
  Object.defineProperty(TsClassToKt.prototype, 'isInterface', {
    get: function () {
      return this.isInterface_qyfkxa$_0;
    }
  });
  TsClassToKt.prototype.visitClassDeclaration_4wvyue$ = function (node) {
    var tmp$, tmp$_0, tmp$_1;
    this.name = unescapeIdentifier(ensureNotNull(node.name).text);
    this.typeParams = (tmp$ = node.typeParameters) != null ? toKotlinTypeParams(tmp$, this.typeMapper) : null;
    if ((tmp$_1 = (tmp$_0 = node.heritageClauses) != null ? tmp$_0 : null) != null) {
      var tmp$_2;
      for (tmp$_2 = 0; tmp$_2 !== tmp$_1.length; ++tmp$_2) {
        var element = tmp$_1[tmp$_2];
        visitNode(this, element);
      }
    }
    var $receiver = node.members;
    var tmp$_3;
    for (tmp$_3 = 0; tmp$_3 !== $receiver.length; ++tmp$_3) {
      var element_0 = $receiver[tmp$_3];
      visitNode(this, element_0);
    }
  };
  TsClassToKt.prototype.visitConstructorDeclaration_cz84f8$ = function (node) {
    var paramsOverloads = toKotlinParamsOverloads(node.parameters, this.typeMapper);
    this.paramsOfConstructors.addAll_brywnq$(paramsOverloads);
    assert(node.body == null, "A constructor in declarations file should not have body, constructor in '" + toString(this.name));
  };
  TsClassToKt.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'TsClassToKt',
    interfaces: [TsClassifierToKt]
  };
  function TsClassifierToKt(typeMapper, isOverride, isOverrideProperty) {
    TypeScriptToKotlinBase.call(this, ArrayList_init(), LinkedHashMap_init());
    this.typeMapper = typeMapper;
    this.isOverride = isOverride;
    this.isOverrideProperty = isOverrideProperty;
    this.parents = ArrayList_init();
    this.name = null;
    this.staticTranslator = null;
  }
  TsClassifierToKt.prototype.visitHeritageClause_10qtta$ = function (node) {
    var tmp$, tmp$_0, tmp$_1;
    var tmp$_2;
    if ((tmp$_0 = (tmp$ = node.types) != null ? tmp$ : null) != null) {
      var destination = ArrayList_init(tmp$_0.length);
      var tmp$_3;
      for (tmp$_3 = 0; tmp$_3 !== tmp$_0.length; ++tmp$_3) {
        var item = tmp$_0[tmp$_3];
        destination.add_11rb$(new KtHeritageType(mapType(this.typeMapper, item)));
      }
      tmp$_2 = destination;
    }
     else
      tmp$_2 = null;
    var types = (tmp$_1 = tmp$_2) != null ? tmp$_1 : emptyList();
    this.parents.addAll_brywnq$(types);
  };
  TsClassifierToKt.prototype.visitIndexSignature_53if9s$ = function (node) {
    this.translateAccessor_xriwno$_0(node, true);
    this.translateAccessor_xriwno$_0(node, false);
  };
  TsClassifierToKt.prototype.translateAccessor_xriwno$_0 = function (node, isGetter) {
    var tmp$;
    tmp$ = toKotlinParamsOverloads(node.parameters, this.typeMapper).iterator();
    while (tmp$.hasNext()) {
      var element = tmp$.next();
      var tmp$_0, tmp$_1, tmp$_2, tmp$_3, tmp$_4;
      if (isGetter) {
        tmp$_4 = KtTypeUnion([(tmp$_1 = (tmp$_0 = node.type) != null ? mapType(this.typeMapper, tmp$_0) : null) != null ? tmp$_1 : new KtType(ANY)]);
      }
       else {
        tmp$_4 = (tmp$_3 = (tmp$_2 = node.type) != null ? mapTypeToUnion(this.typeMapper, tmp$_2) : null) != null ? tmp$_3 : KtTypeUnion([new KtType(ANY)]);
      }
      var propTypeUnion = tmp$_4;
      var tmp$_5;
      tmp$_5 = propTypeUnion.possibleTypes.iterator();
      while (tmp$_5.hasNext()) {
        var element_0 = tmp$_5.next();
        var callSignature;
        var accessorName;
        var annotation;
        if (isGetter) {
          callSignature = new KtCallSignature(element, emptyList(), new KtTypeAnnotation(element_0.copy_wau779$(void 0, void 0, void 0, true)));
          accessorName = GET;
          annotation = NATIVE_GETTER_ANNOTATION;
        }
         else {
          callSignature = new KtCallSignature(listOf_0([element.get_za3lpa$(0), new KtFunParam(new KtName('value'), new KtTypeAnnotation(element_0))]), emptyList(), new KtTypeAnnotation(new KtType(UNIT)));
          accessorName = SET;
          annotation = NATIVE_SETTER_ANNOTATION;
        }
        this.addFunction_3b8o0j$(null, accessorName, callSignature, void 0, this.needsNoImpl, listOf(annotation), void 0, true);
      }
    }
  };
  TsClassifierToKt.prototype.getTranslator_uhzyw$ = function (node) {
    var tmp$, tmp$_0, tmp$_1, tmp$_2;
    var tmp$_3;
    if ((tmp$_0 = (tmp$ = node.modifiers) != null ? tmp$ : null) != null) {
      var any$result;
      any$break: do {
        var tmp$_4;
        for (tmp$_4 = 0; tmp$_4 !== tmp$_0.length; ++tmp$_4) {
          var element = tmp$_0[tmp$_4];
          if (element.kind === SyntaxKind$StaticKeyword) {
            any$result = true;
            break any$break;
          }
        }
        any$result = false;
      }
       while (false);
      tmp$_3 = any$result;
    }
     else
      tmp$_3 = null;
    if ((tmp$_1 = tmp$_3) != null ? tmp$_1 : false) {
      if (this.staticTranslator == null) {
        this.staticTranslator = new TsClassToKt(this.typeMapper, KtClassKind$COMPANION_OBJECT_getInstance(), emptyList(), NOT_OVERRIDE, NOT_OVERRIDE, false);
        (tmp$_2 = this.staticTranslator) != null ? (tmp$_2.name = '') : null;
      }
      return ensureNotNull(this.staticTranslator);
    }
    return this;
  };
  TsClassifierToKt.prototype.needsNoImpl_qnxew1$ = function (node) {
    return true;
  };
  TsClassifierToKt.prototype.isNullable_qnxew1$ = function (node) {
    return false;
  };
  TsClassifierToKt.prototype.isLambda_qnxew1$ = function (node) {
    return false;
  };
  TsClassifierToKt.prototype.needsNoImpl_7vsj57$ = function (node) {
    return true;
  };
  TsClassifierToKt.prototype.visitPropertyDeclaration_qnxew1$ = function (node) {
    var tmp$, tmp$_0, tmp$_1;
    var declarationName = ensureNotNull(node.name);
    tmp$ = asString(declarationName);
    if (tmp$ == null) {
      return;
    }
    var name = tmp$;
    var varType = (tmp$_1 = (tmp$_0 = node.type) != null ? mapType(this.typeMapper, tmp$_0) : null) != null ? tmp$_1 : new KtType(ANY);
    var isOverride = this.isOverrideProperty(node);
    var symbol = getSymbolResolvingAliases(this.typeMapper.typeChecker, node);
    this.getTranslator_uhzyw$(node).addVariable_x4qmk8$(symbol, name, varType.copy_wau779$(void 0, void 0, void 0, varType.isNullable || this.isNullable_qnxew1$(node)), void 0, void 0, void 0, this.needsNoImpl_qnxew1$(node), void 0, isOverride);
  };
  TsClassifierToKt.prototype.addFunction_h4pyhe$ = function ($receiver, name, isOverride, needsNoImpl, node) {
    var symbol = getSymbolResolvingAliases($receiver.typeMapper.typeChecker, node);
    var tmp$;
    tmp$ = toKotlinCallSignatureOverloads(node, $receiver.typeMapper).iterator();
    while (tmp$.hasNext()) {
      var element = tmp$.next();
      $receiver.addFunction_3b8o0j$(symbol, name, element, void 0, $receiver.needsNoImpl_7vsj57$(node), void 0, isOverride);
    }
    assert(node.body == null, "An function in declarations file should not have body, function '" + toString($receiver.name) + '.' + name + "'");
  };
  TsClassifierToKt.prototype.visitMethodDeclaration_7vsj57$ = function (node) {
    var tmp$;
    var declarationName = ensureNotNull(node.name);
    tmp$ = asString(declarationName);
    if (tmp$ == null) {
      return;
    }
    var name = tmp$;
    var isOverride = this.isOverride(node);
    this.addFunction_h4pyhe$(this.getTranslator_uhzyw$(node), name, isOverride, this.needsNoImpl, node);
  };
  TsClassifierToKt.prototype.visitSignatureDeclaration_vb212e$ = function (node) {
    var tmp$;
    tmp$ = toKotlinCallSignatureOverloads(node, this.typeMapper).iterator();
    while (tmp$.hasNext()) {
      var element = tmp$.next();
      this.addFunction_3b8o0j$(null, INVOKE, element, void 0, false, listOf(NATIVE_INVOKE_ANNOTATION), void 0, true);
    }
  };
  TsClassifierToKt.prototype.visitConstructSignatureDeclaration_cz84f8$ = function (node) {
  };
  TsClassifierToKt.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'TsClassifierToKt',
    interfaces: [TypeScriptToKotlinBase]
  };
  function TsInterfaceToKt(typeMapper, annotations, isOverride, isOverrideProperty) {
    TsClassifierToKt.call(this, typeMapper, isOverride, isOverrideProperty);
    this.annotations = annotations;
    this.hasMembersOpenModifier_xiuzzc$_0 = false;
    this.needsNoImpl_mb2hi6$_0 = false;
    this.isInterface_uzenar$_0 = true;
    this.typeParams = null;
  }
  Object.defineProperty(TsInterfaceToKt.prototype, 'hasMembersOpenModifier', {
    get: function () {
      return this.hasMembersOpenModifier_xiuzzc$_0;
    }
  });
  Object.defineProperty(TsInterfaceToKt.prototype, 'needsNoImpl', {
    get: function () {
      return this.needsNoImpl_mb2hi6$_0;
    }
  });
  Object.defineProperty(TsInterfaceToKt.prototype, 'isInterface', {
    get: function () {
      return this.isInterface_uzenar$_0;
    }
  });
  TsInterfaceToKt.prototype.needsNoImpl_qnxew1$ = function (node) {
    return node.questionToken != null;
  };
  TsInterfaceToKt.prototype.isNullable_qnxew1$ = function (node) {
    return node.questionToken != null;
  };
  TsInterfaceToKt.prototype.isLambda_qnxew1$ = function (node) {
    var tmp$;
    return ((tmp$ = node.type) != null ? tmp$.kind : null) === SyntaxKind$FunctionType;
  };
  TsInterfaceToKt.prototype.needsNoImpl_7vsj57$ = function (node) {
    return false;
  };
  TsInterfaceToKt.prototype.addFunction_h4pyhe$ = function ($receiver, name, isOverride, needsNoImpl, node) {
    var isOptional = node.questionToken != null;
    var symbol = getSymbolResolvingAliases($receiver.typeMapper.typeChecker, node);
    if (isOptional) {
      var call = toKotlinCallSignature(node, $receiver.typeMapper);
      $receiver.addVariable_x4qmk8$(symbol, name, createFunctionType(call.params, call.returnType.type).copy_wau779$(void 0, void 0, void 0, true), void 0, call.typeParams, false, true, void 0, isOverride);
    }
     else {
      var tmp$;
      tmp$ = toKotlinCallSignatureOverloads(node, $receiver.typeMapper).iterator();
      while (tmp$.hasNext()) {
        var element = tmp$.next();
        $receiver.addFunction_3b8o0j$(symbol, name, element, void 0, false, void 0, isOverride);
      }
    }
  };
  TsInterfaceToKt.prototype.visitInterfaceDeclaration_f4u3$ = function (node) {
    var tmp$, tmp$_0, tmp$_1;
    this.name = unescapeIdentifier(node.name.text);
    this.typeParams = (tmp$ = node.typeParameters) != null ? toKotlinTypeParams(tmp$, this.typeMapper) : null;
    if ((tmp$_1 = (tmp$_0 = node.heritageClauses) != null ? tmp$_0 : null) != null) {
      var tmp$_2;
      for (tmp$_2 = 0; tmp$_2 !== tmp$_1.length; ++tmp$_2) {
        var element = tmp$_1[tmp$_2];
        visitNode(this, element);
      }
    }
    var $receiver = node.members;
    var tmp$_3;
    for (tmp$_3 = 0; tmp$_3 !== $receiver.length; ++tmp$_3) {
      var element_0 = $receiver[tmp$_3];
      visitNode(this, element_0);
    }
  };
  TsInterfaceToKt.prototype.visitConstructSignatureDeclaration_cz84f8$ = function (node) {
  };
  TsInterfaceToKt.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'TsInterfaceToKt',
    interfaces: [TsClassifierToKt]
  };
  function TsInterfaceToKtExtensions(typeMapper, annotations, isOverride, isOverrideProperty) {
    TsInterfaceToKt.call(this, typeMapper, annotations, isOverride, isOverrideProperty);
    this.cachedExtendsType_kjks7r$_0 = lazy(TsInterfaceToKtExtensions$cachedExtendsType$lambda(this));
  }
  Object.defineProperty(TsInterfaceToKtExtensions.prototype, 'cachedExtendsType', {
    get: function () {
      return this.cachedExtendsType_kjks7r$_0.value;
    }
  });
  TsInterfaceToKtExtensions.prototype.getExtendsType_0 = function (typeParams) {
    var tmp$, tmp$_0;
    tmp$ = KtQualifiedName_init(ensureNotNull(this.name));
    var tmp$_1;
    if (typeParams != null) {
      var destination = ArrayList_init(collectionSizeOrDefault(typeParams, 10));
      var tmp$_2;
      tmp$_2 = typeParams.iterator();
      while (tmp$_2.hasNext()) {
        var item = tmp$_2.next();
        destination.add_11rb$(new KtType(new KtQualifiedName(item.name)));
      }
      tmp$_1 = destination;
    }
     else
      tmp$_1 = null;
    return new KtType(tmp$, (tmp$_0 = tmp$_1) != null ? tmp$_0 : emptyList());
  };
  TsInterfaceToKtExtensions.prototype.fixIfClashWith_9pzgf3$ = function ($receiver, another) {
    var tmp$, tmp$_0;
    if ($receiver == null || another == null)
      return $receiver;
    assert($receiver !== another, 'expected this !== another, this = ' + toString($receiver) + ', another = ' + toString(another));
    var extendsTypeParams = ArrayList_init();
    tmp$ = $receiver.iterator();
    while (tmp$.hasNext()) {
      var e = tmp$.next();
      var toAdd = {v: e.name};
      var i = 0;
      while (true) {
        var any$result;
        any$break: do {
          var tmp$_1;
          if (Kotlin.isType(another, Collection) && another.isEmpty()) {
            any$result = false;
            break any$break;
          }
          tmp$_1 = another.iterator();
          while (tmp$_1.hasNext()) {
            var element = tmp$_1.next();
            var tmp$_2;
            if ((tmp$_2 = element.name) != null ? tmp$_2.equals(toAdd.v) : null) {
              any$result = true;
              break any$break;
            }
          }
          any$result = false;
        }
         while (false);
        if (!any$result)
          break;
        toAdd.v = new KtName(e.name.value + toString((tmp$_0 = i, i = tmp$_0 + 1 | 0, tmp$_0)));
      }
      extendsTypeParams.add_11rb$(new KtTypeParam(toAdd.v, e.upperBound));
    }
    return extendsTypeParams;
  };
  TsInterfaceToKtExtensions.prototype.merge_9pzgf3$ = function ($receiver, another) {
    if ($receiver == null)
      return another;
    else if (another == null)
      return $receiver;
    else
      return plus($receiver, another);
  };
  TsInterfaceToKtExtensions.prototype.withNativeAnnotation_dk8kn7$ = function ($receiver) {
    var $receiver_0 = this.defaultAnnotations;
    var predicate = IS_NATIVE_ANNOTATION;
    var any$result;
    any$break: do {
      var tmp$;
      if (Kotlin.isType($receiver_0, Collection) && $receiver_0.isEmpty()) {
        any$result = false;
        break any$break;
      }
      tmp$ = $receiver_0.iterator();
      while (tmp$.hasNext()) {
        var element = tmp$.next();
        if (predicate(element)) {
          any$result = true;
          break any$break;
        }
      }
      any$result = false;
    }
     while (false);
    var tmp$_0 = any$result;
    if (!tmp$_0) {
      var predicate_0 = IS_NATIVE_ANNOTATION;
      var any$result_0;
      any$break: do {
        var tmp$_1;
        if (Kotlin.isType($receiver, Collection) && $receiver.isEmpty()) {
          any$result_0 = false;
          break any$break;
        }
        tmp$_1 = $receiver.iterator();
        while (tmp$_1.hasNext()) {
          var element_0 = tmp$_1.next();
          if (predicate_0(element_0)) {
            any$result_0 = true;
            break any$break;
          }
        }
        any$result_0 = false;
      }
       while (false);
      tmp$_0 = any$result_0;
    }
    if (tmp$_0)
      return $receiver;
    else {
      var list = ArrayList_init();
      list.add_11rb$(NATIVE_ANNOTATION);
      list.addAll_brywnq$($receiver);
      return list;
    }
  };
  TsInterfaceToKtExtensions.prototype.addVariable_x4qmk8$$default = function (symbol, name, type, extendsType, typeParams, isVar, needsNoImpl, additionalAnnotations, isOverride) {
    var typeParamsWithoutClashes = this.fixIfClashWith_9pzgf3$(this.typeParams, typeParams);
    var actualExtendsType = typeParamsWithoutClashes === this.typeParams ? this.cachedExtendsType : this.getExtendsType_0(typeParamsWithoutClashes);
    var annotations = this.withNativeAnnotation_dk8kn7$(additionalAnnotations);
    this.addVariable_x4qmk8$(symbol, name, type, actualExtendsType, this.merge_9pzgf3$(typeParamsWithoutClashes, typeParams), isVar, true, annotations, isOverride, TsInterfaceToKt.prototype.addVariable_x4qmk8$$default.bind(this));
  };
  TsInterfaceToKtExtensions.prototype.addFunction_3b8o0j$$default = function (symbol, name, callSignature, extendsType, needsNoImpl, additionalAnnotations, isOverride, isOperator) {
    var typeParamsWithoutClashes = this.fixIfClashWith_9pzgf3$(this.typeParams, callSignature.typeParams);
    var actualExtendsType = typeParamsWithoutClashes === this.typeParams ? this.cachedExtendsType : this.getExtendsType_0(typeParamsWithoutClashes);
    var annotations = this.withNativeAnnotation_dk8kn7$(additionalAnnotations);
    this.addFunction_3b8o0j$(symbol, name, new KtCallSignature(callSignature.params, this.merge_9pzgf3$(typeParamsWithoutClashes, callSignature.typeParams), callSignature.returnType), actualExtendsType, true, annotations, isOverride, isOperator, TsInterfaceToKt.prototype.addFunction_3b8o0j$$default.bind(this));
  };
  function TsInterfaceToKtExtensions$cachedExtendsType$lambda(this$TsInterfaceToKtExtensions) {
    return function () {
      return this$TsInterfaceToKtExtensions.getExtendsType_0(this$TsInterfaceToKtExtensions.typeParams);
    };
  }
  TsInterfaceToKtExtensions.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'TsInterfaceToKtExtensions',
    interfaces: [TsInterfaceToKt]
  };
  var NATIVE;
  var NATIVE_ANNOTATION;
  var NATIVE_GETTER_ANNOTATION;
  var NATIVE_SETTER_ANNOTATION;
  var NATIVE_INVOKE_ANNOTATION;
  var DEFAULT_ANNOTATION;
  var NO_ANNOTATIONS;
  var INVOKE;
  var GET;
  var SET;
  function COMPARE_BY_NAME$lambda(a, b) {
    var tmp$;
    return (tmp$ = a.name) != null ? tmp$.equals(b.name) : null;
  }
  var COMPARE_BY_NAME;
  function IS_NATIVE_ANNOTATION$lambda(a) {
    var tmp$;
    return (tmp$ = a.name) != null ? tmp$.equals(NATIVE) : null;
  }
  var IS_NATIVE_ANNOTATION;
  function TypeScriptToKotlin(context, currentPackagePartBuilder, typeChecker, declarations, defaultAnnotations, requiredModifier, typeMapper, isInterface, isOwnDeclaration, isOverride, isOverrideProperty, qualifier) {
    if (requiredModifier === void 0)
      requiredModifier = SyntaxKind$DeclareKeyword;
    if (isInterface === void 0)
      isInterface = false;
    if (isOwnDeclaration === void 0)
      isOwnDeclaration = TypeScriptToKotlin_init$lambda;
    if (qualifier === void 0) {
      qualifier = emptyList();
    }
    TypeScriptToKotlinBase.call(this, declarations, context.declarations);
    this.context_0 = context;
    this.currentPackagePartBuilder_0 = currentPackagePartBuilder;
    this.typeChecker_0 = typeChecker;
    this.defaultAnnotations_2umpc4$_0 = defaultAnnotations;
    this.requiredModifier = requiredModifier;
    this.typeMapper = typeMapper;
    this.isInterface_8sh96u$_0 = isInterface;
    this.isOwnDeclaration = isOwnDeclaration;
    this.isOverride = isOverride;
    this.isOverrideProperty = isOverrideProperty;
    this.qualifier_0 = qualifier;
    this.hasMembersOpenModifier_aofgqp$_0 = false;
  }
  Object.defineProperty(TypeScriptToKotlin.prototype, 'defaultAnnotations', {
    get: function () {
      return this.defaultAnnotations_2umpc4$_0;
    }
  });
  Object.defineProperty(TypeScriptToKotlin.prototype, 'isInterface', {
    get: function () {
      return this.isInterface_8sh96u$_0;
    }
  });
  Object.defineProperty(TypeScriptToKotlin.prototype, 'hasMembersOpenModifier', {
    get: function () {
      return this.hasMembersOpenModifier_aofgqp$_0;
    }
  });
  TypeScriptToKotlin.prototype.getAdditionalAnnotations_uvf806$ = function (node) {
    var tmp$, tmp$_0, tmp$_1;
    var tmp$_2 = this.requiredModifier === SyntaxKind$DeclareKeyword;
    if (tmp$_2) {
      var tmp$_3;
      if ((tmp$_0 = (tmp$ = node.modifiers) != null ? tmp$ : null) != null) {
        var any$result;
        any$break: do {
          var tmp$_4;
          for (tmp$_4 = 0; tmp$_4 !== tmp$_0.length; ++tmp$_4) {
            var element = tmp$_0[tmp$_4];
            if (element.kind === this.requiredModifier) {
              any$result = true;
              break any$break;
            }
          }
          any$result = false;
        }
         while (false);
        tmp$_3 = any$result;
      }
       else
        tmp$_3 = null;
      tmp$_2 = !((tmp$_1 = tmp$_3) != null ? tmp$_1 : false);
    }
    var isShouldSkip = tmp$_2;
    if (isShouldSkip)
      return DEFAULT_FAKE_ANNOTATION;
    return NO_ANNOTATIONS;
  };
  TypeScriptToKotlin.prototype.visitTypeAliasDeclaration_it7xrc$ = function (node) {
    var tmp$, tmp$_0;
    if (!equals(node.type.kind, SyntaxKind$TypeLiteral))
      return;
    var translator = new TsInterfaceToKt(this.typeMapper, this.defaultAnnotations, NOT_OVERRIDE, NOT_OVERRIDE);
    forEachChild_0(translator, node.type);
    translator.name = (tmp$ = node.name) != null ? unescapeIdentifier(tmp$.text) : null;
    translator.typeParams = (tmp$_0 = node.typeParameters) != null ? toKotlinTypeParams(tmp$_0, this.typeMapper) : null;
    this.addDeclaration_ahl69t$(this.typeChecker_0.getSymbolAtLocation(node), createClassifier(translator));
  };
  TypeScriptToKotlin.prototype.visitVariableStatement_x0poxd$ = function (node) {
    var tmp$, tmp$_0, tmp$_1, tmp$_2, tmp$_3;
    var additionalAnnotations = this.getAdditionalAnnotations_uvf806$(node);
    var declarations = node.declarationList.declarations;
    for (tmp$ = 0; tmp$ !== declarations.length; ++tmp$) {
      var d = declarations[tmp$];
      var name = ensureNotNull((tmp$_0 = d.name) != null ? asString_0(tmp$_0) : null);
      var symbol = getSymbolResolvingAliases(this.typeChecker_0, d.name);
      if (equals((tmp$_1 = d.type) != null ? tmp$_1.kind : null, SyntaxKind$TypeLiteral)) {
        var asObject = this.tryTranslateTypeLiteralAsObject_0(d, name, additionalAnnotations);
        if (asObject != null) {
          this.addDeclaration_ahl69t$(symbol, asObject);
          return;
        }
      }
      var varType = (tmp$_3 = (tmp$_2 = d.type) != null ? mapType(this.typeMapper, tmp$_2) : null) != null ? tmp$_3 : new KtType(ANY);
      this.addVariable_x4qmk8$(symbol, name, varType, void 0, void 0, void 0, void 0, additionalAnnotations);
    }
  };
  TypeScriptToKotlin.prototype.tryTranslateTypeLiteralAsObject_0 = function (d, name, additionalAnnotations) {
    var translator = new TsClassToKt(this.typeMapper, KtClassKind$OBJECT_getInstance(), plus(this.defaultAnnotations, additionalAnnotations), this.isOverride, this.isOverrideProperty, false, false);
    var typeLiteral = d.type;
    forEachChild_0(translator, typeLiteral);
    if (equals(toStringKey(translator.declarations), ObjectTypeToKotlinTypeMapperImpl$Companion_getInstance().jsonTypeKey))
      return null;
    translator.name = name;
    return ensureNotNull(createClassifier_0(translator));
  };
  TypeScriptToKotlin.prototype.visitFunctionDeclaration_eywj3y$ = function (node) {
    var tmp$, tmp$_0;
    var additionalAnnotations = this.getAdditionalAnnotations_uvf806$(node);
    var name = ensureNotNull((tmp$ = node.name) != null ? asString(tmp$) : null);
    var symbol = (tmp$_0 = node.name) != null ? getSymbolResolvingAliases(this.typeChecker_0, tmp$_0) : null;
    var tmp$_1;
    tmp$_1 = toKotlinCallSignatureOverloads(node, this.typeMapper).iterator();
    while (tmp$_1.hasNext()) {
      var element = tmp$_1.next();
      this.addFunction_3b8o0j$(symbol, name, element, void 0, void 0, additionalAnnotations);
    }
    this.processDefaultExport_0(node, symbol);
  };
  TypeScriptToKotlin.prototype.visitInterfaceDeclaration_f4u3$ = function (node) {
    var tmp$;
    if (!this.isOwnDeclaration.call(this, node.name)) {
      var translator = new TsInterfaceToKtExtensions(this.typeMapper, this.defaultAnnotations, this.isOverride, this.isOverrideProperty);
      translator.visitInterfaceDeclaration_f4u3$(node);
      this.declarations.addAll_brywnq$(translator.declarations);
    }
     else {
      var translator_0 = new TsInterfaceToKt(this.typeMapper, this.defaultAnnotations, this.isOverride, this.isOverrideProperty);
      translator_0.visitInterfaceDeclaration_f4u3$(node);
      var symbol = (tmp$ = node.name) != null ? getSymbolResolvingAliases(this.typeChecker_0, tmp$) : null;
      this.addDeclaration_ahl69t$(symbol, createClassifier(translator_0));
      this.processDefaultExport_0(node, symbol);
    }
  };
  TypeScriptToKotlin.prototype.visitClassDeclaration_4wvyue$ = function (node) {
    var tmp$;
    var additionalAnnotations = this.getAdditionalAnnotations_uvf806$(node);
    var translator = new TsClassToKt(this.typeMapper, void 0, plus(this.defaultAnnotations, additionalAnnotations), this.isOverride, this.isOverrideProperty);
    translator.visitClassDeclaration_4wvyue$(node);
    var result = createClassifier_0(translator);
    if (result != null) {
      var symbol = (tmp$ = node.name) != null ? getSymbolResolvingAliases(this.typeChecker_0, tmp$) : null;
      this.addDeclaration_ahl69t$(symbol, result);
      this.processDefaultExport_0(node, symbol);
    }
  };
  TypeScriptToKotlin.prototype.processDefaultExport_0 = function (node, symbol) {
    var tmp$, tmp$_0;
    var tmp$_1;
    if ((tmp$_0 = (tmp$ = node.modifiers) != null ? tmp$ : null) != null) {
      var any$result;
      any$break: do {
        var tmp$_2;
        for (tmp$_2 = 0; tmp$_2 !== tmp$_0.length; ++tmp$_2) {
          var element = tmp$_0[tmp$_2];
          if (equals(element.kind, SyntaxKind$DefaultKeyword)) {
            any$result = true;
            break any$break;
          }
        }
        any$result = false;
      }
       while (false);
      tmp$_1 = any$result;
    }
     else
      tmp$_1 = null;
    if (tmp$_1 === true) {
      this.addJsNameAnnotation_0(symbol, 'default');
    }
  };
  TypeScriptToKotlin.prototype.addJsNameAnnotation_0 = function (symbol, name) {
    var tmp$;
    if (symbol == null)
      return;
    if ((tmp$ = this.declarationsBySymbol.get_11rb$(symbol)) != null) {
      var tmp$_0;
      tmp$_0 = tmp$.iterator();
      while (tmp$_0.hasNext()) {
        var element = tmp$_0.next();
        element.annotations = plus_0(element.annotations, jsNameAnnotation(name));
      }
    }
  };
  TypeScriptToKotlin.prototype.visitEnumDeclaration_1emvp1$ = function (node) {
    var tmp$;
    var $receiver = node.members;
    var destination = ArrayList_init($receiver.length);
    var tmp$_0;
    for (tmp$_0 = 0; tmp$_0 !== $receiver.length; ++tmp$_0) {
      var item = $receiver[tmp$_0];
      var tmp$_1;
      destination.add_11rb$(new KtEnumEntry(new KtName(ensureNotNull(asString_0(item.name))), (tmp$_1 = item.initializer) != null ? tmp$_1.getText() : null));
    }
    var entries = destination;
    var enumClass = new KtClassifier(KtClassKind$ENUM_getInstance(), new KtName(unescapeIdentifier(node.name.text)), emptyList(), emptyList(), emptyList(), entries, emptyList(), false);
    var symbol = (tmp$ = node.name) != null ? getSymbolResolvingAliases(this.typeChecker_0, tmp$) : null;
    this.addDeclaration_ahl69t$(symbol, enumClass);
  };
  function TypeScriptToKotlin$visitModuleDeclaration$getName(node) {
    var tmp$, tmp$_0, tmp$_1, tmp$_2, tmp$_3;
    var declarationName = ensureNotNull(node.name);
    tmp$_0 = Kotlin.isType(tmp$ = declarationName.kind, Any) ? tmp$ : throwCCE();
    if (equals(tmp$_0, SyntaxKind$Identifier)) {
      tmp$_3 = unescapeIdentifier((Kotlin.isType(tmp$_1 = node.name, Object) ? tmp$_1 : throwCCE()).text);
    }
     else if (equals(tmp$_0, SyntaxKind$StringLiteral)) {
      tmp$_3 = replace(unescapeIdentifier((Kotlin.isType(tmp$_2 = node.name, Object) ? tmp$_2 : throwCCE()).text), 47, 46);
    }
     else {
      reportUnsupportedNode(declarationName);
      tmp$_3 = '???';
    }
    return tmp$_3;
  }
  function TypeScriptToKotlin$visitModuleDeclaration$createPackagePart(closure$packageSymbol, this$TypeScriptToKotlin, closure$ownName) {
    return function () {
      var $receiver = new KtPackagePartBuilder(closure$packageSymbol, this$TypeScriptToKotlin.currentPackagePartBuilder_0, closure$ownName);
      var this$TypeScriptToKotlin_0 = this$TypeScriptToKotlin;
      this$TypeScriptToKotlin_0.currentPackagePartBuilder_0.nestedPackages.add_11rb$($receiver);
      this$TypeScriptToKotlin_0.context_0.packageParts.add_11rb$($receiver);
      return $receiver;
    };
  }
  TypeScriptToKotlin.prototype.visitModuleDeclaration_ezg4eu$ = function (node) {
    var tmp$;
    var additionalAnnotations = this.getAdditionalAnnotations_uvf806$(node);
    var getName = TypeScriptToKotlin$visitModuleDeclaration$getName;
    var body = node.body;
    var ownName = getName(node);
    var newQualifier = plus_0(this.qualifier_0, ownName);
    var packageSymbol = getSymbolResolvingAliases(this.typeChecker_0, node.name);
    var createPackagePart = TypeScriptToKotlin$visitModuleDeclaration$createPackagePart(packageSymbol, this, ownName);
    if (packageSymbol != null) {
      var $receiver = this.context_0.packagePartsBySymbol;
      var tmp$_0;
      var value = $receiver.get_11rb$(packageSymbol);
      if (value == null) {
        var answer = createPackagePart();
        $receiver.put_xwzc9p$(packageSymbol, answer);
        tmp$_0 = answer;
      }
       else {
        tmp$_0 = value;
      }
      tmp$ = tmp$_0;
    }
     else {
      tmp$ = createPackagePart();
    }
    var innerPackagePartBuilder = tmp$;
    if (equals(node.name.kind, SyntaxKind$StringLiteral)) {
      innerPackagePartBuilder.module = node.name.text;
    }
    var innerTypeMapper = new ObjectTypeToKotlinTypeMapperImpl(this.typeChecker_0, additionalAnnotations, innerPackagePartBuilder.members, joinToString(newQualifier, '.'));
    var tr = new TypeScriptToKotlin(this.context_0, innerPackagePartBuilder, this.typeChecker_0, innerPackagePartBuilder.members, additionalAnnotations, SyntaxKind$ExportKeyword, innerTypeMapper, void 0, this.isOwnDeclaration, this.isOverride, this.isOverrideProperty, newQualifier);
    if (equals(body.kind, SyntaxKind$ModuleDeclaration)) {
      tr.visitModuleDeclaration_ezg4eu$(body);
    }
     else {
      tr.visitList_uvf806$(body);
    }
  };
  TypeScriptToKotlin.prototype.visitExportAssignment_fybyfv$ = function (node) {
    var tmp$;
    var symbol = getSymbolResolvingAliases(this.typeChecker_0, node.expression);
    if (node.isExportEquals === true) {
      this.currentPackagePartBuilder_0.exportedSymbol = symbol;
    }
     else {
      var tmp$_0;
      if ((tmp$ = symbol != null ? symbol.declarations : null) != null) {
        var none$result;
        none$break: do {
          var tmp$_1;
          for (tmp$_1 = 0; tmp$_1 !== tmp$.length; ++tmp$_1) {
            var element = tmp$[tmp$_1];
            if ((getCombinedModifierFlags(element) & ModifierFlags$Export) !== 0) {
              none$result = false;
              break none$break;
            }
          }
          none$result = true;
        }
         while (false);
        tmp$_0 = none$result;
      }
       else
        tmp$_0 = null;
      if (tmp$_0 === true) {
        this.addJsNameAnnotation_0(symbol, 'default');
      }
    }
  };
  function TypeScriptToKotlin_init$lambda(it) {
    return true;
  }
  TypeScriptToKotlin.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'TypeScriptToKotlin',
    interfaces: [TypeScriptToKotlinBase]
  };
  function TypeScriptToKotlinBase(declarations, declarationsBySymbol) {
    this.declarations = declarations;
    this.declarationsBySymbol = declarationsBySymbol;
    this.defaultAnnotations_pxp7hp$_0 = emptyList();
  }
  Object.defineProperty(TypeScriptToKotlinBase.prototype, 'defaultAnnotations', {
    get: function () {
      return this.defaultAnnotations_pxp7hp$_0;
    }
  });
  TypeScriptToKotlinBase.prototype.addVariable_x4qmk8$$default = function (symbol, name, type, extendsType, typeParams, isVar, needsNoImpl, additionalAnnotations, isOverride) {
    var annotations = plus(this.defaultAnnotations, additionalAnnotations);
    this.addDeclaration_ahl69t$(symbol, new KtVariable(new KtName(name), new KtTypeAnnotation(type), extendsType != null ? new KtHeritageType(extendsType) : null, annotations, typeParams, isVar, needsNoImpl, this.isInterface, isOverride, this.hasMembersOpenModifier));
  };
  TypeScriptToKotlinBase.prototype.addVariable_x4qmk8$ = function (symbol, name, type, extendsType, typeParams, isVar, needsNoImpl, additionalAnnotations, isOverride, callback$default) {
    if (extendsType === void 0)
      extendsType = null;
    if (typeParams === void 0)
      typeParams = null;
    if (isVar === void 0)
      isVar = true;
    if (needsNoImpl === void 0)
      needsNoImpl = true;
    if (additionalAnnotations === void 0) {
      additionalAnnotations = emptyList();
    }
    if (isOverride === void 0)
      isOverride = false;
    callback$default ? callback$default(symbol, name, type, extendsType, typeParams, isVar, needsNoImpl, additionalAnnotations, isOverride) : this.addVariable_x4qmk8$$default(symbol, name, type, extendsType, typeParams, isVar, needsNoImpl, additionalAnnotations, isOverride);
  };
  TypeScriptToKotlinBase.prototype.addFunction_3b8o0j$$default = function (symbol, name, callSignature, extendsType, needsNoImpl, additionalAnnotations, isOverride, isOperator) {
    var annotations = plus(this.defaultAnnotations, additionalAnnotations);
    this.addDeclaration_ahl69t$(symbol, new KtFunction(new KtName(name), callSignature, extendsType != null ? new KtHeritageType(extendsType) : null, annotations, needsNoImpl, isOverride, this.hasMembersOpenModifier, isOperator));
  };
  TypeScriptToKotlinBase.prototype.addFunction_3b8o0j$ = function (symbol, name, callSignature, extendsType, needsNoImpl, additionalAnnotations, isOverride, isOperator, callback$default) {
    if (extendsType === void 0)
      extendsType = null;
    if (needsNoImpl === void 0)
      needsNoImpl = true;
    if (additionalAnnotations === void 0) {
      additionalAnnotations = emptyList();
    }
    if (isOverride === void 0)
      isOverride = false;
    if (isOperator === void 0)
      isOperator = false;
    callback$default ? callback$default(symbol, name, callSignature, extendsType, needsNoImpl, additionalAnnotations, isOverride, isOperator) : this.addFunction_3b8o0j$$default(symbol, name, callSignature, extendsType, needsNoImpl, additionalAnnotations, isOverride, isOperator);
  };
  TypeScriptToKotlinBase.prototype.addDeclaration_ahl69t$ = function (symbol, declaration) {
    this.declarations.add_11rb$(declaration);
    if (symbol != null) {
      var $receiver = this.declarationsBySymbol;
      var tmp$;
      var value = $receiver.get_11rb$(symbol);
      if (value == null) {
        var answer = ArrayList_init();
        $receiver.put_xwzc9p$(symbol, answer);
        tmp$ = answer;
      }
       else {
        tmp$ = value;
      }
      var values = tmp$;
      values.add_11rb$(declaration);
    }
  };
  TypeScriptToKotlinBase.prototype.visitList_uvf806$ = function (node) {
    forEachChild_0(this, node);
  };
  TypeScriptToKotlinBase.prototype.visitImportEqualsDeclaration_p9svv6$ = function (node) {
  };
  TypeScriptToKotlinBase.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'TypeScriptToKotlinBase',
    interfaces: [Visitor]
  };
  function createClassifier($receiver) {
    return new KtClassifier(KtClassKind$INTERFACE_getInstance(), new KtName(ensureNotNull($receiver.name)), emptyList(), $receiver.typeParams, $receiver.parents, $receiver.declarations, $receiver.annotations, false);
  }
  function createClassifier_0($receiver) {
    var tmp$, tmp$_0;
    if ($receiver.name == null)
      return null;
    var tmp$_1;
    if ((tmp$ = $receiver.staticTranslator) != null) {
      var $receiver_0 = ArrayList_init();
      addAll($receiver_0, $receiver.declarations);
      var element = ensureNotNull(createClassifier_0(tmp$));
      $receiver_0.add_11rb$(element);
      tmp$_1 = $receiver_0;
    }
     else
      tmp$_1 = null;
    var members = (tmp$_0 = tmp$_1) != null ? tmp$_0 : $receiver.declarations;
    return new KtClassifier($receiver.kind, new KtName(ensureNotNull($receiver.name)), $receiver.paramsOfConstructors, $receiver.typeParams, $receiver.parents, members, $receiver.annotations, $receiver.kind === KtClassKind$CLASS_getInstance());
  }
  var JS_MODULE;
  var JS_QUALIFIER;
  var JS_NAME;
  function moduleAnnotation(moduleName) {
    return new KtAnnotation(JS_MODULE, listOf(new KtArgument('"' + moduleName + '"')));
  }
  function jsNameAnnotation(name) {
    return new KtAnnotation(JS_NAME, listOf(new KtArgument('"' + name + '"')));
  }
  function asString($receiver) {
    var tmp$;
    tmp$ = $receiver.kind;
    if (equals(tmp$, SyntaxKind$Identifier)) {
      return unescapeIdentifier($receiver.text);
    }
     else if (equals(tmp$, SyntaxKind$NumericLiteral)) {
      return $receiver.text;
    }
     else {
      reportUnsupportedNode($receiver);
      return null;
    }
  }
  function asString_0($receiver) {
    var tmp$;
    tmp$ = $receiver.kind;
    if (equals(tmp$, SyntaxKind$Identifier)) {
      return unescapeIdentifier($receiver.text);
    }
     else if (equals(tmp$, SyntaxKind$ObjectBindingPattern)) {
      return $receiver.parent.symbol.escapedName;
    }
     else {
      reportUnsupportedNode($receiver);
      return null;
    }
  }
  function ObjectTypeToKotlinTypeMapper() {
  }
  ObjectTypeToKotlinTypeMapper.$metadata$ = {
    kind: Kind_INTERFACE,
    simpleName: 'ObjectTypeToKotlinTypeMapper',
    interfaces: []
  };
  var LinkedHashSet_init = Kotlin.kotlin.collections.LinkedHashSet_init_287e2$;
  function ObjectTypeToKotlinTypeMapperImpl(typeChecker, defaultAnnotations, declarations, currentPackage, typeParameterDeclarations, cache) {
    ObjectTypeToKotlinTypeMapperImpl$Companion_getInstance();
    if (typeParameterDeclarations === void 0) {
      typeParameterDeclarations = emptyList();
    }
    if (cache === void 0) {
      cache = HashMap_init();
    }
    this.typeChecker_w03o97$_0 = typeChecker;
    this.defaultAnnotations = defaultAnnotations;
    this.declarations = declarations;
    this.currentPackage_umr5xd$_0 = currentPackage;
    this.typeParameterDeclarations = typeParameterDeclarations;
    this.cache = cache;
    this.typesInMappingProcess_se5g3d$_0 = LinkedHashSet_init();
    var $receiver = this.cache;
    var value = new KtType(KtQualifiedName_init('Any'));
    $receiver.put_xwzc9p$('', value);
    var $receiver_0 = this.cache;
    var key = ObjectTypeToKotlinTypeMapperImpl$Companion_getInstance().jsonTypeKey;
    var value_0 = new KtType(KtQualifiedName_init('Json'));
    $receiver_0.put_xwzc9p$(key, value_0);
  }
  Object.defineProperty(ObjectTypeToKotlinTypeMapperImpl.prototype, 'typeChecker', {
    get: function () {
      return this.typeChecker_w03o97$_0;
    }
  });
  Object.defineProperty(ObjectTypeToKotlinTypeMapperImpl.prototype, 'currentPackage', {
    get: function () {
      return this.currentPackage_umr5xd$_0;
    }
  });
  Object.defineProperty(ObjectTypeToKotlinTypeMapperImpl.prototype, 'typesInMappingProcess', {
    get: function () {
      return this.typesInMappingProcess_se5g3d$_0;
    }
  });
  function ObjectTypeToKotlinTypeMapperImpl$Companion() {
    ObjectTypeToKotlinTypeMapperImpl$Companion_instance = this;
    this.n_0 = 0;
    this.jsonTypeKey = trimIndent('\n                @nativeGetter\n                operator fun get(String): Any?\n                @nativeSetter\n                operator fun set(String, Any)\n\n                ');
  }
  ObjectTypeToKotlinTypeMapperImpl$Companion.prototype.reset = function () {
    this.n_0 = 0;
  };
  ObjectTypeToKotlinTypeMapperImpl$Companion.$metadata$ = {
    kind: Kind_OBJECT,
    simpleName: 'Companion',
    interfaces: []
  };
  var ObjectTypeToKotlinTypeMapperImpl$Companion_instance = null;
  function ObjectTypeToKotlinTypeMapperImpl$Companion_getInstance() {
    if (ObjectTypeToKotlinTypeMapperImpl$Companion_instance === null) {
      new ObjectTypeToKotlinTypeMapperImpl$Companion();
    }
    return ObjectTypeToKotlinTypeMapperImpl$Companion_instance;
  }
  ObjectTypeToKotlinTypeMapperImpl.prototype.getKotlinTypeForObjectType_29gnwt$ = function (objectType) {
    var tmp$;
    var translator = new TsInterfaceToKt(this, this.defaultAnnotations, NOT_OVERRIDE, NOT_OVERRIDE);
    forEachChild_0(translator, objectType);
    var typeKey = toStringKey(translator.declarations);
    var cachedTraitType = this.cache.get_11rb$(typeKey);
    if (cachedTraitType != null)
      return cachedTraitType;
    var $receiver = translator.declarations;
    var destination = ArrayList_init();
    var tmp$_0;
    tmp$_0 = $receiver.iterator();
    while (tmp$_0.hasNext()) {
      var element = tmp$_0.next();
      var transform$result;
      if (Kotlin.isType(element, KtVariable)) {
        transform$result = listOf(element.type.type.qualifiedName);
      }
       else if (Kotlin.isType(element, KtFunction)) {
        var $receiver_0 = element.callSignature.params;
        var destination_0 = ArrayList_init(collectionSizeOrDefault($receiver_0, 10));
        var tmp$_1;
        tmp$_1 = $receiver_0.iterator();
        while (tmp$_1.hasNext()) {
          var item = tmp$_1.next();
          destination_0.add_11rb$(item.type.type.qualifiedName);
        }
        transform$result = plus_0(destination_0, element.callSignature.returnType.type.qualifiedName);
      }
       else {
        transform$result = emptyList();
      }
      var list = transform$result;
      addAll(destination, list);
    }
    var usedTypeParams = distinct(destination);
    var $receiver_1 = this.typeParameterDeclarations;
    var destination_1 = ArrayList_init();
    var tmp$_2;
    tmp$_2 = $receiver_1.iterator();
    while (tmp$_2.hasNext()) {
      var element_0 = tmp$_2.next();
      if (usedTypeParams.contains_11rb$(KtQualifiedName_init(element_0.name.text)))
        destination_1.add_11rb$(element_0);
    }
    var destination_2 = ArrayList_init(collectionSizeOrDefault(destination_1, 10));
    var tmp$_3;
    tmp$_3 = destination_1.iterator();
    while (tmp$_3.hasNext()) {
      var item_0 = tmp$_3.next();
      destination_2.add_11rb$(item_0.name.text);
    }
    var typeParamNames = destination_2;
    var traitName = 'T' + '$' + (tmp$ = ObjectTypeToKotlinTypeMapperImpl$Companion_getInstance().n_0, ObjectTypeToKotlinTypeMapperImpl$Companion_getInstance().n_0 = tmp$ + 1 | 0, tmp$);
    var tmp$_4 = KtQualifiedName_init(traitName);
    var destination_3 = ArrayList_init(collectionSizeOrDefault(typeParamNames, 10));
    var tmp$_5;
    tmp$_5 = typeParamNames.iterator();
    while (tmp$_5.hasNext()) {
      var item_1 = tmp$_5.next();
      destination_3.add_11rb$(new KtType(KtQualifiedName_init(item_1)));
    }
    var traitType = new KtType(tmp$_4, destination_3);
    translator.name = traitName;
    var destination_4 = ArrayList_init(collectionSizeOrDefault(typeParamNames, 10));
    var tmp$_6;
    tmp$_6 = typeParamNames.iterator();
    while (tmp$_6.hasNext()) {
      var item_2 = tmp$_6.next();
      destination_4.add_11rb$(new KtTypeParam(new KtName(item_2)));
    }
    translator.typeParams = destination_4;
    this.declarations.add_11rb$(createClassifier(translator));
    this.cache.put_xwzc9p$(typeKey, traitType);
    return traitType;
  };
  ObjectTypeToKotlinTypeMapperImpl.prototype.withTypeParameters_le0eav$ = function (typeParameters) {
    var tmp$;
    return this.copy_kaikd7$(void 0, void 0, void 0, void 0, plus_1(toList_1(this.typeParameterDeclarations), (tmp$ = typeParameters != null ? typeParameters : null) != null ? tmp$ : []));
  };
  ObjectTypeToKotlinTypeMapperImpl.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'ObjectTypeToKotlinTypeMapperImpl',
    interfaces: [ObjectTypeToKotlinTypeMapper]
  };
  ObjectTypeToKotlinTypeMapperImpl.prototype.component1 = function () {
    return this.typeChecker;
  };
  ObjectTypeToKotlinTypeMapperImpl.prototype.component2 = function () {
    return this.defaultAnnotations;
  };
  ObjectTypeToKotlinTypeMapperImpl.prototype.component3 = function () {
    return this.declarations;
  };
  ObjectTypeToKotlinTypeMapperImpl.prototype.component4 = function () {
    return this.currentPackage;
  };
  ObjectTypeToKotlinTypeMapperImpl.prototype.component5 = function () {
    return this.typeParameterDeclarations;
  };
  ObjectTypeToKotlinTypeMapperImpl.prototype.component6 = function () {
    return this.cache;
  };
  ObjectTypeToKotlinTypeMapperImpl.prototype.copy_kaikd7$ = function (typeChecker, defaultAnnotations, declarations, currentPackage, typeParameterDeclarations, cache) {
    return new ObjectTypeToKotlinTypeMapperImpl(typeChecker === void 0 ? this.typeChecker : typeChecker, defaultAnnotations === void 0 ? this.defaultAnnotations : defaultAnnotations, declarations === void 0 ? this.declarations : declarations, currentPackage === void 0 ? this.currentPackage : currentPackage, typeParameterDeclarations === void 0 ? this.typeParameterDeclarations : typeParameterDeclarations, cache === void 0 ? this.cache : cache);
  };
  ObjectTypeToKotlinTypeMapperImpl.prototype.toString = function () {
    return 'ObjectTypeToKotlinTypeMapperImpl(typeChecker=' + Kotlin.toString(this.typeChecker) + (', defaultAnnotations=' + Kotlin.toString(this.defaultAnnotations)) + (', declarations=' + Kotlin.toString(this.declarations)) + (', currentPackage=' + Kotlin.toString(this.currentPackage)) + (', typeParameterDeclarations=' + Kotlin.toString(this.typeParameterDeclarations)) + (', cache=' + Kotlin.toString(this.cache)) + ')';
  };
  ObjectTypeToKotlinTypeMapperImpl.prototype.hashCode = function () {
    var result = 0;
    result = result * 31 + Kotlin.hashCode(this.typeChecker) | 0;
    result = result * 31 + Kotlin.hashCode(this.defaultAnnotations) | 0;
    result = result * 31 + Kotlin.hashCode(this.declarations) | 0;
    result = result * 31 + Kotlin.hashCode(this.currentPackage) | 0;
    result = result * 31 + Kotlin.hashCode(this.typeParameterDeclarations) | 0;
    result = result * 31 + Kotlin.hashCode(this.cache) | 0;
    return result;
  };
  ObjectTypeToKotlinTypeMapperImpl.prototype.equals = function (other) {
    return this === other || (other !== null && (typeof other === 'object' && (Object.getPrototypeOf(this) === Object.getPrototypeOf(other) && (Kotlin.equals(this.typeChecker, other.typeChecker) && Kotlin.equals(this.defaultAnnotations, other.defaultAnnotations) && Kotlin.equals(this.declarations, other.declarations) && Kotlin.equals(this.currentPackage, other.currentPackage) && Kotlin.equals(this.typeParameterDeclarations, other.typeParameterDeclarations) && Kotlin.equals(this.cache, other.cache)))));
  };
  function merge($receiver) {
    var destination = LinkedHashMap_init();
    var tmp$;
    tmp$ = $receiver.iterator();
    while (tmp$.hasNext()) {
      var element = tmp$.next();
      var key = element.fqName;
      var tmp$_0;
      var value = destination.get_11rb$(key);
      if (value == null) {
        var answer = ArrayList_init();
        destination.put_xwzc9p$(key, answer);
        tmp$_0 = answer;
      }
       else {
        tmp$_0 = value;
      }
      var list = tmp$_0;
      list.add_11rb$(element);
    }
    var destination_0 = ArrayList_init(destination.size);
    var tmp$_1;
    tmp$_1 = destination.entries.iterator();
    while (tmp$_1.hasNext()) {
      var item = tmp$_1.next();
      var tmp$_2 = destination_0.add_11rb$;
      var parts = item.value;
      var fqName = first(parts).fqName;
      var destination_1 = ArrayList_init();
      var tmp$_3;
      tmp$_3 = parts.iterator();
      while (tmp$_3.hasNext()) {
        var element_0 = tmp$_3.next();
        var list_0 = element_0.members;
        addAll(destination_1, list_0);
      }
      var members = destination_1;
      var destination_2 = ArrayList_init();
      var tmp$_4;
      tmp$_4 = parts.iterator();
      while (tmp$_4.hasNext()) {
        var element_1 = tmp$_4.next();
        var list_1 = element_1.annotations;
        addAll(destination_2, list_1);
      }
      var annotations = distinct(destination_2);
      var mergedMembers = mergeDeclarationsWithSameNameIfNeed(members);
      tmp$_2.call(destination_0, new KtPackagePart(fqName, mergedMembers, mergeAnnotations_0(annotations)));
    }
    return destination_0;
  }
  function mergeDeclarationsWithSameNameIfNeed$lambda(it) {
    return !Kotlin.isType(it, KtFunction);
  }
  function mergeDeclarationsWithSameNameIfNeed$lambda_0(a, b) {
    var tmp$;
    if (Kotlin.isType(a, KtClassifier)) {
      if (Kotlin.isType(b, KtClassifier))
        tmp$ = mergeClassifiers(a, b);
      else if (Kotlin.isType(b, KtVariable))
        tmp$ = mergeClassifierAndVariable(a, b);
      else {
        report('Merging ' + a.kind + ' and ??? unsupported yet, a: ' + stringify(a) + ', b: ' + stringify(b));
        tmp$ = null;
      }
    }
     else if (Kotlin.isType(a, KtVariable)) {
      if (Kotlin.isType(b, KtClassifier))
        tmp$ = mergeClassifierAndVariable(b, a);
      else {
        report('Merging Variable and ??? unsupported yet, a: ' + stringify(a) + ', b: ' + stringify(b));
        tmp$ = null;
      }
    }
     else {
      report('Unsupported types for merging, a: ' + stringify(a) + ', b: ' + stringify(b));
      tmp$ = null;
    }
    var result = tmp$;
    var tmp$_0;
    if (result != null) {
      result.annotations = mergeAnnotations(a.annotations, b.annotations);
      tmp$_0 = result;
    }
     else
      tmp$_0 = null;
    return tmp$_0;
  }
  function mergeDeclarationsWithSameNameIfNeed($receiver) {
    return merge_0($receiver, mergeDeclarationsWithSameNameIfNeed$lambda, COMPARE_BY_NAME, mergeDeclarationsWithSameNameIfNeed$lambda_0);
  }
  function mergeClassifiers(a, b) {
    switch (a.kind.name) {
      case 'CLASS':
        switch (b.kind.name) {
          case 'OBJECT':
            return mergeClassAndObject(a, b);
          case 'INTERFACE':
            return mergeClassAndInterface(a, b);
        }

        break;
      case 'INTERFACE':
        switch (b.kind.name) {
          case 'OBJECT':
            return mergeClassAndObject(a, b);
          case 'INTERFACE':
            return mergeClassifierMembers(a, [b]);
          case 'CLASS':
            return mergeClassAndInterface(b, a);
        }

        break;
      case 'OBJECT':
        if (b.kind === KtClassKind$CLASS_getInstance() || b.kind === KtClassKind$INTERFACE_getInstance())
          return mergeClassAndObject(b, a);
        if (hasModuleAnnotation(a) && isModule(b))
          return mergeClassifierMembers(a, [b]);
        break;
      default:break;
    }
    report('Merging ' + a.kind + ' and ' + b.kind + ' unsupported yet, a: ' + stringify(a) + ', b: ' + stringify(b));
    return null;
  }
  function mergeClassAndInterface(klass, iface) {
    if (!equals(klass.typeParams, iface.typeParams)) {
      report("Can't merge classifiers with different type parameters -- klass: " + stringify(klass) + ', iface: ' + stringify(iface));
      return null;
    }
    var result = new KtClassifier(KtClassKind$CLASS_getInstance(), klass.name, klass.paramsOfConstructors, klass.typeParams, distinct(plus(klass.parents, iface.parents)), ArrayList_init(), ArrayList_init(), klass.hasOpenModifier);
    return mergeClassifierMembers(result, [klass, iface]);
  }
  function mergeClassifierAndVariable(a, b) {
    assert(getClassObject(a) == null, 'Unxpected `class object` when merge Classifier(kind=' + a.kind + ') and Variable(' + stringify(b) + ')');
    if (a.kind === KtClassKind$INTERFACE_getInstance() || isModule(a)) {
      var newTrait = new KtClassifier(KtClassKind$INTERFACE_getInstance(), a.name, a.paramsOfConstructors, a.typeParams, a.parents, a.members, a.annotations, false);
      var delegation = listOf(new KtHeritageType(b.type.type, NO_IMPL));
      var classObject = new KtClassifier(KtClassKind$COMPANION_OBJECT_getInstance(), KtName$Companion_getInstance().NO_NAME, emptyList(), emptyList(), delegation, emptyList(), emptyList(), false);
      addMember(newTrait, classObject);
      return newTrait;
    }
    report('Merging non-empty Classifier(kind=' + a.kind + ') and Variable unsupported yet, a: ' + stringify(a) + ', b: ' + stringify(b));
    return null;
  }
  function mergeAnnotations(a, b) {
    if (a.isEmpty())
      return b;
    else if (b.isEmpty())
      return a;
    else
      return mergeAnnotations_0(plus(a, b));
  }
  function mergeAnnotations$lambda(it) {
    return true;
  }
  function mergeAnnotations$lambda_0(a, b) {
    if (a.parameters.isEmpty())
      return b;
    else if (b.parameters.isEmpty())
      return a;
    else if (equals(a.parameters, b.parameters))
      return a;
    else {
      report('Merging annotations with different arguments unsupported yet, a: ' + stringify(a) + ', b: ' + stringify(b));
      return null;
    }
  }
  function mergeAnnotations_0(annotations) {
    return merge_0(annotations, mergeAnnotations$lambda, COMPARE_BY_NAME, mergeAnnotations$lambda_0);
  }
  function mergeClassAndObject(a, b) {
    var classObject = getClassObject(a);
    if (classObject == null) {
      addMember(a, new KtClassifier(KtClassKind$COMPANION_OBJECT_getInstance(), KtName$Companion_getInstance().NO_NAME, emptyList(), emptyList(), emptyList(), b.members, NO_ANNOTATIONS, false));
    }
     else {
      addMembersFrom(classObject, b);
    }
    return a;
  }
  function mergeClassifierMembers(a, other) {
    var tmp$;
    for (tmp$ = 0; tmp$ !== other.length; ++tmp$) {
      var b = other[tmp$];
      addMembersFrom(a, b);
    }
    return a;
  }
  function addMembersFrom($receiver, another) {
    var tmp$;
    var members = Kotlin.isType(tmp$ = $receiver.members, MutableList) ? tmp$ : throwCCE();
    members.addAll_brywnq$(another.members);
    mergeDeclarationsWithSameNameIfNeed(members);
  }
  function addMember($receiver, member) {
    var tmp$;
    (Kotlin.isType(tmp$ = $receiver.members, MutableList) ? tmp$ : throwCCE()).add_11rb$(member);
  }
  var mapCapacity = Kotlin.kotlin.collections.mapCapacity_za3lpa$;
  var coerceAtLeast = Kotlin.kotlin.ranges.coerceAtLeast_dqglrj$;
  var LinkedHashMap_init_0 = Kotlin.kotlin.collections.LinkedHashMap_init_xf5xz2$;
  function mergeClassesAndPackages($receiver) {
    var tmp$, tmp$_0;
    var $receiver_0 = $receiver.members;
    var destination = ArrayList_init();
    var tmp$_1;
    tmp$_1 = $receiver_0.iterator();
    while (tmp$_1.hasNext()) {
      var element = tmp$_1.next();
      if (Kotlin.isType(element, KtClassifier))
        destination.add_11rb$(element);
    }
    var destination_0 = ArrayList_init();
    var tmp$_2;
    tmp$_2 = destination.iterator();
    while (tmp$_2.hasNext()) {
      var element_0 = tmp$_2.next();
      if (element_0.kind === KtClassKind$CLASS_getInstance() || element_0.kind === KtClassKind$INTERFACE_getInstance())
        destination_0.add_11rb$(element_0);
    }
    var capacity = coerceAtLeast(mapCapacity(collectionSizeOrDefault(destination_0, 10)), 16);
    var destination_1 = LinkedHashMap_init_0(capacity);
    var tmp$_3;
    tmp$_3 = destination_0.iterator();
    while (tmp$_3.hasNext()) {
      var element_1 = tmp$_3.next();
      destination_1.put_xwzc9p$(element_1.name, element_1);
    }
    var classesByName = destination_1;
    tmp$ = $receiver.nestedPackages.iterator();
    while (tmp$.hasNext()) {
      var nestedPackage = tmp$.next();
      if (!nestedPackage.nestedPackages.isEmpty())
        continue;
      tmp$_0 = classesByName.get_11rb$(new KtName(nestedPackage.ownName));
      if (tmp$_0 == null) {
        continue;
      }
      var classToMerge = tmp$_0;
      var $receiver_1 = classToMerge.members;
      var destination_2 = ArrayList_init();
      var tmp$_4;
      tmp$_4 = $receiver_1.iterator();
      while (tmp$_4.hasNext()) {
        var element_2 = tmp$_4.next();
        if (Kotlin.isType(element_2, KtClassifier))
          destination_2.add_11rb$(element_2);
      }
      var singleOrNull$result;
      singleOrNull$break: do {
        var tmp$_5;
        var single = null;
        var found = false;
        tmp$_5 = destination_2.iterator();
        while (tmp$_5.hasNext()) {
          var element_3 = tmp$_5.next();
          if (element_3.kind === KtClassKind$COMPANION_OBJECT_getInstance()) {
            if (found) {
              singleOrNull$result = null;
              break singleOrNull$break;
            }
            single = element_3;
            found = true;
          }
        }
        if (!found) {
          singleOrNull$result = null;
          break singleOrNull$break;
        }
        singleOrNull$result = single;
      }
       while (false);
      var companion = singleOrNull$result;
      var companionFound = companion != null;
      if (companion == null) {
        companion = new KtClassifier(KtClassKind$COMPANION_OBJECT_getInstance(), KtName$Companion_getInstance().NO_NAME, emptyList(), null, emptyList(), emptyList(), emptyList(), false);
      }
      var $receiver_2 = nestedPackage.members;
      var tmp$_6;
      var first = ArrayList_init();
      var second = ArrayList_init();
      tmp$_6 = $receiver_2.iterator();
      while (tmp$_6.hasNext()) {
        var element_4 = tmp$_6.next();
        if (Kotlin.isType(element_4, KtClassifier)) {
          first.add_11rb$(element_4);
        }
         else {
          second.add_11rb$(element_4);
        }
      }
      var tmp$_7 = new Pair(first, second);
      var classifiers = tmp$_7.component1()
      , nonClassifiers = tmp$_7.component2();
      companion.members = plus(companion.members, nonClassifiers);
      classToMerge.members = plus(classToMerge.members, classifiers);
      var tmp$_8 = !companionFound;
      if (tmp$_8) {
        tmp$_8 = !companion.members.isEmpty();
      }
      if (tmp$_8) {
        classToMerge.members = plus_0(classToMerge.members, companion);
      }
      nestedPackage.members.clear();
    }
  }
  function withMissedOverloads($receiver) {
    var destination = ArrayList_init(collectionSizeOrDefault($receiver, 10));
    var tmp$;
    tmp$ = $receiver.iterator();
    while (tmp$.hasNext()) {
      var item = tmp$.next();
      destination.add_11rb$(withMissedOverloads_0(item));
    }
    return destination;
  }
  function withMissedOverloads_0($receiver) {
    var $receiver_0 = $receiver.members;
    var destination = ArrayList_init(collectionSizeOrDefault($receiver_0, 10));
    var tmp$;
    tmp$ = $receiver_0.iterator();
    while (tmp$.hasNext()) {
      var item = tmp$.next();
      var tmp$_0 = destination.add_11rb$;
      var transform$result;
      var tmp$_1;
      if (Kotlin.isType(item, KtWithMembers)) {
        transform$result = Kotlin.isType(tmp$_1 = withMissedOverloads_0(item), KtMember) ? tmp$_1 : throwCCE();
      }
       else {
        transform$result = item;
      }
      tmp$_0.call(destination, transform$result);
    }
    $receiver.members = withMissedOverloads_1($receiver.members);
    return $receiver;
  }
  function withMissedOverloads$hasDefaultParameters($receiver) {
    var any$result;
    any$break: do {
      var tmp$;
      if (Kotlin.isType($receiver, Collection) && $receiver.isEmpty()) {
        any$result = false;
        break any$break;
      }
      tmp$ = $receiver.iterator();
      while (tmp$.hasNext()) {
        var element = tmp$.next();
        if (element.defaultValue != null) {
          any$result = true;
          break any$break;
        }
      }
      any$result = false;
    }
     while (false);
    return any$result;
  }
  function withMissedOverloads$hasDefaultParameters_0(closure$hasDefaultParameters) {
    return function ($receiver) {
      return closure$hasDefaultParameters($receiver.callSignature.params);
    };
  }
  function withMissedOverloads$possibleSignatures($receiver) {
    var params = $receiver.callSignature.params;
    var indexOfFirst$result;
    indexOfFirst$break: do {
      var tmp$;
      var index = 0;
      tmp$ = params.iterator();
      while (tmp$.hasNext()) {
        var item = tmp$.next();
        if (item.defaultValue != null) {
          indexOfFirst$result = index;
          break indexOfFirst$break;
        }
        index = index + 1 | 0;
      }
      indexOfFirst$result = -1;
    }
     while (false);
    var first = indexOfFirst$result;
    if (first < 0)
      return emptyList();
    var $receiver_0 = params.subList_vux9f0$(first, params.size);
    var indexOfFirst$result_0;
    indexOfFirst$break: do {
      var tmp$_0;
      var index_0 = 0;
      tmp$_0 = $receiver_0.iterator();
      while (tmp$_0.hasNext()) {
        var item_0 = tmp$_0.next();
        if (item_0.defaultValue == null) {
          indexOfFirst$result_0 = index_0;
          break indexOfFirst$break;
        }
        index_0 = index_0 + 1 | 0;
      }
      indexOfFirst$result_0 = -1;
    }
     while (false);
    var count = indexOfFirst$result_0;
    var last = count < 0 ? params.size : -1;
    var $receiver_1 = new IntRange(first, last);
    var destination = ArrayList_init(collectionSizeOrDefault($receiver_1, 10));
    var tmp$_1;
    tmp$_1 = $receiver_1.iterator();
    while (tmp$_1.hasNext()) {
      var item_1 = tmp$_1.next();
      destination.add_11rb$(toList_1(params.subList_vux9f0$(0, item_1)));
    }
    var r = destination;
    return r;
  }
  function withMissedOverloads_1($receiver) {
    var hasDefaultParameters = withMissedOverloads$hasDefaultParameters;
    var hasDefaultParameters_0 = withMissedOverloads$hasDefaultParameters_0(hasDefaultParameters);
    var possibleSignatures = withMissedOverloads$possibleSignatures;
    var destination = ArrayList_init();
    var tmp$;
    tmp$ = $receiver.iterator();
    while (tmp$.hasNext()) {
      var element = tmp$.next();
      if (Kotlin.isType(element, KtFunction))
        destination.add_11rb$(element);
    }
    var destination_0 = LinkedHashMap_init();
    var tmp$_0;
    tmp$_0 = destination.iterator();
    while (tmp$_0.hasNext()) {
      var element_0 = tmp$_0.next();
      var key = element_0.copy_3m4w0d$(void 0, element_0.callSignature.copy_sl5de3$(emptyList()));
      var tmp$_0_0;
      var value = destination_0.get_11rb$(key);
      if (value == null) {
        var answer = ArrayList_init();
        destination_0.put_xwzc9p$(key, answer);
        tmp$_0_0 = answer;
      }
       else {
        tmp$_0_0 = value;
      }
      var list = tmp$_0_0;
      list.add_11rb$(element_0);
    }
    var $receiver_0 = toList_2(destination_0);
    var tmp$_1;
    var first_0 = ArrayList_init();
    var second = ArrayList_init();
    tmp$_1 = $receiver_0.iterator();
    while (tmp$_1.hasNext()) {
      var element_1 = tmp$_1.next();
      var $receiver_1 = element_1.second;
      var count$result;
      count$break: do {
        var tmp$_2;
        if (Kotlin.isType($receiver_1, Collection) && $receiver_1.isEmpty()) {
          count$result = 0;
          break count$break;
        }
        var count = 0;
        tmp$_2 = $receiver_1.iterator();
        while (tmp$_2.hasNext()) {
          var element_2 = tmp$_2.next();
          if (hasDefaultParameters_0(element_2)) {
            count = count + 1 | 0;
          }
        }
        count$result = count;
      }
       while (false);
      if (count$result > 1) {
        first_0.add_11rb$(element_1);
      }
       else {
        second.add_11rb$(element_1);
      }
    }
    var tmp$_3 = new Pair(first_0, second);
    var withDefaultParams = tmp$_3.component1()
    , withoutDefaultParams = tmp$_3.component2();
    var $receiver_2 = toMap(withoutDefaultParams);
    var destination_1 = LinkedHashMap_init_0(mapCapacity($receiver_2.size));
    var tmp$_4;
    tmp$_4 = $receiver_2.entries.iterator();
    while (tmp$_4.hasNext()) {
      var element_3 = tmp$_4.next();
      var tmp$_5 = destination_1.put_xwzc9p$;
      var tmp$_6 = element_3.key;
      var $receiver_3 = element_3.value;
      var destination_2 = ArrayList_init(collectionSizeOrDefault($receiver_3, 10));
      var tmp$_7;
      tmp$_7 = $receiver_3.iterator();
      while (tmp$_7.hasNext()) {
        var item = tmp$_7.next();
        destination_2.add_11rb$(item.callSignature.params);
      }
      tmp$_5.call(destination_1, tmp$_6, destination_2);
    }
    var m = destination_1;
    var newFunctions = ArrayList_init();
    var tmp$_8;
    tmp$_8 = withDefaultParams.iterator();
    while (tmp$_8.hasNext()) {
      var element_4 = tmp$_8.next();
      var $receiver_4 = element_4.second;
      var destination_3 = ArrayList_init();
      var tmp$_9;
      tmp$_9 = $receiver_4.iterator();
      while (tmp$_9.hasNext()) {
        var element_5 = tmp$_9.next();
        var list_0 = possibleSignatures(element_5);
        addAll(destination_3, list_0);
      }
      var destination_4 = ArrayList_init();
      var tmp$_10;
      tmp$_10 = destination_3.iterator();
      while (tmp$_10.hasNext()) {
        var element_6 = tmp$_10.next();
        if (!hasDefaultParameters(element_6))
          destination_4.add_11rb$(element_6);
      }
      var destination_5 = LinkedHashMap_init();
      var tmp$_11;
      tmp$_11 = destination_4.iterator();
      while (tmp$_11.hasNext()) {
        var element_7 = tmp$_11.next();
        var key_0 = element_7;
        var tmp$_0_1;
        var value_0 = destination_5.get_11rb$(key_0);
        if (value_0 == null) {
          var answer_0 = ArrayList_init();
          destination_5.put_xwzc9p$(key_0, answer_0);
          tmp$_0_1 = answer_0;
        }
         else {
          tmp$_0_1 = value_0;
        }
        var list_1 = tmp$_0_1;
        list_1.add_11rb$(element_7);
      }
      var destination_6 = LinkedHashMap_init();
      var tmp$_12;
      tmp$_12 = destination_5.entries.iterator();
      while (tmp$_12.hasNext()) {
        var element_8 = tmp$_12.next();
        if (element_8.value.size > 1) {
          destination_6.put_xwzc9p$(element_8.key, element_8.value);
        }
      }
      var destination_7 = ArrayList_init(destination_6.size);
      var tmp$_13;
      tmp$_13 = destination_6.entries.iterator();
      while (tmp$_13.hasNext()) {
        var item_0 = tmp$_13.next();
        destination_7.add_11rb$(first(item_0.value));
      }
      var tmp$_14;
      tmp$_14 = distinct(destination_7).iterator();
      while (tmp$_14.hasNext()) {
        var element_9 = tmp$_14.next();
        var tmp$_15;
        if (((tmp$_15 = m.get_11rb$(element_4.first)) != null ? tmp$_15.contains_11rb$(element_9) : null) !== true) {
          newFunctions.add_11rb$(element_4.first.copy_3m4w0d$(void 0, element_4.first.callSignature.copy_sl5de3$(element_9)));
        }
      }
    }
    return plus($receiver, newFunctions);
  }
  function mapType($receiver, type) {
    var tmp$;
    var resolvedType = $receiver.typeChecker.getTypeAtLocation(type);
    if (resolvedType != null) {
      tmp$ = mapType_0($receiver, resolvedType, type);
    }
     else {
      tmp$ = toKotlinType_2(type, $receiver);
    }
    return tmp$;
  }
  function mapTypeToUnion($receiver, type) {
    var tmp$;
    var resolvedType = $receiver.typeChecker.getTypeAtLocation(type);
    if (resolvedType != null) {
      tmp$ = mapTypeToUnion_0($receiver, resolvedType, type);
    }
     else {
      tmp$ = toKotlinTypeUnion_0(type, $receiver);
    }
    return tmp$;
  }
  function mapType_0($receiver, type, declaration) {
    return mapTypeToUnion_0($receiver, type, declaration).singleType;
  }
  function mapTypeToUnion_0($receiver, type, declaration) {
    var tmp$, tmp$_0, tmp$_1, tmp$_2, tmp$_3;
    var resultingDeclaration = declaration != null ? declaration : (tmp$_0 = (tmp$ = type.symbol) != null ? tmp$.declarations : null) != null ? singleOrNull(tmp$_0) : null;
    var flags = type.getFlags();
    var tmp$_4 = resultingDeclaration != null && type.symbol == null;
    if (tmp$_4) {
      tmp$_4 = (flags & TypeFlags$Any) !== 0;
    }
    if (tmp$_4) {
      return toKotlinTypeUnion_0(resultingDeclaration, $receiver);
    }
    var tmp$_5 = equals(resultingDeclaration != null ? resultingDeclaration.kind : null, SyntaxKind$UnionType);
    if (tmp$_5) {
      tmp$_5 = !((flags & TypeFlags$Union) !== 0);
    }
    if (tmp$_5) {
      return toKotlinTypeUnion_2(resultingDeclaration, $receiver);
    }
    if ($receiver.typesInMappingProcess.contains_11rb$(type)) {
      report('Recursion is detected when resolve type: ' + '"' + toString((tmp$_1 = type.symbol) != null ? tmp$_1.name : null) + '"' + ' for the declaration at ' + toString(declaration != null ? location(declaration) : null), DiagnosticLevel$WARNING_WITH_STACKTRACE_getInstance());
      return KtTypeUnion([new KtType(DYNAMIC)]);
    }
    $receiver.typesInMappingProcess.add_11rb$(type);
    if (equals(declaration != null ? declaration.kind : null, SyntaxKind$ThisType)) {
      var $receiver_0 = mapTypeToUnion_0($receiver, ensureNotNull(type.constraint), null).possibleTypes;
      var destination = ArrayList_init(collectionSizeOrDefault($receiver_0, 10));
      var tmp$_6;
      tmp$_6 = $receiver_0.iterator();
      while (tmp$_6.hasNext()) {
        var item = tmp$_6.next();
        destination.add_11rb$(item.copy_wau779$(void 0, void 0, 'this'));
      }
      var possibleTypes = destination;
      tmp$_3 = new KtTypeUnion_0(possibleTypes);
    }
     else {
      if ((flags & TypeFlags$Any) !== 0)
        tmp$_3 = KtTypeUnion([new KtType(ANY)]);
      else {
        if ((flags & TypeFlags$String) !== 0)
          tmp$_3 = KtTypeUnion([new KtType(STRING)]);
        else {
          if ((flags & TypeFlags$Boolean) !== 0)
            tmp$_3 = KtTypeUnion([new KtType(BOOLEAN)]);
          else {
            if ((flags & TypeFlags$Number) !== 0)
              tmp$_3 = KtTypeUnion([new KtType(NUMBER)]);
            else {
              if ((flags & TypeFlags$Void) !== 0)
                tmp$_3 = KtTypeUnion([new KtType(UNIT)]);
              else {
                var tmp$_7 = (flags & TypeFlags$Undefined) !== 0;
                if (!tmp$_7) {
                  tmp$_7 = (flags & TypeFlags$Null) !== 0;
                }
                if (tmp$_7)
                  tmp$_3 = KtTypeUnion([new KtType(NOTHING, void 0, void 0, true)]);
                else {
                  if ((flags & TypeFlags$StringLiteral) !== 0) {
                    tmp$_3 = KtTypeUnion([new KtType(STRING, void 0, '"' + toString(type.value) + '"')]);
                  }
                   else {
                    if ((flags & TypeFlags$NumberLiteral) !== 0) {
                      tmp$_3 = KtTypeUnion([new KtType(NUMBER, void 0, type.value)]);
                    }
                     else {
                      if ((flags & TypeFlags$BooleanLiteral) !== 0) {
                        tmp$_3 = KtTypeUnion([new KtType(BOOLEAN, void 0, type.value)]);
                      }
                       else {
                        if ((flags & TypeFlags$Union) !== 0) {
                          tmp$_3 = mapUnionType($receiver, type);
                        }
                         else {
                          if ((flags & TypeFlags$Intersection) !== 0) {
                            tmp$_3 = mapIntersectionType($receiver, type);
                          }
                           else {
                            if ((flags & TypeFlags$TypeParameter) !== 0)
                              tmp$_3 = KtTypeUnion([new KtType(KtQualifiedName_init(unescapeIdentifier(ensureNotNull(type.getSymbol()).name)))]);
                            else {
                              if ((flags & TypeFlags$Object) !== 0) {
                                var objectFlags = (Kotlin.isType(tmp$_2 = type, Object) ? tmp$_2 : throwCCE()).objectFlags;
                                if ((objectFlags & ObjectFlags$Anonymous) !== 0)
                                  tmp$_3 = KtTypeUnion([mapAnonymousType($receiver, type, declaration)]);
                                else {
                                  if ((objectFlags & ObjectFlags$ClassOrInterface) !== 0) {
                                    tmp$_3 = KtTypeUnion([mapInterfaceType($receiver, type, declaration)]);
                                  }
                                   else {
                                    if ((objectFlags & ObjectFlags$Reference) !== 0) {
                                      tmp$_3 = KtTypeUnion([mapTypeReference($receiver, type, declaration)]);
                                    }
                                     else
                                      tmp$_3 = KtTypeUnion([new KtType(ANY, void 0, void 0, true)]);
                                  }
                                }
                              }
                               else {
                                if ((flags & TypeFlags$Enum) !== 0) {
                                  tmp$_3 = KtTypeUnion([mapObjectType($receiver, type)]);
                                }
                                 else
                                  tmp$_3 = KtTypeUnion([new KtType(ANY, void 0, void 0, true)]);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    var mappedType = tmp$_3;
    $receiver.typesInMappingProcess.remove_11rb$(type);
    return mappedType;
  }
  function mapUnionType($receiver, type) {
    var tmp$;
    var $receiver_0 = type.types;
    var destination = ArrayList_init();
    var tmp$_0;
    for (tmp$_0 = 0; tmp$_0 !== $receiver_0.length; ++tmp$_0) {
      var element = $receiver_0[tmp$_0];
      var tmp$_1 = !((element.getFlags() & TypeFlags$Undefined) !== 0);
      if (tmp$_1) {
        tmp$_1 = !((element.getFlags() & TypeFlags$Null) !== 0);
      }
      if (tmp$_1)
        destination.add_11rb$(element);
    }
    var notNullTypes = destination;
    var tmp$_2 = notNullTypes.size !== type.types.length;
    if (!tmp$_2) {
      var array = type.types;
      var tmp$_3 = equals(typeof array.containsNull, 'boolean');
      if (tmp$_3) {
        tmp$_3 = array.containsNull;
      }
      tmp$_2 = tmp$_3;
    }
    var tmp$_4 = tmp$_2;
    if (!tmp$_4) {
      var array_0 = type.types;
      var tmp$_5 = equals(typeof array_0.containsUndefined, 'boolean');
      if (tmp$_5) {
        tmp$_5 = array_0.containsUndefined;
      }
      tmp$_4 = tmp$_5;
    }
    var nullable = tmp$_4;
    var destination_0 = ArrayList_init(collectionSizeOrDefault(notNullTypes, 10));
    var tmp$_6;
    tmp$_6 = notNullTypes.iterator();
    while (tmp$_6.hasNext()) {
      var item = tmp$_6.next();
      destination_0.add_11rb$(mapType_0($receiver, item, null));
    }
    var mappedTypes = destination_0;
    if (!nullable)
      tmp$ = distinct(mappedTypes);
    else if (notNullTypes.size === 1) {
      var destination_1 = ArrayList_init(collectionSizeOrDefault(mappedTypes, 10));
      var tmp$_7;
      tmp$_7 = mappedTypes.iterator();
      while (tmp$_7.hasNext()) {
        var item_0 = tmp$_7.next();
        destination_1.add_11rb$(item_0.copy_wau779$(void 0, void 0, void 0, true));
      }
      tmp$ = destination_1;
    }
     else
      tmp$ = distinct(plus_0(mappedTypes, new KtType(NOTHING, void 0, void 0, true)));
    return new KtTypeUnion_0(tmp$);
  }
  function get_containsUndefined($receiver) {
    var array = $receiver.types;
    var tmp$ = equals(typeof array.containsUndefined, 'boolean');
    if (tmp$) {
      tmp$ = array.containsUndefined;
    }
    return tmp$;
  }
  function get_containsNull($receiver) {
    var array = $receiver.types;
    var tmp$ = equals(typeof array.containsNull, 'boolean');
    if (tmp$) {
      tmp$ = array.containsNull;
    }
    return tmp$;
  }
  function mapIntersectionType$lambda(this$mapIntersectionType) {
    return function (it) {
      return stringify(mapType_0(this$mapIntersectionType, it, null));
    };
  }
  function mapIntersectionType($receiver, type) {
    return KtTypeUnion([mapType_0($receiver, first_0(type.types), null).copy_wau779$(void 0, void 0, joinToString_0(type.types, ' & ', void 0, void 0, void 0, void 0, mapIntersectionType$lambda($receiver)))]);
  }
  function mapTypeReference$lambda(it) {
    return stringify(it);
  }
  function mapTypeReference($receiver, type, declaration) {
    var mappedArgs = mapTypeArguments($receiver, type.typeArguments, declaration);
    if ((type.target.objectFlags & ObjectFlags$Tuple) !== 0) {
      return new KtType(DYNAMIC, void 0, 'JsTuple<' + joinToString_1(mappedArgs, ', ', void 0, void 0, void 0, void 0, mapTypeReference$lambda) + '>');
    }
    return mapObjectType($receiver, type.target).copy_wau779$(void 0, toList_0(mappedArgs));
  }
  function mapInterfaceType($receiver, type, declaration) {
    var tmp$, tmp$_0, tmp$_1;
    var tmp$_2;
    if ((tmp$ = type.typeParameters) != null) {
      var destination = ArrayList_init(tmp$.length);
      var tmp$_3;
      for (tmp$_3 = 0; tmp$_3 !== tmp$.length; ++tmp$_3) {
        var item = tmp$[tmp$_3];
        destination.add_11rb$(item);
      }
      tmp$_2 = destination;
    }
     else
      tmp$_2 = null;
    var mappedArgs = mapTypeArguments($receiver, (tmp$_0 = tmp$_2) != null ? copyToArray(tmp$_0) : null, declaration);
    var mappedType = mapObjectType($receiver, type);
    if ((tmp$_1 = mappedType.qualifiedName) != null ? tmp$_1.equals(KtQualifiedName_init('Function')) : null)
      return mappedType;
    return mappedType.copy_wau779$(void 0, toList_0(mappedArgs));
  }
  function mapTypeArguments$lambda() {
    return 0;
  }
  function mapTypeArguments$lambda_0(it) {
    return null;
  }
  function mapTypeArguments$lambda_1(this$mapTypeArguments) {
    return function (f) {
      var argType = f.component1()
      , arg = f.component2();
      return mapType_0(this$mapTypeArguments, argType, arg);
    };
  }
  function mapTypeArguments($receiver, typeArguments, declaration) {
    var tmp$, tmp$_0, tmp$_1, tmp$_2, tmp$_3, tmp$_4;
    if (declaration != null) {
      tmp$_0 = Kotlin.isType(tmp$ = declaration.kind, Any) ? tmp$ : throwCCE();
      if (equals(tmp$_0, SyntaxKind$ExpressionWithTypeArguments) || equals(tmp$_0, SyntaxKind$TypeReference)) {
        tmp$_4 = (tmp$_3 = (tmp$_2 = (tmp$_1 = declaration.typeArguments) != null ? tmp$_1 : null) != null ? asSequence_0(tmp$_2) : null) != null ? tmp$_3 : emptySequence();
      }
       else if (equals(tmp$_0, SyntaxKind$ArrayType)) {
        tmp$_4 = sequenceOf([declaration.elementType]);
      }
       else {
        tmp$_4 = emptySequence();
      }
    }
     else {
      tmp$_4 = emptySequence();
    }
    var typeArgsFromDeclaration = tmp$_4;
    var $receiver_0 = typeArguments != null ? typeArguments : [];
    var destination = ArrayList_init();
    var tmp$_5;
    for (tmp$_5 = 0; tmp$_5 !== $receiver_0.length; ++tmp$_5) {
      var element = $receiver_0[tmp$_5];
      var tmp$_6;
      if ((element.flags & TypeFlags$TypeParameter) !== 0 ? (Kotlin.isType(tmp$_6 = element, Object) ? tmp$_6 : throwCCE()).isThisType !== true : true)
        destination.add_11rb$(element);
    }
    var typeArgsWithDeclarations = zip(asSequence(destination), plus_2(typeArgsFromDeclaration, map(generateSequence(mapTypeArguments$lambda), mapTypeArguments$lambda_0)));
    return map(typeArgsWithDeclarations, mapTypeArguments$lambda_1($receiver));
  }
  function mapObjectType($receiver, type) {
    var tmp$;
    var fqn = buildFqn($receiver, ensureNotNull(type.getSymbol()));
    if (fqn != null ? fqn.equals(KtQualifiedName_init('Function')) : null)
      return new KtType(KtQualifiedName_init('Function'), listOf(starType()));
    if (equals(fqn, KtQualifiedName_init('Object')))
      tmp$ = ANY;
    else {
      if ($receiver.currentPackage.length > 0 && startsWith(fqn.asString(), $receiver.currentPackage + '.') && indexOf(fqn.asString(), 46, $receiver.currentPackage.length + 1 | 0) < 0) {
        var $receiver_0 = fqn.asString();
        var startIndex = $receiver.currentPackage.length + 1 | 0;
        var tmp$_0;
        var accumulator = null;
        tmp$_0 = split($receiver_0.substring(startIndex), ['.']).iterator();
        while (tmp$_0.hasNext()) {
          var element = tmp$_0.next();
          accumulator = KtQualifiedName_init(element, accumulator);
        }
        tmp$ = ensureNotNull(accumulator);
      }
       else {
        tmp$ = fqn;
      }
    }
    return new KtType(tmp$);
  }
  function buildFqn($receiver, symbol) {
    var tmp$, tmp$_0;
    var declaration = (tmp$ = symbol.declarations) != null ? singleOrNull(tmp$) : null;
    return (tmp$_0 = declaration != null ? buildFqn_0($receiver, declaration) : null) != null ? tmp$_0 : KtQualifiedName_init($receiver.typeChecker.getFullyQualifiedName(symbol));
  }
  function buildFqn_0($receiver, declaration) {
    var tmp$, tmp$_0, tmp$_1, tmp$_2, tmp$_3, tmp$_4;
    var parent = getParentDeclaration(declaration);
    var parentSymbol = parent != null ? getSymbolResolvingAliases($receiver.typeChecker, parent) : null;
    if (parentSymbol != null)
      tmp$ = buildFqn($receiver, parentSymbol);
    else if (parent != null)
      tmp$ = buildFqn_0($receiver, parent);
    else
      tmp$ = null;
    var parentName = tmp$;
    tmp$_1 = Kotlin.isType(tmp$_0 = declaration.kind, Any) ? tmp$_0 : throwCCE();
    if (equals(tmp$_1, SyntaxKind$InterfaceDeclaration) || equals(tmp$_1, SyntaxKind$ClassDeclaration)) {
      return KtQualifiedName_init(unescapeIdentifier(ensureNotNull(declaration.name).text), parentName);
    }
     else if (equals(tmp$_1, SyntaxKind$ModuleDeclaration)) {
      var nameExpr = declaration.name;
      tmp$_3 = Kotlin.isType(tmp$_2 = nameExpr.kind, Any) ? tmp$_2 : throwCCE();
      if (equals(tmp$_3, SyntaxKind$StringLiteral)) {
        tmp$_4 = replace(nameExpr.text, 47, 46);
      }
       else if (equals(tmp$_3, SyntaxKind$Identifier)) {
        tmp$_4 = unescapeIdentifier(nameExpr.text);
      }
       else
        tmp$_4 = 'UNKNOWN';
      var name = tmp$_4;
      return KtQualifiedName_init(sanitize(name), parentName);
    }
    return null;
  }
  function getParentDeclaration($receiver) {
    var tmp$;
    return (tmp$ = $receiver.parent) != null ? getEnclosingDeclaration(tmp$) : null;
  }
  function getEnclosingDeclaration($receiver) {
    var tmp$, tmp$_0;
    tmp$_0 = Kotlin.isType(tmp$ = $receiver.kind, Any) ? tmp$ : throwCCE();
    if (equals(tmp$_0, SyntaxKind$ModuleBlock)) {
      return getEnclosingDeclaration($receiver.parent);
    }
     else if (equals(tmp$_0, SyntaxKind$ClassDeclaration) || equals(tmp$_0, SyntaxKind$InterfaceDeclaration) || equals(tmp$_0, SyntaxKind$ModuleDeclaration)) {
      return $receiver;
    }
     else
      return null;
  }
  function mapAnonymousType($receiver, type, declaration) {
    var tmp$, tmp$_0, tmp$_1, tmp$_2, tmp$_3, tmp$_4, tmp$_5, tmp$_6, tmp$_7;
    tmp$_2 = (tmp$_1 = (tmp$_0 = (tmp$ = type.getSymbol()) != null ? tmp$.getDeclarations() : null) != null ? singleOrNull(tmp$_0) : null) != null ? tmp$_1 : declaration;
    if (tmp$_2 == null) {
      return new KtType(ANY, void 0, void 0, true);
    }
    var resolvedDeclaration = tmp$_2;
    if (equals(resolvedDeclaration.kind, SyntaxKind$TypeLiteral)) {
      if ((tmp$_3 = type.aliasSymbol) != null) {
        var typeArguments = toList_0(mapTypeArguments($receiver, type.aliasTypeArguments, declaration));
        return new KtType(buildFqn($receiver, tmp$_3), typeArguments);
      }
    }
    var parent = resolvedDeclaration.parent;
    if (equals(parent != null ? parent.kind : null, SyntaxKind$TypeAliasDeclaration)) {
      var typeParameters = parent.typeParameters;
      var $receiver_0 = typeParameters != null ? typeParameters : null;
      var $receiver_1 = $receiver_0 != null ? $receiver_0 : [];
      var destination = ArrayList_init($receiver_1.length);
      var tmp$_8;
      for (tmp$_8 = 0; tmp$_8 !== $receiver_1.length; ++tmp$_8) {
        var item = $receiver_1[tmp$_8];
        destination.add_11rb$(item.name.text);
      }
      var $receiver_2 = type.aliasTypeArguments;
      var $receiver_3 = $receiver_2 != null ? $receiver_2 : [];
      var destination_0 = ArrayList_init($receiver_3.length);
      var tmp$_9;
      for (tmp$_9 = 0; tmp$_9 !== $receiver_3.length; ++tmp$_9) {
        var item_0 = $receiver_3[tmp$_9];
        destination_0.add_11rb$(mapType_0($receiver, item_0, null));
      }
      var substitution = toMap(zip_0(destination, destination_0));
      tmp$_4 = new Pair($receiver.withTypeParameters_le0eav$(typeParameters), substitution);
    }
     else {
      tmp$_4 = new Pair($receiver, emptyMap());
    }
    var tmp$_10 = tmp$_4;
    var mapper = tmp$_10.component1()
    , substitution_0 = tmp$_10.component2();
    tmp$_6 = Kotlin.isType(tmp$_5 = resolvedDeclaration.kind, Any) ? tmp$_5 : throwCCE();
    if (equals(tmp$_6, SyntaxKind$FunctionType)) {
      tmp$_7 = toKotlinType_0(resolvedDeclaration, mapper);
    }
     else if (equals(tmp$_6, SyntaxKind$TypeLiteral)) {
      tmp$_7 = mapper.getKotlinTypeForObjectType_29gnwt$(resolvedDeclaration);
    }
     else
      tmp$_7 = new KtType(ANY, void 0, void 0, true);
    var kotlinType = tmp$_7;
    return !substitution_0.isEmpty() ? replaceTypeParameters(kotlinType, substitution_0) : kotlinType;
  }
  function replaceTypeParameters($receiver, substitution) {
    var tmp$, tmp$_0;
    if ($receiver.typeArgs.isEmpty() && $receiver.callSignature == null) {
      return (tmp$ = substitution.get_11rb$($receiver.qualifiedName.asString())) != null ? tmp$ : $receiver;
    }
     else {
      var $receiver_0 = $receiver.typeArgs;
      var destination = ArrayList_init(collectionSizeOrDefault($receiver_0, 10));
      var tmp$_1;
      tmp$_1 = $receiver_0.iterator();
      while (tmp$_1.hasNext()) {
        var item = tmp$_1.next();
        destination.add_11rb$(replaceTypeParameters(item, substitution));
      }
      return $receiver.copy_wau779$(void 0, destination, void 0, void 0, (tmp$_0 = $receiver.callSignature) != null ? replaceTypeParameters_0(tmp$_0, substitution) : null);
    }
  }
  function replaceTypeParameters_0($receiver, substitution) {
    var $receiver_0 = $receiver.params;
    var destination = ArrayList_init(collectionSizeOrDefault($receiver_0, 10));
    var tmp$;
    tmp$ = $receiver_0.iterator();
    while (tmp$.hasNext()) {
      var item = tmp$.next();
      destination.add_11rb$(replaceTypeParameters_1(item, substitution));
    }
    return $receiver.copy_sl5de3$(destination, void 0, replaceTypeParameters_2($receiver.returnType, substitution));
  }
  function replaceTypeParameters_1($receiver, substitution) {
    return $receiver.copy_wii1xx$(void 0, replaceTypeParameters_2($receiver.type, substitution));
  }
  function replaceTypeParameters_2($receiver, substitution) {
    return $receiver.copy_nxconx$(replaceTypeParameters($receiver.type, substitution));
  }
  function UnionOrIntersectionTypeNode() {
  }
  UnionOrIntersectionTypeNode.$metadata$ = {
    kind: Kind_INTERFACE,
    simpleName: 'UnionOrIntersectionTypeNode',
    interfaces: []
  };
  var get_declarationName = defineInlineFunction('ts2kt.typescriptServices.ts.get_declarationName_jhg893$', function ($receiver) {
    return $receiver.name;
  });
  var get_identifierName = defineInlineFunction('ts2kt.typescriptServices.ts.get_identifierName_snzh8q$', function ($receiver) {
    return $receiver.name;
  });
  var get_identifierName_0 = defineInlineFunction('ts2kt.typescriptServices.ts.get_identifierName_5s6jds$', function ($receiver) {
    return $receiver.name;
  });
  var get_propertyName = defineInlineFunction('ts2kt.typescriptServices.ts.get_propertyName_nwtuk7$', function ($receiver) {
    return $receiver.name;
  });
  var get_propertyName_0 = defineInlineFunction('ts2kt.typescriptServices.ts.get_propertyName_ih1unk$', function ($receiver) {
    return $receiver.name;
  });
  var get_propertyName_1 = defineInlineFunction('ts2kt.typescriptServices.ts.get_propertyName_prku36$', function ($receiver) {
    return $receiver.name;
  });
  var get_propertyName_2 = defineInlineFunction('ts2kt.typescriptServices.ts.get_propertyName_1v1vnl$', function ($receiver) {
    return $receiver.name;
  });
  var get_propertyName_3 = defineInlineFunction('ts2kt.typescriptServices.ts.get_propertyName_i42fc9$', function ($receiver) {
    return $receiver.name;
  });
  var get_identifierName_1 = defineInlineFunction('ts2kt.typescriptServices.ts.get_identifierName_gcxvwa$', function ($receiver) {
    return $receiver.name;
  });
  var get_declarationName_0 = defineInlineFunction('ts2kt.typescriptServices.ts.get_declarationName_czbci4$', function ($receiver) {
    return $receiver.name;
  });
  var get_propertyName_4 = defineInlineFunction('ts2kt.typescriptServices.ts.get_propertyName_7v1fh7$', function ($receiver) {
    return $receiver.name;
  });
  var get_identifierName_2 = defineInlineFunction('ts2kt.typescriptServices.ts.get_identifierName_x5rxe7$', function ($receiver) {
    return $receiver.name;
  });
  var get_propertyName_5 = defineInlineFunction('ts2kt.typescriptServices.ts.get_propertyName_jnf2ws$', function ($receiver) {
    return $receiver.name;
  });
  var get_propertyName_6 = defineInlineFunction('ts2kt.typescriptServices.ts.get_propertyName_va8bie$', function ($receiver) {
    return $receiver.name;
  });
  var set_propertyName = defineInlineFunction('ts2kt.typescriptServices.ts.set_propertyName_vxqxz6$', function ($receiver, v) {
    $receiver.name = v;
  });
  var get_propertyName_7 = defineInlineFunction('ts2kt.typescriptServices.ts.get_propertyName_68a97k$', function ($receiver) {
    return $receiver.name;
  });
  var get_identifierName_3 = defineInlineFunction('ts2kt.typescriptServices.ts.get_identifierName_jlyuxx$', function ($receiver) {
    return $receiver.name;
  });
  var get_identifierName_4 = defineInlineFunction('ts2kt.typescriptServices.ts.get_identifierName_j6kl1i$', function ($receiver) {
    return $receiver.name;
  });
  var get_identifierName_5 = defineInlineFunction('ts2kt.typescriptServices.ts.get_identifierName_uulvm1$', function ($receiver) {
    return $receiver.name;
  });
  var get_identifierName_6 = defineInlineFunction('ts2kt.typescriptServices.ts.get_identifierName_p0tzpc$', function ($receiver) {
    return $receiver.name;
  });
  var set_identifierName = defineInlineFunction('ts2kt.typescriptServices.ts.set_identifierName_x4zda$', function ($receiver, v) {
    $receiver.name = v;
  });
  var get_identifierName_7 = defineInlineFunction('ts2kt.typescriptServices.ts.get_identifierName_a9aw95$', function ($receiver) {
    return $receiver.name;
  });
  var set_identifierName_0 = defineInlineFunction('ts2kt.typescriptServices.ts.set_identifierName_2zh5fb$', function ($receiver, v) {
    $receiver.name = v;
  });
  var get_propertyName_8 = defineInlineFunction('ts2kt.typescriptServices.ts.get_propertyName_q9hz09$', function ($receiver) {
    return $receiver.name;
  });
  var get_propertyName_9 = defineInlineFunction('ts2kt.typescriptServices.ts.get_propertyName_rgranj$', function ($receiver) {
    return $receiver.name;
  });
  var get_identifierName_8 = defineInlineFunction('ts2kt.typescriptServices.ts.get_identifierName_d15va$', function ($receiver) {
    return $receiver.name;
  });
  var get_identifierName_9 = defineInlineFunction('ts2kt.typescriptServices.ts.get_identifierName_ewxmrr$', function ($receiver) {
    return $receiver.name;
  });
  var set_identifierName_1 = defineInlineFunction('ts2kt.typescriptServices.ts.set_identifierName_eya9g$', function ($receiver, v) {
    $receiver.name = v;
  });
  var get_declarationName_1 = defineInlineFunction('ts2kt.typescriptServices.ts.get_declarationName_w16434$', function ($receiver) {
    return $receiver.name;
  });
  var get_identifierName_10 = defineInlineFunction('ts2kt.typescriptServices.ts.get_identifierName_rferdy$', function ($receiver) {
    return $receiver.name;
  });
  var get_identifierName_11 = defineInlineFunction('ts2kt.typescriptServices.ts.get_identifierName_23mu59$', function ($receiver) {
    return $receiver.name;
  });
  var get_identifierName_12 = defineInlineFunction('ts2kt.typescriptServices.ts.get_identifierName_8phqdc$', function ($receiver) {
    return $receiver.name;
  });
  var get_identifierName_13 = defineInlineFunction('ts2kt.typescriptServices.ts.get_identifierName_fs3q0n$', function ($receiver) {
    return $receiver.name;
  });
  var set_identifierName_2 = defineInlineFunction('ts2kt.typescriptServices.ts.set_identifierName_9rwuhn$', function ($receiver, v) {
    $receiver.name = v;
  });
  var get_identifierName_14 = defineInlineFunction('ts2kt.typescriptServices.ts.get_identifierName_rlpjmb$', function ($receiver) {
    return $receiver.name;
  });
  var get_identifierName_15 = defineInlineFunction('ts2kt.typescriptServices.ts.get_identifierName_287i12$', function ($receiver) {
    return $receiver.name;
  });
  var get_identifierName_16 = defineInlineFunction('ts2kt.typescriptServices.ts.get_identifierName_lob3gp$', function ($receiver) {
    return $receiver.name;
  });
  function DiagnosticLevel(name, ordinal) {
    Enum.call(this);
    this.name$ = name;
    this.ordinal$ = ordinal;
  }
  function DiagnosticLevel_initFields() {
    DiagnosticLevel_initFields = function () {
    };
    DiagnosticLevel$EXCEPTION_instance = new DiagnosticLevel('EXCEPTION', 0);
    DiagnosticLevel$WARNING_WITH_STACKTRACE_instance = new DiagnosticLevel('WARNING_WITH_STACKTRACE', 1);
    DiagnosticLevel$WARNING_instance = new DiagnosticLevel('WARNING', 2);
    DiagnosticLevel$QUIET_instance = new DiagnosticLevel('QUIET', 3);
    DiagnosticLevel$Companion_getInstance();
  }
  var DiagnosticLevel$EXCEPTION_instance;
  function DiagnosticLevel$EXCEPTION_getInstance() {
    DiagnosticLevel_initFields();
    return DiagnosticLevel$EXCEPTION_instance;
  }
  var DiagnosticLevel$WARNING_WITH_STACKTRACE_instance;
  function DiagnosticLevel$WARNING_WITH_STACKTRACE_getInstance() {
    DiagnosticLevel_initFields();
    return DiagnosticLevel$WARNING_WITH_STACKTRACE_instance;
  }
  var DiagnosticLevel$WARNING_instance;
  function DiagnosticLevel$WARNING_getInstance() {
    DiagnosticLevel_initFields();
    return DiagnosticLevel$WARNING_instance;
  }
  var DiagnosticLevel$QUIET_instance;
  function DiagnosticLevel$QUIET_getInstance() {
    DiagnosticLevel_initFields();
    return DiagnosticLevel$QUIET_instance;
  }
  function DiagnosticLevel$Companion() {
    DiagnosticLevel$Companion_instance = this;
    this.DEFAULT = DiagnosticLevel$WARNING_getInstance();
  }
  DiagnosticLevel$Companion.$metadata$ = {
    kind: Kind_OBJECT,
    simpleName: 'Companion',
    interfaces: []
  };
  var DiagnosticLevel$Companion_instance = null;
  function DiagnosticLevel$Companion_getInstance() {
    DiagnosticLevel_initFields();
    if (DiagnosticLevel$Companion_instance === null) {
      new DiagnosticLevel$Companion();
    }
    return DiagnosticLevel$Companion_instance;
  }
  DiagnosticLevel.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'DiagnosticLevel',
    interfaces: [Enum]
  };
  function DiagnosticLevel$values() {
    return [DiagnosticLevel$EXCEPTION_getInstance(), DiagnosticLevel$WARNING_WITH_STACKTRACE_getInstance(), DiagnosticLevel$WARNING_getInstance(), DiagnosticLevel$QUIET_getInstance()];
  }
  DiagnosticLevel.values = DiagnosticLevel$values;
  function DiagnosticLevel$valueOf(name) {
    switch (name) {
      case 'EXCEPTION':
        return DiagnosticLevel$EXCEPTION_getInstance();
      case 'WARNING_WITH_STACKTRACE':
        return DiagnosticLevel$WARNING_WITH_STACKTRACE_getInstance();
      case 'WARNING':
        return DiagnosticLevel$WARNING_getInstance();
      case 'QUIET':
        return DiagnosticLevel$QUIET_getInstance();
      default:throwISE('No enum constant ts2kt.utils.DiagnosticLevel.' + name);
    }
  }
  DiagnosticLevel.valueOf_61zpoe$ = DiagnosticLevel$valueOf;
  var diagnosticLevel;
  function report(message, maxLevelToShow) {
    if (maxLevelToShow === void 0)
      maxLevelToShow = null;
    var tmp$;
    if (maxLevelToShow != null && diagnosticLevel.compareTo_11rb$(maxLevelToShow) > 0)
      return null;
    switch (diagnosticLevel.name) {
      case 'EXCEPTION':
        throw IllegalStateException_init(message);
      case 'WARNING_WITH_STACKTRACE':
        console.warn('ts2kt: ' + message);
        console.warn('Stacktrace:' + toString(Exception_init().stack));
        tmp$ = message;
        break;
      case 'WARNING':
        console.warn('ts2kt: ' + message);
        tmp$ = message;
        break;
      case 'QUIET':
        tmp$ = null;
        break;
      default:tmp$ = Kotlin.noWhenBranchMatched();
        break;
    }
    return tmp$;
  }
  function assert(condition, message) {
    if (!condition)
      report(message);
  }
  function reportUnsupportedNode(node) {
    reportUnsupportedNodeAndGetMessage(node);
    return null;
  }
  var trackUnsupportedKinds;
  var unsupportedKinds;
  function reportUnsupportedNodeAndGetMessage(node) {
    var tmp$;
    if (trackUnsupportedKinds) {
      var $receiver = unsupportedKinds;
      var key = node.kind;
      var value = ((tmp$ = unsupportedKinds.get_11rb$(node.kind)) != null ? tmp$ : 0) + 1 | 0;
      $receiver.put_xwzc9p$(key, value);
    }
    var $receiver_0 = node.kind;
    return report('"' + get_js(getKClass(SyntaxKind))[$receiver_0] + '"' + ' kind unsupported yet here! (' + location(node) + ')');
  }
  function reportUnsupportedKinds$lambda(it) {
    return it.second;
  }
  var sortedWith = Kotlin.kotlin.collections.sortedWith_eknfly$;
  var compareByDescending$lambda = wrapFunction(function () {
    var compareValues = Kotlin.kotlin.comparisons.compareValues_s00gnj$;
    return function (closure$selector) {
      return function (a, b) {
        var selector = closure$selector;
        return compareValues(selector(b), selector(a));
      };
    };
  });
  var Comparator = Kotlin.kotlin.Comparator;
  function Comparator$ObjectLiteral(closure$comparison) {
    this.closure$comparison = closure$comparison;
  }
  Comparator$ObjectLiteral.prototype.compare = function (a, b) {
    return this.closure$comparison(a, b);
  };
  Comparator$ObjectLiteral.$metadata$ = {kind: Kind_CLASS, interfaces: [Comparator]};
  function reportUnsupportedKinds() {
    if (!trackUnsupportedKinds) {
      console.warn('Tracking unsupported node kinds is disabled');
      return;
    }
    console.warn('Unsupported node kinds (' + unsupportedKinds.size + '):');
    console.warn('count\t\tname(id)');
    var tmp$;
    tmp$ = sortedWith(toList_2(unsupportedKinds), new Comparator$ObjectLiteral(compareByDescending$lambda(reportUnsupportedKinds$lambda))).iterator();
    while (tmp$.hasNext()) {
      var element = tmp$.next();
      var tmp$_0 = console;
      var tmp$_1 = element.second.toString() + '\t' + '\t';
      var $receiver = element.first;
      tmp$_0.warn(tmp$_1 + get_js(getKClass(SyntaxKind))[$receiver] + ' (' + element.first + ')');
    }
  }
  var KOTLIN_FILE_EXT;
  function translateToFile$lambda(closure$srcName) {
    return function (it) {
      return stringify_0(it, closure$srcName);
    };
  }
  function translateToFile(srcPath, outPath) {
    var tmp$;
    var srcName = $module$path.basename(srcPath, TYPESCRIPT_DEFINITION_FILE_EXT);
    var packageParts = translate(srcPath, srcName);
    if (!packageParts.isEmpty()) {
      tmp$ = joinToString(packageParts, '\n' + '// ' + repeat('-', 90) + '\n', void 0, void 0, void 0, void 0, translateToFile$lambda(srcName));
    }
     else
      tmp$ = '// NO DECLARATIONS';
    var out = tmp$;
    $module$fs.writeFileSync(outPath, out);
  }
  var UnsupportedOperationException_init = Kotlin.kotlin.UnsupportedOperationException_init_pdl1vj$;
  function mkDirs(dirs) {
    var parts = split(dirs, [$module$path.sep]);
    if (parts.isEmpty())
      return true;
    if (!$module$fs.existsSync(parts.get_za3lpa$(0))) {
      $module$fs.mkdirSync(parts.get_za3lpa$(0));
    }
    var iterator = parts.iterator();
    if (!iterator.hasNext())
      throw UnsupportedOperationException_init("Empty collection can't be reduced.");
    var accumulator = iterator.next();
    while (iterator.hasNext()) {
      var parent = accumulator;
      var name = iterator.next();
      var cur = parent + $module$path.sep + name;
      if (!$module$fs.existsSync(cur)) {
        $module$fs.mkdirSync(cur);
      }
      accumulator = cur;
    }
    return true;
  }
  function translateToDir(sources, outDir, basePackage, libraries, declareModifierIsOptional) {
    if (basePackage === void 0)
      basePackage = null;
    if (libraries === void 0)
      libraries = emptyList();
    if (declareModifierIsOptional === void 0)
      declareModifierIsOptional = false;
    var tmp$;
    var isOutDirExists = {v: false};
    tmp$ = sources.iterator();
    while (tmp$.hasNext()) {
      var src = tmp$.next();
      console.log('Converting ' + src);
      var baseSrcName = $module$path.basename(src, TYPESCRIPT_DEFINITION_FILE_EXT);
      var packageParts = translate(src, basePackage != null ? basePackage : '', declareModifierIsOptional);
      if (packageParts.isEmpty()) {
        console.log('Nothing was converted');
        continue;
      }
      console.log('Save declarations:');
      var tmp$_0;
      tmp$_0 = packageParts.iterator();
      while (tmp$_0.hasNext()) {
        var element = tmp$_0.next();
        var outFileName = baseSrcName + (!element.fqName.isEmpty() ? '.' : '') + joinToString(element.fqName, '.') + KOTLIN_FILE_EXT;
        var outFilePath = outDir + '/' + outFileName;
        console.log('\t' + outFilePath);
        var imports = listOf_0(['kotlin.js.*', 'kotlin.js.Json', 'org.khronos.webgl.*', 'org.w3c.dom.*', 'org.w3c.dom.events.*', 'org.w3c.dom.parsing.*', 'org.w3c.dom.svg.*', 'org.w3c.dom.url.*', 'org.w3c.fetch.*', 'org.w3c.files.*', 'org.w3c.notifications.*', 'org.w3c.performance.*', 'org.w3c.workers.*', 'org.w3c.xhr.*']);
        var suppressedDiagnostics = listOf_0(['INTERFACE_WITH_SUPERCLASS', 'OVERRIDING_FINAL_MEMBER', 'RETURN_TYPE_MISMATCH_ON_OVERRIDE', 'CONFLICTING_OVERLOADS', 'EXTERNAL_DELEGATION', 'NESTED_CLASS_IN_EXTERNAL_INTERFACE']);
        if (!isOutDirExists.v) {
          isOutDirExists.v = $module$fs.existsSync(outDir) || mkDirs(outDir);
        }
        $module$fs.writeFileSync(outFilePath, stringify_0(element, basePackage, true, imports, suppressedDiagnostics));
      }
    }
  }
  function CliArguments(sources, outDir, basePackage, libraries, declareModifierIsOptional) {
    this.sources = sources;
    this.outDir = outDir;
    this.basePackage = basePackage;
    this.libraries = libraries;
    this.declareModifierIsOptional = declareModifierIsOptional;
  }
  CliArguments.$metadata$ = {
    kind: Kind_CLASS,
    simpleName: 'CliArguments',
    interfaces: []
  };
  CliArguments.prototype.component1 = function () {
    return this.sources;
  };
  CliArguments.prototype.component2 = function () {
    return this.outDir;
  };
  CliArguments.prototype.component3 = function () {
    return this.basePackage;
  };
  CliArguments.prototype.component4 = function () {
    return this.libraries;
  };
  CliArguments.prototype.component5 = function () {
    return this.declareModifierIsOptional;
  };
  CliArguments.prototype.copy_bro5pk$ = function (sources, outDir, basePackage, libraries, declareModifierIsOptional) {
    return new CliArguments(sources === void 0 ? this.sources : sources, outDir === void 0 ? this.outDir : outDir, basePackage === void 0 ? this.basePackage : basePackage, libraries === void 0 ? this.libraries : libraries, declareModifierIsOptional === void 0 ? this.declareModifierIsOptional : declareModifierIsOptional);
  };
  CliArguments.prototype.toString = function () {
    return 'CliArguments(sources=' + Kotlin.toString(this.sources) + (', outDir=' + Kotlin.toString(this.outDir)) + (', basePackage=' + Kotlin.toString(this.basePackage)) + (', libraries=' + Kotlin.toString(this.libraries)) + (', declareModifierIsOptional=' + Kotlin.toString(this.declareModifierIsOptional)) + ')';
  };
  CliArguments.prototype.hashCode = function () {
    var result = 0;
    result = result * 31 + Kotlin.hashCode(this.sources) | 0;
    result = result * 31 + Kotlin.hashCode(this.outDir) | 0;
    result = result * 31 + Kotlin.hashCode(this.basePackage) | 0;
    result = result * 31 + Kotlin.hashCode(this.libraries) | 0;
    result = result * 31 + Kotlin.hashCode(this.declareModifierIsOptional) | 0;
    return result;
  };
  CliArguments.prototype.equals = function (other) {
    return this === other || (other !== null && (typeof other === 'object' && (Object.getPrototypeOf(this) === Object.getPrototypeOf(other) && (Kotlin.equals(this.sources, other.sources) && Kotlin.equals(this.outDir, other.outDir) && Kotlin.equals(this.basePackage, other.basePackage) && Kotlin.equals(this.libraries, other.libraries) && Kotlin.equals(this.declareModifierIsOptional, other.declareModifierIsOptional)))));
  };
  function printUsage(program) {
    console.log(trimIndent('\n' + '                Usage: ' + program + ' [<options>] <d.ts files>' + '\n' + '                where possible options include:' + '\n' + '                    -d <path>                   Destination directory for files with converted declarations,' + '\n' + '                                                current directory is used by default' + '\n' + '                    -h                          Print a synopsis of standard options' + '\n' + '                    -v, -version                Print version' + '\n' + '                    -X                          Print a synopsis of advanced options' + '\n' + '                '));
  }
  function parseArguments$readArg($receiver) {
    if (!$receiver.hasNext())
      return null;
    var v = $receiver.next();
    if (startsWith(v, '-'))
      return null;
    return v;
  }
  function parseArguments$printVersion(closure$program) {
    return function () {
      var tmp$;
      try {
        tmp$ = require('./package.json').version;
      }
       catch (e) {
        if (Kotlin.isType(e, Throwable)) {
          tmp$ = '<unknown>';
        }
         else
          throw e;
      }
      var version = tmp$;
      console.log(closure$program + ' version: ' + version);
    };
  }
  function parseArguments() {
    var readArg = parseArguments$readArg;
    var program = 'ts2kt';
    var printVersion = parseArguments$printVersion(program);
    var args = drop_0($module$process.argv, 2);
    if (args.isEmpty()) {
      printUsage(program);
      return null;
    }
    var it = args.iterator();
    var other = ArrayList_init();
    var destination = null;
    var basePackage = null;
    var declareModifierIsOptional = false;
    while (it.hasNext()) {
      var arg = it.next();
      switch (arg) {
        case '-h':
          printUsage(program);
          return null;
        case '-d':
          var p = readArg(it);
          if (p == null) {
            console.error("'-d' should be followed by path to destination directory");
            return null;
          }

          destination = p;
          break;
        case '-l':
          console.error("'-l' not supported yet");
          return null;
        case '-p':
          var p_0 = readArg(it);
          if (p_0 == null) {
            console.error(arg + ' should be followed by base package fq-name');
            return null;
          }

          basePackage = p_0;
          break;
        case '-v':
        case '-version':
          printVersion();
          return null;
        case '-X':
          console.log(trimIndent('\n' + '                            Usage: ' + program + ' <options> <d.ts files>' + '\n' + '                            where possible options include:' + '\n' + '                                -Xdeclare-is-optional       Treat declare keyword for top level declarations as optional' + '\n' + '                                -Xdiagnostic-level <level>  How report diagnostics, ' + DiagnosticLevel$Companion_getInstance().DEFAULT + ' by default,' + '\n' + '                                        where level can be any of {' + joinToString_0(DiagnosticLevel$values()) + '}' + '\n' + '                                -Xtrack-unsupported-kinds   Enable tracking unsupported node kinds and print statistic at the finish' + '\n' + '                            '));
          return null;
        case '-Xdiagnostic-level':
          var p_1 = readArg(it);
          var level = p_1 != null ? DiagnosticLevel$valueOf(p_1) : null;
          if (level == null) {
            console.error("'-Xdiagnostic-level' should be followed by one of " + joinToString_0(DiagnosticLevel$values()));
            return null;
          }

          diagnosticLevel = level;
          break;
        case '-Xtrack-unsupported-kinds':
          trackUnsupportedKinds = true;
          break;
        case '-Xdeclare-is-optional':
          declareModifierIsOptional = true;
          break;
        default:other.add_11rb$(arg);
          break;
      }
    }
    var tmp$;
    var first = ArrayList_init();
    var second = ArrayList_init();
    tmp$ = other.iterator();
    while (tmp$.hasNext()) {
      var element = tmp$.next();
      if (startsWith(element, '-')) {
        first.add_11rb$(element);
      }
       else {
        second.add_11rb$(element);
      }
    }
    var allSources = (new Pair(first, second)).component2();
    var destination_0 = ArrayList_init();
    var tmp$_0;
    tmp$_0 = allSources.iterator();
    while (tmp$_0.hasNext()) {
      var element_0 = tmp$_0.next();
      if (endsWith(element_0, TYPESCRIPT_DEFINITION_FILE_EXT))
        destination_0.add_11rb$(element_0);
    }
    var sources = destination_0;
    printVersion();
    if (sources.size !== allSources.size) {
      console.error('ts2kt supports to convert only TypeScript definition files (d.ts)');
      return null;
    }
    if (sources.isEmpty()) {
      console.error('No files to convert');
      return null;
    }
    return new CliArguments(sources, destination != null ? destination : '.', basePackage, emptyList(), declareModifierIsOptional);
  }
  function main(args) {
    var tmp$;
    if (module.parent != null)
      return;
    tmp$ = parseArguments();
    if (tmp$ == null) {
      return;
    }
    var sources = tmp$.component1()
    , destination = tmp$.component2()
    , basePackage = tmp$.component3()
    , libraries = tmp$.component4()
    , declareModifierIsOptional = tmp$.component5();
    translateToDir(sources, destination, basePackage, libraries, declareModifierIsOptional);
    if (trackUnsupportedKinds) {
      reportUnsupportedKinds();
    }
  }
  var TYPESCRIPT_DEFINITION_FILE_EXT;
  var PATH_TO_LIB_D_TS;
  var file2scriptSnapshotCache;
  function getScriptSnapshotFromFile(path) {
    var scriptSnapshot = file2scriptSnapshotCache.get_11rb$(path);
    if (scriptSnapshot == null) {
      scriptSnapshot = fromString($module$fs.readFileSync(path).toString());
      var $receiver = file2scriptSnapshotCache;
      var value = scriptSnapshot;
      $receiver.put_xwzc9p$(path, value);
    }
    return scriptSnapshot;
  }
  var LIB_D_TS_WITH_SNAPSHOT;
  var host;
  var documentRegistry;
  var languageService;
  function translate$isOverrideHelper$forEachBaseTypeNode(closure$typechecker, closure$visited, closure$f, closure$nodeName) {
    return function closure$forEachBaseTypeNode($receiver) {
      var tmp$, tmp$_0, tmp$_1, tmp$_2, tmp$_3, tmp$_4, tmp$_5, tmp$_6, tmp$_7, tmp$_8;
      tmp$ = $receiver.heritageClauses;
      if (tmp$ == null) {
        return false;
      }
      var heritages = tmp$;
      for (tmp$_0 = 0; tmp$_0 !== heritages.length; ++tmp$_0) {
        var heritage = heritages[tmp$_0];
        tmp$_1 = heritage.types;
        if (tmp$_1 == null) {
          continue;
        }
        var types = tmp$_1;
        for (tmp$_2 = 0; tmp$_2 !== types.length; ++tmp$_2) {
          var typeNode = types[tmp$_2];
          tmp$_3 = closure$typechecker.getTypeAtLocation(typeNode);
          if (tmp$_3 == null) {
            continue;
          }
          var type = tmp$_3;
          if (!closure$visited.add_11rb$(type))
            continue;
          if (closure$f(closure$typechecker, type, closure$nodeName))
            return true;
          if ((tmp$_8 = (tmp$_7 = Kotlin.isType(tmp$_6 = (tmp$_5 = (tmp$_4 = type.symbol) != null ? tmp$_4.declarations : null) != null ? tmp$_5[0] : null, Object) ? tmp$_6 : null) != null ? closure$forEachBaseTypeNode(tmp$_7) : null) != null ? tmp$_8 : false)
            return true;
        }
      }
      return false;
    };
  }
  var HashSet_init = Kotlin.kotlin.collections.HashSet_init_287e2$;
  function translate$isOverrideHelper(node, f) {
    var tmp$;
    var parentNode = ensureNotNull(node.parent);
    if (parentNode.heritageClauses == null)
      return false;
    var typechecker = languageService.getProgram().getTypeChecker();
    var nodeName = ensureNotNull((tmp$ = node.name) != null ? asString_0(tmp$) : null);
    var visited = HashSet_init();
    var forEachBaseTypeNode = translate$isOverrideHelper$forEachBaseTypeNode(typechecker, visited, f, nodeName);
    return forEachBaseTypeNode(parentNode);
  }
  function translate$isSubtypeOf($receiver, other) {
    var tmp$, tmp$_0;
    if (equals($receiver, other))
      return true;
    if ((other.flags & TypeFlags$Any) !== 0)
      return true;
    var tmp$_1;
    if ((tmp$ = $receiver.getBaseTypes()) != null) {
      translate$isSubtypeOf;
      var any$result;
      any$break: do {
        var tmp$_2;
        for (tmp$_2 = 0; tmp$_2 !== tmp$.length; ++tmp$_2) {
          var element = tmp$[tmp$_2];
          if (translate$isSubtypeOf(element, other)) {
            any$result = true;
            break any$break;
          }
        }
        any$result = false;
      }
       while (false);
      tmp$_1 = any$result;
    }
     else
      tmp$_1 = null;
    return (tmp$_0 = tmp$_1) != null ? tmp$_0 : false;
  }
  function translate$getTypeOfSymbol($receiver, symbol) {
    return $receiver.getTypeOfSymbolAtLocation(symbol, symbol.valueDeclaration);
  }
  function translate$isOverride(closure$getTypeOfSymbol) {
    return function ($receiver, candidate, other) {
      var tmp$;
      if (candidate.parameters.length !== other.parameters.length)
        return false;
      tmp$ = candidate.parameters;
      for (var i = 0; i !== tmp$.length; ++i) {
        var candidateType = closure$getTypeOfSymbol($receiver, candidate.parameters[i]);
        var otherType = closure$getTypeOfSymbol($receiver, other.parameters[i]);
        if (!equals(candidateType, otherType))
          return false;
      }
      return true;
    };
  }
  function translate$isOverride$lambda(closure$nodeSignature, closure$node, closure$isOverride) {
    return function (typechecker, type, nodeName) {
      var tmp$, tmp$_0, tmp$_1;
      closure$nodeSignature.v = (tmp$ = closure$nodeSignature.v) != null ? tmp$ : typechecker.getSignatureFromDeclaration(closure$node);
      var candidates = typechecker.getPropertyOfType(type, nodeName);
      var tmp$_2;
      if ((tmp$_0 = candidates != null ? candidates.declarations : null) != null) {
        var any$result;
        any$break: do {
          var tmp$_3;
          for (tmp$_3 = 0; tmp$_3 !== tmp$_0.length; ++tmp$_3) {
            var element = tmp$_0[tmp$_3];
            var closure$nodeSignature_0 = closure$nodeSignature;
            var closure$isOverride_0 = closure$isOverride;
            var predicate$result;
            predicate$break: do {
              var tmp$_4, tmp$_5, tmp$_6;
              if (element.kind === SyntaxKind$PropertyDeclaration || element.kind === SyntaxKind$PropertySignature) {
                predicate$result = false;
                break predicate$break;
              }
              tmp$_5 = Kotlin.isType(tmp$_4 = element.kind, Any) ? tmp$_4 : throwCCE();
              if (equals(tmp$_5, SyntaxKind$MethodSignature) || equals(tmp$_5, SyntaxKind$MethodDeclaration)) {
                tmp$_6 = typechecker.getSignatureFromDeclaration(element);
              }
               else {
                reportUnsupportedNode(element);
                predicate$result = false;
                break predicate$break;
              }
              var signature = tmp$_6;
              predicate$result = closure$isOverride_0(typechecker, ensureNotNull(closure$nodeSignature_0.v), signature);
            }
             while (false);
            if (predicate$result) {
              any$result = true;
              break any$break;
            }
          }
          any$result = false;
        }
         while (false);
        tmp$_2 = any$result;
      }
       else
        tmp$_2 = null;
      return (tmp$_1 = tmp$_2) != null ? tmp$_1 : false;
    };
  }
  function translate$isOverride_0(closure$isOverride, closure$isOverrideHelper) {
    return function (node) {
      var tmp$, tmp$_0, tmp$_1, tmp$_2;
      var params = node.parameters;
      switch ((tmp$ = node.name) != null ? tmp$.text : null) {
        case 'equals':
          var tmp$_3 = params.length === 1;
          if (tmp$_3) {
            tmp$_3 = (tmp$_1 = (tmp$_0 = params[0].type) != null ? tmp$_0.kind === SyntaxKind$AnyKeyword : null) != null ? tmp$_1 : true;
          }

          tmp$_2 = tmp$_3;
          break;
        case 'hashCode':
        case 'toString':
          tmp$_2 = params.length === 0;
          break;
        default:tmp$_2 = false;
          break;
      }
      if (tmp$_2)
        return true;
      var nodeSignature = {v: null};
      return closure$isOverrideHelper(node, translate$isOverride$lambda(nodeSignature, node, closure$isOverride));
    };
  }
  function translate$isOverrideProperty$lambda(typechecker, type, nodeName) {
    return typechecker.getPropertyOfType(type, nodeName) != null;
  }
  function translate$isOverrideProperty(closure$isOverrideHelper) {
    return function (node) {
      return closure$isOverrideHelper(node, translate$isOverrideProperty$lambda);
    };
  }
  function translate$lambda(closure$normalizeSrcPath) {
    return function (it) {
      var definitions = languageService.getDefinitionAtPosition(closure$normalizeSrcPath, it.end);
      var all$result;
      all$break: do {
        var tmp$;
        for (tmp$ = 0; tmp$ !== definitions.length; ++tmp$) {
          var element = definitions[tmp$];
          var closure$normalizeSrcPath_0 = closure$normalizeSrcPath;
          if (!equals(element.fileName, closure$normalizeSrcPath_0)) {
            all$result = false;
            break all$break;
          }
        }
        all$result = true;
      }
       while (false);
      return all$result;
    };
  }
  var Map = Kotlin.kotlin.collections.Map;
  function translate(srcPath, basePackageName, declareModifierIsOptional) {
    if (declareModifierIsOptional === void 0)
      declareModifierIsOptional = false;
    var tmp$;
    var normalizeSrcPath = normalizePath(srcPath);
    var file2scriptSnapshot = hashMapOf([LIB_D_TS_WITH_SNAPSHOT, to(normalizeSrcPath, getScriptSnapshotFromFile(normalizeSrcPath))]);
    var filesToProcess = [normalizeSrcPath];
    while (!(filesToProcess.length === 0)) {
      var curFile = filesToProcess.shift();
      var curDir = getDirectoryPath(curFile) + '/';
      var result = preProcessFile(ensureNotNull(file2scriptSnapshot.get_11rb$(curFile)).getText());
      var referencedFiles = result.referencedFiles;
      for (tmp$ = 0; tmp$ !== referencedFiles.length; ++tmp$) {
        var referencedFile = referencedFiles[tmp$];
        var referencedFilePath = normalizePath(curDir + referencedFile.fileName);
        var tmp$_0;
        if ((Kotlin.isType(tmp$_0 = file2scriptSnapshot, Map) ? tmp$_0 : throwCCE()).containsKey_11rb$(referencedFilePath))
          continue;
        filesToProcess.push(referencedFilePath);
        var value = getScriptSnapshotFromFile(referencedFilePath);
        file2scriptSnapshot.put_xwzc9p$(referencedFilePath, value);
      }
    }
    host.file2scriptSnapshot = file2scriptSnapshot;
    host.currentDirectory = getDirectoryPath(normalizeSrcPath);
    var fileNode = languageService.getProgram().getSourceFile(normalizeSrcPath);
    var isOverrideHelper = translate$isOverrideHelper;
    var isSubtypeOf = translate$isSubtypeOf;
    var getTypeOfSymbol = translate$getTypeOfSymbol;
    var isOverride = translate$isOverride(getTypeOfSymbol);
    var isOverride_0 = translate$isOverride_0(isOverride, isOverrideHelper);
    var isOverrideProperty = translate$isOverrideProperty(isOverrideHelper);
    ObjectTypeToKotlinTypeMapperImpl$Companion_getInstance().reset();
    var typeChecker = languageService.getProgram().getTypeChecker();
    var rootBuilder = new KtPackagePartBuilder(null, null, '');
    var context = new ConverterContext();
    context.packageParts.add_11rb$(rootBuilder);
    var typeMapper = new ObjectTypeToKotlinTypeMapperImpl(typeChecker, DEFAULT_ANNOTATION, rootBuilder.members, '');
    var typeScriptToKotlin = new TypeScriptToKotlin(context, rootBuilder, typeChecker, rootBuilder.members, DEFAULT_ANNOTATION, declareModifierIsOptional ? null : SyntaxKind$DeclareKeyword, typeMapper, void 0, translate$lambda(normalizeSrcPath), getCallableRef('isOverride', function (node) {
      return isOverride_0(node);
    }), getCallableRef('isOverrideProperty', function (node) {
      return isOverrideProperty(node);
    }), emptyList());
    typeScriptToKotlin.visitList_uvf806$(fileNode);
    var $receiver = withMissedOverloads(merge(build(context)));
    var destination = ArrayList_init();
    var tmp$_1;
    tmp$_1 = $receiver.iterator();
    while (tmp$_1.hasNext()) {
      var element = tmp$_1.next();
      var $receiver_0 = element.members;
      var predicate = isNotAnnotatedAsFake;
      var any$result;
      any$break: do {
        var tmp$_2;
        if (Kotlin.isType($receiver_0, Collection) && $receiver_0.isEmpty()) {
          any$result = false;
          break any$break;
        }
        tmp$_2 = $receiver_0.iterator();
        while (tmp$_2.hasNext()) {
          var element_0 = tmp$_2.next();
          if (predicate(element_0)) {
            any$result = true;
            break any$break;
          }
        }
        any$result = false;
      }
       while (false);
      if (any$result)
        destination.add_11rb$(element);
    }
    return destination;
  }
  var cast = defineInlineFunction('ts2kt.ts2kt.utils.cast_3752g7$', function ($receiver) {
    return $receiver;
  });
  function join($receiver, delimiter, start, end, startWithIfNotEmpty, endWithIfNotEmpty, filter, stringify) {
    if (delimiter === void 0)
      delimiter = ', ';
    if (start === void 0)
      start = '';
    if (end === void 0)
      end = '';
    if (startWithIfNotEmpty === void 0)
      startWithIfNotEmpty = '';
    if (endWithIfNotEmpty === void 0)
      endWithIfNotEmpty = '';
    if (filter === void 0)
      filter = null;
    if (stringify === void 0)
      stringify = null;
    var tmp$;
    if ($receiver.isEmpty())
      return start + end;
    var s = '';
    var first = true;
    tmp$ = $receiver.iterator();
    while (tmp$.hasNext()) {
      var e = tmp$.next();
      if (filter != null && !filter(e))
        continue;
      if (!first) {
        s += delimiter;
      }
       else {
        first = false;
      }
      s += stringify == null ? toString(e) : stringify(e);
    }
    if (first)
      return start + end;
    return start + startWithIfNotEmpty + s + endWithIfNotEmpty + end;
  }
  function merge_0($receiver, acceptor, comparator, merger) {
    var $receiver_0 = toMutableList($receiver);
    merge_1($receiver_0, acceptor, comparator, merger);
    return $receiver_0;
  }
  function merge_1($receiver, acceptor, comparator, merger) {
    var i = 0;
    while (i < $receiver.size) {
      var current = $receiver.get_za3lpa$(i);
      if (!acceptor(current)) {
        i = i + 1 | 0;
        continue;
      }
      var candidates = ArrayList_init();
      var size = $receiver.size;
      var j = i + 1 | 0;
      while (j < size) {
        var e = $receiver.get_za3lpa$(j);
        if (!acceptor(e)) {
          j = j + 1 | 0;
          continue;
        }
        if (comparator(current, e)) {
          candidates.add_11rb$(j);
        }
        j = j + 1 | 0;
      }
      if (!candidates.isEmpty()) {
        mergeAllTo($receiver, i, candidates, merger);
      }
      i = i + 1 | 0;
    }
  }
  function mergeAllTo($receiver, mergeTo, candidateIndexes, merger) {
    var tmp$;
    var acc = $receiver.get_za3lpa$(mergeTo);
    var indexesToRemove = LinkedHashSet_init();
    tmp$ = candidateIndexes.iterator();
    while (tmp$.hasNext()) {
      var i = tmp$.next();
      var result = merger(acc, $receiver.get_za3lpa$(i));
      if (result != null) {
        acc = result;
        indexesToRemove.add_11rb$(i);
      }
    }
    $receiver.set_wxm5ur$(mergeTo, acc);
    var tmp$_0;
    tmp$_0 = sortedDescending(indexesToRemove).iterator();
    while (tmp$_0.hasNext()) {
      var element = tmp$_0.next();
      $receiver.removeAt_za3lpa$(element);
    }
  }
  var push = defineInlineFunction('ts2kt.ts2kt.utils.push_dxn8qf$', function ($receiver, element) {
    $receiver.push(element);
  });
  var shift = defineInlineFunction('ts2kt.ts2kt.utils.shift_4b5429$', function ($receiver) {
    return $receiver.shift();
  });
  var splice = defineInlineFunction('ts2kt.ts2kt.utils.splice_oo2f0p$', function ($receiver, index, removeCount, newItem) {
    return $receiver.splice(index, removeCount, newItem);
  });
  var package$ts2kt = _.ts2kt || (_.ts2kt = {});
  package$ts2kt.FileSystemBasedLSH = FileSystemBasedLSH;
  var package$kotlin = package$ts2kt.kotlin || (package$ts2kt.kotlin = {});
  var package$ast = package$kotlin.ast || (package$kotlin.ast = {});
  package$ast.KtVisitor = KtVisitor;
  package$ast.Output = Output;
  package$ast.indent_iwwqb4$ = indent;
  Object.defineProperty(package$ast, 'NO_IMPL', {
    get: function () {
      return NO_IMPL;
    }
  });
  package$ast.Stringify = Stringify;
  Object.defineProperty(package$ast, 'MODULE', {
    get: function () {
      return MODULE;
    }
  });
  Object.defineProperty(package$ast, 'FAKE_ANNOTATION', {
    get: function () {
      return FAKE_ANNOTATION;
    }
  });
  Object.defineProperty(package$ast, 'DEFAULT_FAKE_ANNOTATION', {
    get: function () {
      return DEFAULT_FAKE_ANNOTATION;
    }
  });
  Object.defineProperty(package$ast, 'isNotAnnotatedAsFake_8be2vx$', {
    get: function () {
      return isNotAnnotatedAsFake;
    }
  });
  package$ast.KtNode = KtNode;
  package$ast.AbstractKtNode = AbstractKtNode;
  package$ast.KtWithMembers = KtWithMembers;
  package$ast.KtPackagePart = KtPackagePart;
  Object.defineProperty(KtName, 'Companion', {
    get: KtName$Companion_getInstance
  });
  package$ast.KtName = KtName;
  package$ast.KtQualifiedName_init_2tak4a$ = KtQualifiedName_init;
  package$ast.KtQualifiedName = KtQualifiedName;
  package$ast.KtNamed = KtNamed;
  package$ast.KtAnnotated = KtAnnotated;
  package$ast.KtMember = KtMember;
  package$ast.KtArgument = KtArgument;
  package$ast.KtAnnotation = KtAnnotation;
  Object.defineProperty(KtClassKind, 'CLASS', {
    get: KtClassKind$CLASS_getInstance
  });
  Object.defineProperty(KtClassKind, 'INTERFACE', {
    get: KtClassKind$INTERFACE_getInstance
  });
  Object.defineProperty(KtClassKind, 'ENUM', {
    get: KtClassKind$ENUM_getInstance
  });
  Object.defineProperty(KtClassKind, 'OBJECT', {
    get: KtClassKind$OBJECT_getInstance
  });
  Object.defineProperty(KtClassKind, 'COMPANION_OBJECT', {
    get: KtClassKind$COMPANION_OBJECT_getInstance
  });
  package$ast.KtClassKind = KtClassKind;
  package$ast.KtClassifier = KtClassifier;
  package$ast.KtFunParam = KtFunParam;
  package$ast.KtCallSignature = KtCallSignature;
  package$ast.KtFunction = KtFunction;
  package$ast.KtVariable = KtVariable;
  package$ast.KtEnumEntry = KtEnumEntry;
  package$ast.KtHeritageType = KtHeritageType;
  package$ast.KtTypeUnion_9gkjnr$ = KtTypeUnion;
  package$ast.KtTypeUnion = KtTypeUnion_0;
  package$ast.KtType = KtType;
  package$ast.starType = starType;
  package$ast.KtTypeParam = KtTypeParam;
  package$ast.KtTypeAnnotation = KtTypeAnnotation;
  package$ast.stringify_22ngql$ = stringify;
  package$ast.stringify_nmavzd$ = stringify_0;
  package$ast.getFirstParamAsString_pqshe8$ = getFirstParamAsString;
  package$ast.isModule_c2z4xu$ = isModule;
  package$ast.hasModuleAnnotation_c2z4xu$ = hasModuleAnnotation;
  package$ast.getClassObject_c2z4xu$ = getClassObject;
  package$ast.createFunctionType_gor12u$ = createFunctionType;
  $$importsForInline$$.ts2kt = _;
  package$ts2kt.Visitor = Visitor;
  var package$utils = package$ts2kt.utils || (package$ts2kt.utils = {});
  package$utils.reportUnsupportedNode_uvf806$ = reportUnsupportedNode;
  package$ts2kt.unsupported_uvf806$ = unsupported;
  Object.defineProperty(package$ts2kt, 'ANY', {
    get: function () {
      return ANY;
    }
  });
  Object.defineProperty(package$ts2kt, 'NOTHING', {
    get: function () {
      return NOTHING;
    }
  });
  Object.defineProperty(package$ts2kt, 'NUMBER', {
    get: function () {
      return NUMBER;
    }
  });
  Object.defineProperty(package$ts2kt, 'STRING', {
    get: function () {
      return STRING;
    }
  });
  Object.defineProperty(package$ts2kt, 'BOOLEAN', {
    get: function () {
      return BOOLEAN;
    }
  });
  Object.defineProperty(package$ts2kt, 'UNIT', {
    get: function () {
      return UNIT;
    }
  });
  Object.defineProperty(package$ts2kt, 'DYNAMIC', {
    get: function () {
      return DYNAMIC;
    }
  });
  Object.defineProperty(package$ts2kt, 'ARRAY', {
    get: function () {
      return ARRAY;
    }
  });
  Object.defineProperty(package$ts2kt, 'NOTHING_TYPE', {
    get: function () {
      return NOTHING_TYPE;
    }
  });
  Object.defineProperty(package$ts2kt, 'SHOULD_BE_ESCAPED', {
    get: function () {
      return SHOULD_BE_ESCAPED;
    }
  });
  Object.defineProperty(package$ts2kt, 'NOT_OVERRIDE', {
    get: function () {
      return NOT_OVERRIDE;
    }
  });
  package$ts2kt.escapeIfNeed_pdl1vz$ = escapeIfNeed;
  package$ts2kt.sanitize_pdl1vz$ = sanitize;
  package$ts2kt.get_isVararg_vn0qu$ = get_isVararg;
  package$ts2kt.toKotlinParam_58p3ac$ = toKotlinParam;
  package$ts2kt.toKotlinParamOverloads_58p3ac$ = toKotlinParamOverloads;
  package$ts2kt.toKotlinParamsOverloads_nexzm9$ = toKotlinParamsOverloads;
  package$ts2kt.toKotlinParams_nexzm9$ = toKotlinParams;
  package$ts2kt.toKotlinTypeParams_oqytn9$ = toKotlinTypeParams;
  package$ts2kt.toKotlinTypeParam_n2w6m6$ = toKotlinTypeParam;
  package$ts2kt.toKotlinCallSignatureOverloads_vrhhij$ = toKotlinCallSignatureOverloads;
  package$ts2kt.toKotlinCallSignature_vrhhij$ = toKotlinCallSignature;
  package$ts2kt.toKotlinCallSignature_8updhq$ = toKotlinCallSignature_0;
  package$ts2kt.toKotlinType_2bmiu8$ = toKotlinType;
  package$ts2kt.toKotlinType_vrhhij$ = toKotlinType_0;
  package$ts2kt.toKotlinTypeUnion_4psmbz$ = toKotlinTypeUnion_0;
  package$ts2kt.toKotlinType_4psmbz$ = toKotlinType_2;
  package$ts2kt.toKotlinTypeName_x80yjn$ = toKotlinTypeName;
  package$ts2kt.toKotlinTypeUnion_ml8u72$ = toKotlinTypeUnion_1;
  package$ts2kt.toKotlinType_ogcl2v$ = toKotlinType_3;
  package$ts2kt.toKotlinTypeUnion_jcgfca$ = toKotlinTypeUnion_2;
  package$ts2kt.toKotlinTypeUnion_bxfq20$ = toKotlinTypeUnion_3;
  package$ts2kt.toKotlinType_pptu9f$ = toKotlinType_4;
  package$ts2kt.toKotlinType_d9acs6$ = toKotlinType_5;
  package$ts2kt.toKotlinType_wppmt5$ = toKotlinType_6;
  package$ts2kt.forEachChild_elwn1m$ = forEachChild_0;
  package$ts2kt.visitNode_qofihj$ = visitNode;
  package$ts2kt.get_arr_zcybyc$ = get_arr;
  $$importsForInline$$.typescript = $module$typescript;
  package$ts2kt.get_str_g3v1o4$ = get_str;
  package$ts2kt.get_id_g3v1o4$ = get_id;
  package$ts2kt.get_unescapedText_viuja6$ = get_unescapedText;
  package$ts2kt.location_xnn6i1$ = location;
  package$ts2kt.contains_aufjat$ = contains;
  package$ts2kt.getSymbolResolvingAliases_nqfym6$ = getSymbolResolvingAliases;
  package$ts2kt.toStringKey_geq3bk$ = toStringKey;
  var package$converter = _.converter || (_.converter = {});
  package$converter.BaseVisitor = BaseVisitor;
  package$converter.ConverterContext = ConverterContext;
  package$converter.build_1jg4du$ = build;
  package$converter.KtPackagePartBuilder = KtPackagePartBuilder;
  package$ts2kt.TsClassToKt = TsClassToKt;
  package$ts2kt.TsClassifierToKt = TsClassifierToKt;
  package$ts2kt.TsInterfaceToKt = TsInterfaceToKt;
  package$ts2kt.TsInterfaceToKtExtensions = TsInterfaceToKtExtensions;
  Object.defineProperty(package$ts2kt, 'NATIVE_ANNOTATION', {
    get: function () {
      return NATIVE_ANNOTATION;
    }
  });
  Object.defineProperty(package$ts2kt, 'NATIVE_GETTER_ANNOTATION_8be2vx$', {
    get: function () {
      return NATIVE_GETTER_ANNOTATION;
    }
  });
  Object.defineProperty(package$ts2kt, 'NATIVE_SETTER_ANNOTATION_8be2vx$', {
    get: function () {
      return NATIVE_SETTER_ANNOTATION;
    }
  });
  Object.defineProperty(package$ts2kt, 'NATIVE_INVOKE_ANNOTATION_8be2vx$', {
    get: function () {
      return NATIVE_INVOKE_ANNOTATION;
    }
  });
  Object.defineProperty(package$ts2kt, 'DEFAULT_ANNOTATION_8be2vx$', {
    get: function () {
      return DEFAULT_ANNOTATION;
    }
  });
  Object.defineProperty(package$ts2kt, 'NO_ANNOTATIONS_8be2vx$', {
    get: function () {
      return NO_ANNOTATIONS;
    }
  });
  Object.defineProperty(package$ts2kt, 'INVOKE_8be2vx$', {
    get: function () {
      return INVOKE;
    }
  });
  Object.defineProperty(package$ts2kt, 'GET_8be2vx$', {
    get: function () {
      return GET;
    }
  });
  Object.defineProperty(package$ts2kt, 'SET_8be2vx$', {
    get: function () {
      return SET;
    }
  });
  Object.defineProperty(package$ts2kt, 'COMPARE_BY_NAME_8be2vx$', {
    get: function () {
      return COMPARE_BY_NAME;
    }
  });
  Object.defineProperty(package$ts2kt, 'IS_NATIVE_ANNOTATION_8be2vx$', {
    get: function () {
      return IS_NATIVE_ANNOTATION;
    }
  });
  package$ts2kt.TypeScriptToKotlin = TypeScriptToKotlin;
  package$ts2kt.TypeScriptToKotlinBase = TypeScriptToKotlinBase;
  package$ts2kt.createClassifier_i0th2b$ = createClassifier;
  package$ts2kt.createClassifier_540sl8$ = createClassifier_0;
  Object.defineProperty(package$ts2kt, 'JS_MODULE', {
    get: function () {
      return JS_MODULE;
    }
  });
  Object.defineProperty(package$ts2kt, 'JS_QUALIFIER', {
    get: function () {
      return JS_QUALIFIER;
    }
  });
  package$ts2kt.moduleAnnotation_61zpoe$ = moduleAnnotation;
  package$ts2kt.jsNameAnnotation_61zpoe$ = jsNameAnnotation;
  package$ts2kt.asString_9i64q3$ = asString;
  package$ts2kt.asString_qs5dsi$ = asString_0;
  package$ts2kt.ObjectTypeToKotlinTypeMapper = ObjectTypeToKotlinTypeMapper;
  Object.defineProperty(ObjectTypeToKotlinTypeMapperImpl, 'Companion', {
    get: ObjectTypeToKotlinTypeMapperImpl$Companion_getInstance
  });
  package$ts2kt.ObjectTypeToKotlinTypeMapperImpl = ObjectTypeToKotlinTypeMapperImpl;
  package$ts2kt.merge_rjnvub$ = merge;
  package$ts2kt.mergeClassesAndPackages_ximes6$ = mergeClassesAndPackages;
  package$ts2kt.withMissedOverloads_rjnvub$ = withMissedOverloads;
  package$converter.mapType_xaq5kd$ = mapType;
  package$converter.mapTypeToUnion_xaq5kd$ = mapTypeToUnion;
  package$converter.replaceTypeParameters_yn8s40$ = replaceTypeParameters;
  var package$typescriptServices = _.typescriptServices || (_.typescriptServices = {});
  var package$ts = package$typescriptServices.ts || (package$typescriptServices.ts = {});
  package$ts.UnionOrIntersectionTypeNode = UnionOrIntersectionTypeNode;
  package$ts.get_declarationName_jhg893$ = get_declarationName;
  package$ts.get_identifierName_snzh8q$ = get_identifierName;
  package$ts.get_identifierName_5s6jds$ = get_identifierName_0;
  package$ts.get_propertyName_nwtuk7$ = get_propertyName;
  package$ts.get_propertyName_ih1unk$ = get_propertyName_0;
  package$ts.get_propertyName_prku36$ = get_propertyName_1;
  package$ts.get_propertyName_1v1vnl$ = get_propertyName_2;
  package$ts.get_propertyName_i42fc9$ = get_propertyName_3;
  package$ts.get_identifierName_gcxvwa$ = get_identifierName_1;
  package$ts.get_declarationName_czbci4$ = get_declarationName_0;
  package$ts.get_propertyName_7v1fh7$ = get_propertyName_4;
  package$ts.get_identifierName_x5rxe7$ = get_identifierName_2;
  package$ts.get_propertyName_jnf2ws$ = get_propertyName_5;
  package$ts.get_propertyName_va8bie$ = get_propertyName_6;
  package$ts.set_propertyName_vxqxz6$ = set_propertyName;
  package$ts.get_propertyName_68a97k$ = get_propertyName_7;
  package$ts.get_identifierName_jlyuxx$ = get_identifierName_3;
  package$ts.get_identifierName_j6kl1i$ = get_identifierName_4;
  package$ts.get_identifierName_uulvm1$ = get_identifierName_5;
  package$ts.get_identifierName_p0tzpc$ = get_identifierName_6;
  package$ts.set_identifierName_x4zda$ = set_identifierName;
  package$ts.get_identifierName_a9aw95$ = get_identifierName_7;
  package$ts.set_identifierName_2zh5fb$ = set_identifierName_0;
  package$ts.get_propertyName_q9hz09$ = get_propertyName_8;
  package$ts.get_propertyName_rgranj$ = get_propertyName_9;
  package$ts.get_identifierName_d15va$ = get_identifierName_8;
  package$ts.get_identifierName_ewxmrr$ = get_identifierName_9;
  package$ts.set_identifierName_eya9g$ = set_identifierName_1;
  package$ts.get_declarationName_w16434$ = get_declarationName_1;
  package$ts.get_identifierName_rferdy$ = get_identifierName_10;
  package$ts.get_identifierName_23mu59$ = get_identifierName_11;
  package$ts.get_identifierName_8phqdc$ = get_identifierName_12;
  package$ts.get_identifierName_fs3q0n$ = get_identifierName_13;
  package$ts.set_identifierName_9rwuhn$ = set_identifierName_2;
  package$ts.get_identifierName_rlpjmb$ = get_identifierName_14;
  package$ts.get_identifierName_287i12$ = get_identifierName_15;
  package$ts.get_identifierName_lob3gp$ = get_identifierName_16;
  Object.defineProperty(DiagnosticLevel, 'EXCEPTION', {
    get: DiagnosticLevel$EXCEPTION_getInstance
  });
  Object.defineProperty(DiagnosticLevel, 'WARNING_WITH_STACKTRACE', {
    get: DiagnosticLevel$WARNING_WITH_STACKTRACE_getInstance
  });
  Object.defineProperty(DiagnosticLevel, 'WARNING', {
    get: DiagnosticLevel$WARNING_getInstance
  });
  Object.defineProperty(DiagnosticLevel, 'QUIET', {
    get: DiagnosticLevel$QUIET_getInstance
  });
  Object.defineProperty(DiagnosticLevel, 'Companion', {
    get: DiagnosticLevel$Companion_getInstance
  });
  package$utils.DiagnosticLevel = DiagnosticLevel;
  Object.defineProperty(package$utils, 'diagnosticLevel_8be2vx$', {
    get: function () {
      return diagnosticLevel;
    },
    set: function (value) {
      diagnosticLevel = value;
    }
  });
  package$utils.report_hk9j7g$ = report;
  package$utils.assert_8kj6y5$ = assert;
  Object.defineProperty(package$utils, 'trackUnsupportedKinds_8be2vx$', {
    get: function () {
      return trackUnsupportedKinds;
    },
    set: function (value) {
      trackUnsupportedKinds = value;
    }
  });
  package$utils.reportUnsupportedNodeAndGetMessage_uvf806$ = reportUnsupportedNodeAndGetMessage;
  package$utils.reportUnsupportedKinds = reportUnsupportedKinds;
  package$ts2kt.translateToFile_puj7f4$ = translateToFile;
  package$ts2kt.translateToDir_bro5pk$ = translateToDir;
  package$ts2kt.CliArguments = CliArguments;
  package$ts2kt.parseArguments = parseArguments;
  package$ts2kt.main_kand9s$ = main;
  Object.defineProperty(package$ts2kt, 'TYPESCRIPT_DEFINITION_FILE_EXT_8be2vx$', {
    get: function () {
      return TYPESCRIPT_DEFINITION_FILE_EXT;
    }
  });
  package$ts2kt.translate_qz9155$ = translate;
  package$utils.cast_3752g7$ = cast;
  package$utils.join_57z5yl$ = join;
  package$utils.merge_wtasr7$ = merge_0;
  package$utils.push_dxn8qf$ = push;
  package$utils.shift_4b5429$ = shift;
  package$utils.splice_oo2f0p$ = splice;
  TypeScriptToKotlinBase.prototype.visitModuleDeclaration_ezg4eu$ = Visitor.prototype.visitModuleDeclaration_ezg4eu$;
  TypeScriptToKotlinBase.prototype.visitFunctionDeclaration_eywj3y$ = Visitor.prototype.visitFunctionDeclaration_eywj3y$;
  TypeScriptToKotlinBase.prototype.visitTypeAliasDeclaration_it7xrc$ = Visitor.prototype.visitTypeAliasDeclaration_it7xrc$;
  TypeScriptToKotlinBase.prototype.visitVariableStatement_x0poxd$ = Visitor.prototype.visitVariableStatement_x0poxd$;
  TypeScriptToKotlinBase.prototype.visitEnumDeclaration_1emvp1$ = Visitor.prototype.visitEnumDeclaration_1emvp1$;
  TypeScriptToKotlinBase.prototype.visitClassDeclaration_4wvyue$ = Visitor.prototype.visitClassDeclaration_4wvyue$;
  TypeScriptToKotlinBase.prototype.visitInterfaceDeclaration_f4u3$ = Visitor.prototype.visitInterfaceDeclaration_f4u3$;
  TypeScriptToKotlinBase.prototype.visitHeritageClause_10qtta$ = Visitor.prototype.visitHeritageClause_10qtta$;
  TypeScriptToKotlinBase.prototype.visitConstructorDeclaration_cz84f8$ = Visitor.prototype.visitConstructorDeclaration_cz84f8$;
  TypeScriptToKotlinBase.prototype.visitConstructSignatureDeclaration_cz84f8$ = Visitor.prototype.visitConstructSignatureDeclaration_cz84f8$;
  TypeScriptToKotlinBase.prototype.visitMethodDeclaration_7vsj57$ = Visitor.prototype.visitMethodDeclaration_7vsj57$;
  TypeScriptToKotlinBase.prototype.visitPropertyDeclaration_qnxew1$ = Visitor.prototype.visitPropertyDeclaration_qnxew1$;
  TypeScriptToKotlinBase.prototype.visitIndexSignature_53if9s$ = Visitor.prototype.visitIndexSignature_53if9s$;
  TypeScriptToKotlinBase.prototype.visitSignatureDeclaration_vb212e$ = Visitor.prototype.visitSignatureDeclaration_vb212e$;
  TypeScriptToKotlinBase.prototype.visitExportAssignment_fybyfv$ = Visitor.prototype.visitExportAssignment_fybyfv$;
  NO_IMPL = 'definedExternally';
  EQ_NO_IMPL = ' = definedExternally';
  NO_IMPL_PROPERTY_GETTER = ' get()' + EQ_NO_IMPL;
  NO_IMPL_PROPERTY_SETTER = ' set(value)' + EQ_NO_IMPL;
  EXTERNAL = 'external';
  OPEN = 'open';
  OVERRIDE = 'override';
  OPERATOR = 'operator';
  VAR = 'var';
  VAL = 'val';
  FUN = 'fun';
  VARARG = 'vararg';
  MODULE = new KtName('module');
  FAKE = new KtName('fake');
  FAKE_ANNOTATION = new KtAnnotation(FAKE);
  DEFAULT_FAKE_ANNOTATION = listOf(FAKE_ANNOTATION);
  isNotAnnotatedAsFake = isNotAnnotatedAsFake$lambda;
  ANY = KtQualifiedName_init('Any');
  NOTHING = KtQualifiedName_init('Nothing');
  NUMBER = KtQualifiedName_init('Number');
  STRING = KtQualifiedName_init('String');
  BOOLEAN = KtQualifiedName_init('Boolean');
  UNIT = KtQualifiedName_init('Unit');
  DYNAMIC = KtQualifiedName_init('dynamic');
  ARRAY = KtQualifiedName_init('Array');
  NOTHING_TYPE = new KtType(NOTHING, void 0, void 0, true);
  SHOULD_BE_ESCAPED = setOf(['as', 'break', 'class', 'continue', 'do', 'else', 'false', 'for', 'fun', 'if', 'in', 'interface', 'is', 'null', 'object', 'package', 'return', 'super', 'this', 'throw', 'true', 'try', 'typealias', 'typeof', 'val', 'var', 'when', 'while']);
  NOT_OVERRIDE = NOT_OVERRIDE$lambda;
  OVERLOAD_GEN_THRESHOLD_FOR_TYPE_COUNT_ON_ONE_PARAMETER = 10;
  OVERLOAD_GEN_THRESHOLD_FOR_TOTAL_COUNT = 10;
  NATIVE = new KtName('native');
  NATIVE_ANNOTATION = new KtAnnotation(NATIVE);
  NATIVE_GETTER_ANNOTATION = new KtAnnotation(new KtName('nativeGetter'));
  NATIVE_SETTER_ANNOTATION = new KtAnnotation(new KtName('nativeSetter'));
  NATIVE_INVOKE_ANNOTATION = new KtAnnotation(new KtName('nativeInvoke'));
  DEFAULT_ANNOTATION = listOf(NATIVE_ANNOTATION);
  NO_ANNOTATIONS = emptyList();
  INVOKE = 'invoke';
  GET = 'get';
  SET = 'set';
  COMPARE_BY_NAME = COMPARE_BY_NAME$lambda;
  IS_NATIVE_ANNOTATION = IS_NATIVE_ANNOTATION$lambda;
  JS_MODULE = new KtName('JsModule');
  JS_QUALIFIER = new KtName('JsQualifier');
  JS_NAME = new KtName('JsName');
  diagnosticLevel = DiagnosticLevel$Companion_getInstance().DEFAULT;
  trackUnsupportedKinds = false;
  unsupportedKinds = HashMap_init();
  KOTLIN_FILE_EXT = '.kt';
  var NoSuchElementException_init = Kotlin.kotlin.NoSuchElementException;
  TYPESCRIPT_DEFINITION_FILE_EXT = '.d.ts';
  var tmp$ = listOf(getDefaultLibFilePath(getDefaultCompilerOptions()));
  var $receiver = listOf_0(['.', __dirname]);
  var destination = ArrayList_init(collectionSizeOrDefault($receiver, 10));
  var tmp$_0;
  tmp$_0 = $receiver.iterator();
  while (tmp$_0.hasNext()) {
    var item = tmp$_0.next();
    destination.add_11rb$(item + '/lib/lib.d.ts');
  }
  var $receiver_0 = plus(tmp$, destination);
  var first$result;
  first$break: do {
    var tmp$_1;
    tmp$_1 = $receiver_0.iterator();
    while (tmp$_1.hasNext()) {
      var element = tmp$_1.next();
      if ($module$fs.existsSync(element)) {
        first$result = element;
        break first$break;
      }
    }
    throw new NoSuchElementException_init('Collection contains no element matching the predicate.');
  }
   while (false);
  PATH_TO_LIB_D_TS = first$result;
  file2scriptSnapshotCache = HashMap_init();
  LIB_D_TS_WITH_SNAPSHOT = to('lib.d.ts', getScriptSnapshotFromFile(PATH_TO_LIB_D_TS));
  host = new FileSystemBasedLSH(emptyMap(), '');
  documentRegistry = createDocumentRegistry();
  languageService = createLanguageService(host, documentRegistry);
  main([]);
  Kotlin.defineModule('ts2kt', _);
  return _;
}(module.exports, require('./kotlin'), require('typescript'), require('path'), require('fs'), require('process')));

//# sourceMappingURL=ts2kt.js.map
